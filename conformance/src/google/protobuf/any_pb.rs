// This file is generated by pecan 0.1.0, DO NOT EDIT!
// @generated
// source: google/protobuf/any.proto

#![allow(non_upper_case_globals)]
#![allow(unused_imports)]

use pecan::{
    codec,
    EnumType,
    Message,
    Result,
    Buf,
    BufMut,
    CodedInputStream,
    CodedOutputStream,
    encoded,
};
use std::collections::HashMap;

pub static DESCRIPTOR: &[u8] = &[
    10, 25, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117,
    102, 47, 97, 110, 121, 46, 112, 114, 111, 116, 111, 18, 15, 103, 111, 111,
    103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 66, 111, 10, 19,
    99, 111, 109, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111,
    98, 117, 102, 66, 8, 65, 110, 121, 80, 114, 111, 116, 111, 80, 1, 90,
    37, 103, 105, 116, 104, 117, 98, 46, 99, 111, 109, 47, 103, 111, 108, 97,
    110, 103, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 112, 116, 121, 112,
    101, 115, 47, 97, 110, 121, 162, 2, 3, 71, 80, 66, 170, 2, 30, 71,
    111, 111, 103, 108, 101, 46, 80, 114, 111, 116, 111, 98, 117, 102, 46, 87,
    101, 108, 108, 75, 110, 111, 119, 110, 84, 121, 112, 101, 115, 98, 6, 112,
    114, 111, 116, 111, 51,
];

#[derive(Clone, Debug, Default, PartialEq)]
pub struct Any {
    pub type_url: String,
    pub value: Vec<u8>,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for Any {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.type_url = s.read_string()?,
                18 => self.value = s.read_bytes()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !&self.type_url.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.type_url)?;
        }
        if !&self.value.is_empty() {
            s.write_raw_1_byte([18])?;
            s.write_bytes(&self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.type_url.is_empty() {
            n += {
                let l = self.type_url.len();
                1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.value.is_empty() {
            n += {
                let l = self.value.len();
                1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        n
    }
}

impl Any {
    pub const fn new() -> Any {
        Any {
            type_url: String::new(),
            value: Vec::new(),
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static Any {
        static DEFAULT: Any = Any::new();
        &DEFAULT
    }

    pub fn type_url(&self) -> &str { &self.type_url }

    pub fn clear_type_url(&mut self) { self.type_url = Default::default(); }

    pub fn set_type_url(&mut self, v: String) { self.type_url = v; }

    pub fn type_url_mut(&mut self) -> &mut String { &mut self.type_url }

    pub fn value(&self) -> &[u8] { &self.value }

    pub fn clear_value(&mut self) { self.value = Default::default(); }

    pub fn set_value(&mut self, v: Vec<u8>) { self.value = v; }

    pub fn value_mut(&mut self) -> &mut Vec<u8> { &mut self.value }
}
