// This file is generated by pecan 0.1.0, DO NOT EDIT!
// @generated
// source: google/protobuf/wrappers.proto

#![allow(non_upper_case_globals)]
#![allow(unused_imports)]

use pecan::{
    codec,
    EnumType,
    Message,
    Result,
    Buf,
    BufMut,
    CodedInputStream,
    CodedOutputStream,
    encoded,
};
use std::collections::HashMap;

pub static DESCRIPTOR: &[u8] = &[
    10, 30, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117,
    102, 47, 119, 114, 97, 112, 112, 101, 114, 115, 46, 112, 114, 111, 116, 111,
    18, 15, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117,
    102, 66, 124, 10, 19, 99, 111, 109, 46, 103, 111, 111, 103, 108, 101, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 66, 13, 87, 114, 97, 112, 112, 101,
    114, 115, 80, 114, 111, 116, 111, 80, 1, 90, 42, 103, 105, 116, 104, 117,
    98, 46, 99, 111, 109, 47, 103, 111, 108, 97, 110, 103, 47, 112, 114, 111,
    116, 111, 98, 117, 102, 47, 112, 116, 121, 112, 101, 115, 47, 119, 114, 97,
    112, 112, 101, 114, 115, 248, 1, 1, 162, 2, 3, 71, 80, 66, 170, 2,
    30, 71, 111, 111, 103, 108, 101, 46, 80, 114, 111, 116, 111, 98, 117, 102,
    46, 87, 101, 108, 108, 75, 110, 111, 119, 110, 84, 121, 112, 101, 115, 98,
    6, 112, 114, 111, 116, 111, 51,
];

#[derive(Clone, Debug, Default, PartialEq)]
pub struct DoubleValue {
    pub value: f64,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for DoubleValue {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                9 => self.value = s.read_f64()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0f64 != self.value {
            s.write_raw_1_byte([9])?;
            s.write_f64(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0f64 != self.value {
            n += 9;
        }
        n
    }
}

impl DoubleValue {
    pub const fn new() -> DoubleValue {
        DoubleValue {
            value: 0f64,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static DoubleValue {
        static DEFAULT: DoubleValue = DoubleValue::new();
        &DEFAULT
    }

    pub fn value(&self) -> f64 { self.value }

    pub fn clear_value(&mut self) { self.value = 0f64; }

    pub fn set_value(&mut self, v: f64) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct FloatValue {
    pub value: f32,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for FloatValue {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                13 => self.value = s.read_f32()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0f32 != self.value {
            s.write_raw_1_byte([13])?;
            s.write_f32(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0f32 != self.value {
            n += 5;
        }
        n
    }
}

impl FloatValue {
    pub const fn new() -> FloatValue {
        FloatValue {
            value: 0f32,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static FloatValue {
        static DEFAULT: FloatValue = FloatValue::new();
        &DEFAULT
    }

    pub fn value(&self) -> f32 { self.value }

    pub fn clear_value(&mut self) { self.value = 0f32; }

    pub fn set_value(&mut self, v: f32) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct Int64Value {
    pub value: i64,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for Int64Value {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.value = s.read_var_i64()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.value {
            s.write_raw_1_byte([8])?;
            s.write_var_i64(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.value {
            n += 1 + codec::varint_i64_bytes_len(self.value) as usize;
        }
        n
    }
}

impl Int64Value {
    pub const fn new() -> Int64Value {
        Int64Value {
            value: 0,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static Int64Value {
        static DEFAULT: Int64Value = Int64Value::new();
        &DEFAULT
    }

    pub fn value(&self) -> i64 { self.value }

    pub fn clear_value(&mut self) { self.value = 0; }

    pub fn set_value(&mut self, v: i64) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UInt64Value {
    pub value: u64,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for UInt64Value {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.value = s.read_var_u64()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.value {
            s.write_raw_1_byte([8])?;
            s.write_var_u64(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.value {
            n += 1 + codec::varint_u64_bytes_len(self.value) as usize;
        }
        n
    }
}

impl UInt64Value {
    pub const fn new() -> UInt64Value {
        UInt64Value {
            value: 0,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static UInt64Value {
        static DEFAULT: UInt64Value = UInt64Value::new();
        &DEFAULT
    }

    pub fn value(&self) -> u64 { self.value }

    pub fn clear_value(&mut self) { self.value = 0; }

    pub fn set_value(&mut self, v: u64) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct Int32Value {
    pub value: i32,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for Int32Value {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.value = s.read_var_i32()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.value {
            s.write_raw_1_byte([8])?;
            s.write_var_i32(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.value {
            n += 1 + codec::varint_i64_bytes_len(self.value as i64) as usize;
        }
        n
    }
}

impl Int32Value {
    pub const fn new() -> Int32Value {
        Int32Value {
            value: 0,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static Int32Value {
        static DEFAULT: Int32Value = Int32Value::new();
        &DEFAULT
    }

    pub fn value(&self) -> i32 { self.value }

    pub fn clear_value(&mut self) { self.value = 0; }

    pub fn set_value(&mut self, v: i32) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UInt32Value {
    pub value: u32,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for UInt32Value {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.value = s.read_var_u32()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.value {
            s.write_raw_1_byte([8])?;
            s.write_var_u32(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.value {
            n += 1 + codec::varint_u32_bytes_len(self.value) as usize;
        }
        n
    }
}

impl UInt32Value {
    pub const fn new() -> UInt32Value {
        UInt32Value {
            value: 0,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static UInt32Value {
        static DEFAULT: UInt32Value = UInt32Value::new();
        &DEFAULT
    }

    pub fn value(&self) -> u32 { self.value }

    pub fn clear_value(&mut self) { self.value = 0; }

    pub fn set_value(&mut self, v: u32) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct BoolValue {
    pub value: bool,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for BoolValue {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.value = s.read_bool()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if self.value {
            s.write_raw_1_byte([8])?;
            s.write_bool(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if self.value {
            n += 2;
        }
        n
    }
}

impl BoolValue {
    pub const fn new() -> BoolValue {
        BoolValue {
            value: false,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static BoolValue {
        static DEFAULT: BoolValue = BoolValue::new();
        &DEFAULT
    }

    pub fn value(&self) -> bool { self.value }

    pub fn clear_value(&mut self) { self.value = false; }

    pub fn set_value(&mut self, v: bool) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct StringValue {
    pub value: String,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for StringValue {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.value = s.read_string()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !&self.value.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.value.is_empty() {
            n += {
                let l = self.value.len();
                1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        n
    }
}

impl StringValue {
    pub const fn new() -> StringValue {
        StringValue {
            value: String::new(),
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static StringValue {
        static DEFAULT: StringValue = StringValue::new();
        &DEFAULT
    }

    pub fn value(&self) -> &str { &self.value }

    pub fn clear_value(&mut self) { self.value = Default::default(); }

    pub fn set_value(&mut self, v: String) { self.value = v; }

    pub fn value_mut(&mut self) -> &mut String { &mut self.value }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct BytesValue {
    pub value: Vec<u8>,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for BytesValue {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.value = s.read_bytes()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !&self.value.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_bytes(&self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.value.is_empty() {
            n += {
                let l = self.value.len();
                1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        n
    }
}

impl BytesValue {
    pub const fn new() -> BytesValue {
        BytesValue {
            value: Vec::new(),
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static BytesValue {
        static DEFAULT: BytesValue = BytesValue::new();
        &DEFAULT
    }

    pub fn value(&self) -> &[u8] { &self.value }

    pub fn clear_value(&mut self) { self.value = Default::default(); }

    pub fn set_value(&mut self, v: Vec<u8>) { self.value = v; }

    pub fn value_mut(&mut self) -> &mut Vec<u8> { &mut self.value }
}
