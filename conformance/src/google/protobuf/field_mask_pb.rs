// This file is generated by pecan 0.1.0, DO NOT EDIT!
// @generated
// source: google/protobuf/field_mask.proto

#![allow(non_upper_case_globals)]
#![allow(unused_imports)]

use pecan::{
    codec,
    EnumType,
    Message,
    Result,
    Buf,
    BufMut,
    CodedInputStream,
    CodedOutputStream,
    encoded,
};
use std::collections::HashMap;

pub static DESCRIPTOR: &[u8] = &[
    10, 32, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117,
    102, 47, 102, 105, 101, 108, 100, 95, 109, 97, 115, 107, 46, 112, 114, 111,
    116, 111, 18, 15, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111,
    98, 117, 102, 66, 140, 1, 10, 19, 99, 111, 109, 46, 103, 111, 111, 103,
    108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 66, 14, 70, 105, 101,
    108, 100, 77, 97, 115, 107, 80, 114, 111, 116, 111, 80, 1, 90, 57, 103,
    111, 111, 103, 108, 101, 46, 103, 111, 108, 97, 110, 103, 46, 111, 114, 103,
    47, 103, 101, 110, 112, 114, 111, 116, 111, 47, 112, 114, 111, 116, 111, 98,
    117, 102, 47, 102, 105, 101, 108, 100, 95, 109, 97, 115, 107, 59, 102, 105,
    101, 108, 100, 95, 109, 97, 115, 107, 248, 1, 1, 162, 2, 3, 71, 80,
    66, 170, 2, 30, 71, 111, 111, 103, 108, 101, 46, 80, 114, 111, 116, 111,
    98, 117, 102, 46, 87, 101, 108, 108, 75, 110, 111, 119, 110, 84, 121, 112,
    101, 115, 98, 6, 112, 114, 111, 116, 111, 51,
];

#[derive(Clone, Debug, Default, PartialEq)]
pub struct FieldMask {
    paths: Vec<String>,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for FieldMask {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.paths.push(s.read_string()?),
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.paths.is_empty() {
            for v in &self.paths {
                s.write_raw_1_byte([10])?;
                s.write_string(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.paths.is_empty() {
            n += self.paths.iter().fold(0, |n, m| {
                let l = m.len();
                n + 1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        n
    }
}

impl FieldMask {
    pub const fn new() -> FieldMask {
        FieldMask {
            paths: Vec::new(),
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static FieldMask {
        static DEFAULT: FieldMask = FieldMask::new();
        &DEFAULT
    }

    pub fn paths(&self) -> &[String] { &self.paths }

    pub fn clear_paths(&mut self) { self.paths.clear(); }

    pub fn set_paths(&mut self, v: impl Into<Vec<String>>) { self.paths = v.into(); }

    pub fn paths_mut(&mut self) -> &mut Vec<String> { &mut self.paths }
}
