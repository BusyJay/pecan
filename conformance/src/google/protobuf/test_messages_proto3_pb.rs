// This file is generated by pecan 0.1.0, DO NOT EDIT!
// @generated
// source: google/protobuf/test_messages_proto3.proto

#![allow(non_upper_case_globals)]
#![allow(unused_imports)]

use pecan::{
    codec,
    EnumType,
    Message,
    Result,
    Buf,
    BufMut,
    CodedInputStream,
    CodedOutputStream,
    encoded,
};
use std::collections::HashMap;

use crate::google::protobuf::any_pb as google__protobuf__any_pb;
use crate::google::protobuf::duration_pb as google__protobuf__duration_pb;
use crate::google::protobuf::field_mask_pb as google__protobuf__field_mask_pb;
use crate::google::protobuf::struct_pb as google__protobuf__struct_pb;
use crate::google::protobuf::timestamp_pb as google__protobuf__timestamp_pb;
use crate::google::protobuf::wrappers_pb as google__protobuf__wrappers_pb;

pub static DESCRIPTOR: &[u8] = &[
    10, 42, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117,
    102, 47, 116, 101, 115, 116, 95, 109, 101, 115, 115, 97, 103, 101, 115, 95,
    112, 114, 111, 116, 111, 51, 46, 112, 114, 111, 116, 111, 18, 29, 112, 114,
    111, 116, 111, 98, 117, 102, 95, 116, 101, 115, 116, 95, 109, 101, 115, 115,
    97, 103, 101, 115, 46, 112, 114, 111, 116, 111, 51, 26, 25, 103, 111, 111,
    103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 97, 110, 121,
    46, 112, 114, 111, 116, 111, 26, 30, 103, 111, 111, 103, 108, 101, 47, 112,
    114, 111, 116, 111, 98, 117, 102, 47, 100, 117, 114, 97, 116, 105, 111, 110,
    46, 112, 114, 111, 116, 111, 26, 32, 103, 111, 111, 103, 108, 101, 47, 112,
    114, 111, 116, 111, 98, 117, 102, 47, 102, 105, 101, 108, 100, 95, 109, 97,
    115, 107, 46, 112, 114, 111, 116, 111, 26, 28, 103, 111, 111, 103, 108, 101,
    47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 115, 116, 114, 117, 99, 116,
    46, 112, 114, 111, 116, 111, 26, 31, 103, 111, 111, 103, 108, 101, 47, 112,
    114, 111, 116, 111, 98, 117, 102, 47, 116, 105, 109, 101, 115, 116, 97, 109,
    112, 46, 112, 114, 111, 116, 111, 26, 30, 103, 111, 111, 103, 108, 101, 47,
    112, 114, 111, 116, 111, 98, 117, 102, 47, 119, 114, 97, 112, 112, 101, 114,
    115, 46, 112, 114, 111, 116, 111, 66, 56, 10, 40, 99, 111, 109, 46, 103,
    111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 116,
    101, 115, 116, 95, 109, 101, 115, 115, 97, 103, 101, 115, 46, 112, 114, 111,
    116, 111, 51, 72, 1, 248, 1, 1, 162, 2, 6, 80, 114, 111, 116, 111,
    51, 98, 6, 112, 114, 111, 116, 111, 51,
];

#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]
pub struct ForeignEnum(i32);

impl ForeignEnum {
    pub const ForeignFoo: ForeignEnum = ForeignEnum(0);
    pub const ForeignBar: ForeignEnum = ForeignEnum(1);
    pub const ForeignBaz: ForeignEnum = ForeignEnum(2);

    pub const fn new() -> ForeignEnum {
        ForeignEnum::ForeignFoo
    }
}

impl From<i32> for ForeignEnum {
    #[inline]
    fn from(u: i32) -> ForeignEnum {
        ForeignEnum(u)
    }
}

impl EnumType for ForeignEnum {
    #[inline]
    fn values() -> &'static [ForeignEnum] {
        &[
            ForeignEnum::ForeignFoo,
            ForeignEnum::ForeignBar,
            ForeignEnum::ForeignBaz,
        ]
    }

    #[inline]
    fn value(&self) -> i32 { self.0 }
}

#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]
pub struct TestAllTypesProto3NestedNestedEnum(i32);

impl TestAllTypesProto3NestedNestedEnum {
    pub const Foo: TestAllTypesProto3NestedNestedEnum = TestAllTypesProto3NestedNestedEnum(0);
    pub const Bar: TestAllTypesProto3NestedNestedEnum = TestAllTypesProto3NestedNestedEnum(1);
    pub const Baz: TestAllTypesProto3NestedNestedEnum = TestAllTypesProto3NestedNestedEnum(2);
    pub const Neg: TestAllTypesProto3NestedNestedEnum = TestAllTypesProto3NestedNestedEnum(-1);

    pub const fn new() -> TestAllTypesProto3NestedNestedEnum {
        TestAllTypesProto3NestedNestedEnum::Foo
    }
}

impl From<i32> for TestAllTypesProto3NestedNestedEnum {
    #[inline]
    fn from(u: i32) -> TestAllTypesProto3NestedNestedEnum {
        TestAllTypesProto3NestedNestedEnum(u)
    }
}

impl EnumType for TestAllTypesProto3NestedNestedEnum {
    #[inline]
    fn values() -> &'static [TestAllTypesProto3NestedNestedEnum] {
        &[
            TestAllTypesProto3NestedNestedEnum::Foo,
            TestAllTypesProto3NestedNestedEnum::Bar,
            TestAllTypesProto3NestedNestedEnum::Baz,
            TestAllTypesProto3NestedNestedEnum::Neg,
        ]
    }

    #[inline]
    fn value(&self) -> i32 { self.0 }
}

#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]
pub struct TestAllTypesProto3NestedAliasedEnum(i32);

impl TestAllTypesProto3NestedAliasedEnum {
    pub const AliasFoo: TestAllTypesProto3NestedAliasedEnum = TestAllTypesProto3NestedAliasedEnum(0);
    pub const AliasBar: TestAllTypesProto3NestedAliasedEnum = TestAllTypesProto3NestedAliasedEnum(1);
    pub const AliasBaz: TestAllTypesProto3NestedAliasedEnum = TestAllTypesProto3NestedAliasedEnum(2);
    pub const Qux: TestAllTypesProto3NestedAliasedEnum = TestAllTypesProto3NestedAliasedEnum(2);
    pub const BAz: TestAllTypesProto3NestedAliasedEnum = TestAllTypesProto3NestedAliasedEnum(2);

    pub const fn new() -> TestAllTypesProto3NestedAliasedEnum {
        TestAllTypesProto3NestedAliasedEnum::AliasFoo
    }
}

impl From<i32> for TestAllTypesProto3NestedAliasedEnum {
    #[inline]
    fn from(u: i32) -> TestAllTypesProto3NestedAliasedEnum {
        TestAllTypesProto3NestedAliasedEnum(u)
    }
}

impl EnumType for TestAllTypesProto3NestedAliasedEnum {
    #[inline]
    fn values() -> &'static [TestAllTypesProto3NestedAliasedEnum] {
        &[
            TestAllTypesProto3NestedAliasedEnum::AliasFoo,
            TestAllTypesProto3NestedAliasedEnum::AliasBar,
            TestAllTypesProto3NestedAliasedEnum::AliasBaz,
            TestAllTypesProto3NestedAliasedEnum::Qux,
            TestAllTypesProto3NestedAliasedEnum::Qux,
            TestAllTypesProto3NestedAliasedEnum::BAz,
        ]
    }

    #[inline]
    fn value(&self) -> i32 { self.0 }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3 {
    pub optional_int32: i32,
    pub optional_int64: i64,
    pub optional_uint32: u32,
    pub optional_uint64: u64,
    pub optional_sint32: i32,
    pub optional_sint64: i64,
    pub optional_fixed32: u32,
    pub optional_fixed64: u64,
    pub optional_sfixed32: i32,
    pub optional_sfixed64: i64,
    pub optional_float: f32,
    pub optional_double: f64,
    pub optional_bool: bool,
    pub optional_string: String,
    pub optional_bytes: Vec<u8>,
    optional_nested_message: Option<TestAllTypesProto3NestedNestedMessage>,
    optional_foreign_message: Option<ForeignMessage>,
    pub optional_nested_enum: TestAllTypesProto3NestedNestedEnum,
    pub optional_foreign_enum: ForeignEnum,
    pub optional_aliased_enum: TestAllTypesProto3NestedAliasedEnum,
    pub optional_string_piece: String,
    pub optional_cord: String,
    recursive_message: Option<Box<TestAllTypesProto3>>,
    repeated_int32: Vec<i32>,
    repeated_int64: Vec<i64>,
    repeated_uint32: Vec<u32>,
    repeated_uint64: Vec<u64>,
    repeated_sint32: Vec<i32>,
    repeated_sint64: Vec<i64>,
    repeated_fixed32: Vec<u32>,
    repeated_fixed64: Vec<u64>,
    repeated_sfixed32: Vec<i32>,
    repeated_sfixed64: Vec<i64>,
    repeated_float: Vec<f32>,
    repeated_double: Vec<f64>,
    repeated_bool: Vec<bool>,
    repeated_string: Vec<String>,
    repeated_bytes: Vec<Vec<u8>>,
    repeated_nested_message: Vec<TestAllTypesProto3NestedNestedMessage>,
    repeated_foreign_message: Vec<ForeignMessage>,
    repeated_nested_enum: Vec<TestAllTypesProto3NestedNestedEnum>,
    repeated_foreign_enum: Vec<ForeignEnum>,
    repeated_string_piece: Vec<String>,
    repeated_cord: Vec<String>,
    packed_int32: Vec<i32>,
    packed_int64: Vec<i64>,
    packed_uint32: Vec<u32>,
    packed_uint64: Vec<u64>,
    packed_sint32: Vec<i32>,
    packed_sint64: Vec<i64>,
    packed_fixed32: Vec<u32>,
    packed_fixed64: Vec<u64>,
    packed_sfixed32: Vec<i32>,
    packed_sfixed64: Vec<i64>,
    packed_float: Vec<f32>,
    packed_double: Vec<f64>,
    packed_bool: Vec<bool>,
    packed_nested_enum: Vec<TestAllTypesProto3NestedNestedEnum>,
    unpacked_int32: Vec<i32>,
    unpacked_int64: Vec<i64>,
    unpacked_uint32: Vec<u32>,
    unpacked_uint64: Vec<u64>,
    unpacked_sint32: Vec<i32>,
    unpacked_sint64: Vec<i64>,
    unpacked_fixed32: Vec<u32>,
    unpacked_fixed64: Vec<u64>,
    unpacked_sfixed32: Vec<i32>,
    unpacked_sfixed64: Vec<i64>,
    unpacked_float: Vec<f32>,
    unpacked_double: Vec<f64>,
    unpacked_bool: Vec<bool>,
    unpacked_nested_enum: Vec<TestAllTypesProto3NestedNestedEnum>,
    map_int32_int32: Option<HashMap<i32, i32>>,
    map_int64_int64: Option<HashMap<i64, i64>>,
    map_uint32_uint32: Option<HashMap<u32, u32>>,
    map_uint64_uint64: Option<HashMap<u64, u64>>,
    map_sint32_sint32: Option<HashMap<i32, i32>>,
    map_sint64_sint64: Option<HashMap<i64, i64>>,
    map_fixed32_fixed32: Option<HashMap<u32, u32>>,
    map_fixed64_fixed64: Option<HashMap<u64, u64>>,
    map_sfixed32_sfixed32: Option<HashMap<i32, i32>>,
    map_sfixed64_sfixed64: Option<HashMap<i64, i64>>,
    map_int32_float: Option<HashMap<i32, f32>>,
    map_int32_double: Option<HashMap<i32, f64>>,
    map_bool_bool: Option<HashMap<bool, bool>>,
    map_string_string: Option<HashMap<String, String>>,
    map_string_bytes: Option<HashMap<String, Vec<u8>>>,
    map_string_nested_message: Option<HashMap<String, TestAllTypesProto3NestedNestedMessage>>,
    map_string_foreign_message: Option<HashMap<String, ForeignMessage>>,
    map_string_nested_enum: Option<HashMap<String, TestAllTypesProto3NestedNestedEnum>>,
    map_string_foreign_enum: Option<HashMap<String, ForeignEnum>>,
    optional_bool_wrapper: Option<google__protobuf__wrappers_pb::BoolValue>,
    optional_int32_wrapper: Option<google__protobuf__wrappers_pb::Int32Value>,
    optional_int64_wrapper: Option<google__protobuf__wrappers_pb::Int64Value>,
    optional_uint32_wrapper: Option<google__protobuf__wrappers_pb::UInt32Value>,
    optional_uint64_wrapper: Option<google__protobuf__wrappers_pb::UInt64Value>,
    optional_float_wrapper: Option<google__protobuf__wrappers_pb::FloatValue>,
    optional_double_wrapper: Option<google__protobuf__wrappers_pb::DoubleValue>,
    optional_string_wrapper: Option<google__protobuf__wrappers_pb::StringValue>,
    optional_bytes_wrapper: Option<google__protobuf__wrappers_pb::BytesValue>,
    repeated_bool_wrapper: Vec<google__protobuf__wrappers_pb::BoolValue>,
    repeated_int32_wrapper: Vec<google__protobuf__wrappers_pb::Int32Value>,
    repeated_int64_wrapper: Vec<google__protobuf__wrappers_pb::Int64Value>,
    repeated_uint32_wrapper: Vec<google__protobuf__wrappers_pb::UInt32Value>,
    repeated_uint64_wrapper: Vec<google__protobuf__wrappers_pb::UInt64Value>,
    repeated_float_wrapper: Vec<google__protobuf__wrappers_pb::FloatValue>,
    repeated_double_wrapper: Vec<google__protobuf__wrappers_pb::DoubleValue>,
    repeated_string_wrapper: Vec<google__protobuf__wrappers_pb::StringValue>,
    repeated_bytes_wrapper: Vec<google__protobuf__wrappers_pb::BytesValue>,
    optional_duration: Option<google__protobuf__duration_pb::Duration>,
    optional_timestamp: Option<google__protobuf__timestamp_pb::Timestamp>,
    optional_field_mask: Option<google__protobuf__field_mask_pb::FieldMask>,
    optional_struct: Option<google__protobuf__struct_pb::Struct>,
    optional_any: Option<google__protobuf__any_pb::Any>,
    optional_value: Option<google__protobuf__struct_pb::Value>,
    repeated_duration: Vec<google__protobuf__duration_pb::Duration>,
    repeated_timestamp: Vec<google__protobuf__timestamp_pb::Timestamp>,
    repeated_fieldmask: Vec<google__protobuf__field_mask_pb::FieldMask>,
    repeated_struct: Vec<google__protobuf__struct_pb::Struct>,
    repeated_any: Vec<google__protobuf__any_pb::Any>,
    repeated_value: Vec<google__protobuf__struct_pb::Value>,
    repeated_list_value: Vec<google__protobuf__struct_pb::ListValue>,
    pub fieldname1: i32,
    pub field_name2: i32,
    pub field_name3: i32,
    pub field_name4_: i32,
    pub field0name5: i32,
    pub field_0_name6: i32,
    pub field_name7: i32,
    pub field_name8: i32,
    pub field_name9: i32,
    pub field_name10: i32,
    pub f_i_e_l_d_n_a_m_e11: i32,
    pub f_i_e_l_d_name12: i32,
    pub field_name13: i32,
    pub field_name14: i32,
    pub field_name15: i32,
    pub field_name16: i32,
    pub field_name17_: i32,
    pub field_name18_: i32,
    pub oneof_field: Option<TestAllTypesProto3NestedOneofField>,
    cache_size: u32,
    unknown: Vec<u8>,
}

#[derive(Clone, Debug, PartialEq)]
pub enum TestAllTypesProto3NestedOneofField {
    OneofUint32(u32),
    OneofNestedMessage(TestAllTypesProto3NestedNestedMessage),
    OneofString(String),
    OneofBytes(Vec<u8>),
    OneofBool(bool),
    OneofUint64(u64),
    OneofFloat(f32),
    OneofDouble(f64),
    OneofEnum(TestAllTypesProto3NestedNestedEnum),
}

impl Message for TestAllTypesProto3 {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.optional_int32 = s.read_var_i32()?,
                16 => self.optional_int64 = s.read_var_i64()?,
                24 => self.optional_uint32 = s.read_var_u32()?,
                32 => self.optional_uint64 = s.read_var_u64()?,
                40 => self.optional_sint32 = s.read_var_s32()?,
                48 => self.optional_sint64 = s.read_var_s64()?,
                61 => self.optional_fixed32 = s.read_fixed32()?,
                65 => self.optional_fixed64 = s.read_fixed64()?,
                77 => self.optional_sfixed32 = s.read_sfixed32()?,
                81 => self.optional_sfixed64 = s.read_sfixed64()?,
                93 => self.optional_float = s.read_f32()?,
                97 => self.optional_double = s.read_f64()?,
                104 => self.optional_bool = s.read_bool()?,
                114 => self.optional_string = s.read_string()?,
                122 => self.optional_bytes = s.read_bytes()?,
                146 => {
                    let msg = self.optional_nested_message.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                154 => {
                    let msg = self.optional_foreign_message.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                168 => self.optional_nested_enum = s.read_enum()?,
                176 => self.optional_foreign_enum = s.read_enum()?,
                184 => self.optional_aliased_enum = s.read_enum()?,
                194 => self.optional_string_piece = s.read_string()?,
                202 => self.optional_cord = s.read_string()?,
                218 => {
                    let msg = self.recursive_message.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                248 => self.repeated_int32.push(s.read_var_i32()?),
                250 => s.read_var_i32_array(&mut self.repeated_int32)?,
                256 => self.repeated_int64.push(s.read_var_i64()?),
                258 => s.read_var_i64_array(&mut self.repeated_int64)?,
                264 => self.repeated_uint32.push(s.read_var_u32()?),
                266 => s.read_var_u32_array(&mut self.repeated_uint32)?,
                272 => self.repeated_uint64.push(s.read_var_u64()?),
                274 => s.read_var_u64_array(&mut self.repeated_uint64)?,
                280 => self.repeated_sint32.push(s.read_var_s32()?),
                282 => s.read_var_s32_array(&mut self.repeated_sint32)?,
                288 => self.repeated_sint64.push(s.read_var_s64()?),
                290 => s.read_var_s64_array(&mut self.repeated_sint64)?,
                301 => self.repeated_fixed32.push(s.read_fixed32()?),
                298 => s.read_fixed32_array(&mut self.repeated_fixed32)?,
                305 => self.repeated_fixed64.push(s.read_fixed64()?),
                306 => s.read_fixed64_array(&mut self.repeated_fixed64)?,
                317 => self.repeated_sfixed32.push(s.read_sfixed32()?),
                314 => s.read_sfixed32_array(&mut self.repeated_sfixed32)?,
                321 => self.repeated_sfixed64.push(s.read_sfixed64()?),
                322 => s.read_sfixed64_array(&mut self.repeated_sfixed64)?,
                333 => self.repeated_float.push(s.read_f32()?),
                330 => s.read_f32_array(&mut self.repeated_float)?,
                337 => self.repeated_double.push(s.read_f64()?),
                338 => s.read_f64_array(&mut self.repeated_double)?,
                344 => self.repeated_bool.push(s.read_bool()?),
                346 => s.read_bool_array(&mut self.repeated_bool)?,
                354 => self.repeated_string.push(s.read_string()?),
                362 => self.repeated_bytes.push(s.read_bytes()?),
                386 => s.read_message_to(&mut self.repeated_nested_message)?,
                394 => s.read_message_to(&mut self.repeated_foreign_message)?,
                408 => self.repeated_nested_enum.push(s.read_enum()?),
                410 => s.read_enum_array(&mut self.repeated_nested_enum)?,
                416 => self.repeated_foreign_enum.push(s.read_enum()?),
                418 => s.read_enum_array(&mut self.repeated_foreign_enum)?,
                434 => self.repeated_string_piece.push(s.read_string()?),
                442 => self.repeated_cord.push(s.read_string()?),
                600 => self.packed_int32.push(s.read_var_i32()?),
                602 => s.read_var_i32_array(&mut self.packed_int32)?,
                608 => self.packed_int64.push(s.read_var_i64()?),
                610 => s.read_var_i64_array(&mut self.packed_int64)?,
                616 => self.packed_uint32.push(s.read_var_u32()?),
                618 => s.read_var_u32_array(&mut self.packed_uint32)?,
                624 => self.packed_uint64.push(s.read_var_u64()?),
                626 => s.read_var_u64_array(&mut self.packed_uint64)?,
                632 => self.packed_sint32.push(s.read_var_s32()?),
                634 => s.read_var_s32_array(&mut self.packed_sint32)?,
                640 => self.packed_sint64.push(s.read_var_s64()?),
                642 => s.read_var_s64_array(&mut self.packed_sint64)?,
                653 => self.packed_fixed32.push(s.read_fixed32()?),
                650 => s.read_fixed32_array(&mut self.packed_fixed32)?,
                657 => self.packed_fixed64.push(s.read_fixed64()?),
                658 => s.read_fixed64_array(&mut self.packed_fixed64)?,
                669 => self.packed_sfixed32.push(s.read_sfixed32()?),
                666 => s.read_sfixed32_array(&mut self.packed_sfixed32)?,
                673 => self.packed_sfixed64.push(s.read_sfixed64()?),
                674 => s.read_sfixed64_array(&mut self.packed_sfixed64)?,
                685 => self.packed_float.push(s.read_f32()?),
                682 => s.read_f32_array(&mut self.packed_float)?,
                689 => self.packed_double.push(s.read_f64()?),
                690 => s.read_f64_array(&mut self.packed_double)?,
                696 => self.packed_bool.push(s.read_bool()?),
                698 => s.read_bool_array(&mut self.packed_bool)?,
                704 => self.packed_nested_enum.push(s.read_enum()?),
                706 => s.read_enum_array(&mut self.packed_nested_enum)?,
                712 => self.unpacked_int32.push(s.read_var_i32()?),
                714 => s.read_var_i32_array(&mut self.unpacked_int32)?,
                720 => self.unpacked_int64.push(s.read_var_i64()?),
                722 => s.read_var_i64_array(&mut self.unpacked_int64)?,
                728 => self.unpacked_uint32.push(s.read_var_u32()?),
                730 => s.read_var_u32_array(&mut self.unpacked_uint32)?,
                736 => self.unpacked_uint64.push(s.read_var_u64()?),
                738 => s.read_var_u64_array(&mut self.unpacked_uint64)?,
                744 => self.unpacked_sint32.push(s.read_var_s32()?),
                746 => s.read_var_s32_array(&mut self.unpacked_sint32)?,
                752 => self.unpacked_sint64.push(s.read_var_s64()?),
                754 => s.read_var_s64_array(&mut self.unpacked_sint64)?,
                765 => self.unpacked_fixed32.push(s.read_fixed32()?),
                762 => s.read_fixed32_array(&mut self.unpacked_fixed32)?,
                769 => self.unpacked_fixed64.push(s.read_fixed64()?),
                770 => s.read_fixed64_array(&mut self.unpacked_fixed64)?,
                781 => self.unpacked_sfixed32.push(s.read_sfixed32()?),
                778 => s.read_sfixed32_array(&mut self.unpacked_sfixed32)?,
                785 => self.unpacked_sfixed64.push(s.read_sfixed64()?),
                786 => s.read_sfixed64_array(&mut self.unpacked_sfixed64)?,
                797 => self.unpacked_float.push(s.read_f32()?),
                794 => s.read_f32_array(&mut self.unpacked_float)?,
                801 => self.unpacked_double.push(s.read_f64()?),
                802 => s.read_f64_array(&mut self.unpacked_double)?,
                808 => self.unpacked_bool.push(s.read_bool()?),
                810 => s.read_bool_array(&mut self.unpacked_bool)?,
                816 => self.unpacked_nested_enum.push(s.read_enum()?),
                818 => s.read_enum_array(&mut self.unpacked_nested_enum)?,
                450 => s.read_message_like(|s| {
                    let tag = s.read_tag()?;
                    let (mut key, mut value) = Default::default();
                    loop {
                        match tag {
                            8 => key = s.read_var_i32()?,
                            16 => value = s.read_var_i32()?,
                            0 => break,
                            tag => s.discard_field(tag)?,
                        }
                    }
                    self.map_int32_int32.get_or_insert_with(Default::default).insert(key, value);
                    Ok(())
                })?,
                458 => s.read_message_like(|s| {
                    let tag = s.read_tag()?;
                    let (mut key, mut value) = Default::default();
                    loop {
                        match tag {
                            8 => key = s.read_var_i64()?,
                            16 => value = s.read_var_i64()?,
                            0 => break,
                            tag => s.discard_field(tag)?,
                        }
                    }
                    self.map_int64_int64.get_or_insert_with(Default::default).insert(key, value);
                    Ok(())
                })?,
                466 => s.read_message_like(|s| {
                    let tag = s.read_tag()?;
                    let (mut key, mut value) = Default::default();
                    loop {
                        match tag {
                            8 => key = s.read_var_u32()?,
                            16 => value = s.read_var_u32()?,
                            0 => break,
                            tag => s.discard_field(tag)?,
                        }
                    }
                    self.map_uint32_uint32.get_or_insert_with(Default::default).insert(key, value);
                    Ok(())
                })?,
                474 => s.read_message_like(|s| {
                    let tag = s.read_tag()?;
                    let (mut key, mut value) = Default::default();
                    loop {
                        match tag {
                            8 => key = s.read_var_u64()?,
                            16 => value = s.read_var_u64()?,
                            0 => break,
                            tag => s.discard_field(tag)?,
                        }
                    }
                    self.map_uint64_uint64.get_or_insert_with(Default::default).insert(key, value);
                    Ok(())
                })?,
                482 => s.read_message_like(|s| {
                    let tag = s.read_tag()?;
                    let (mut key, mut value) = Default::default();
                    loop {
                        match tag {
                            8 => key = s.read_var_s32()?,
                            16 => value = s.read_var_s32()?,
                            0 => break,
                            tag => s.discard_field(tag)?,
                        }
                    }
                    self.map_sint32_sint32.get_or_insert_with(Default::default).insert(key, value);
                    Ok(())
                })?,
                490 => s.read_message_like(|s| {
                    let tag = s.read_tag()?;
                    let (mut key, mut value) = Default::default();
                    loop {
                        match tag {
                            8 => key = s.read_var_s64()?,
                            16 => value = s.read_var_s64()?,
                            0 => break,
                            tag => s.discard_field(tag)?,
                        }
                    }
                    self.map_sint64_sint64.get_or_insert_with(Default::default).insert(key, value);
                    Ok(())
                })?,
                498 => s.read_message_like(|s| {
                    let tag = s.read_tag()?;
                    let (mut key, mut value) = Default::default();
                    loop {
                        match tag {
                            13 => key = s.read_fixed32()?,
                            21 => value = s.read_fixed32()?,
                            0 => break,
                            tag => s.discard_field(tag)?,
                        }
                    }
                    self.map_fixed32_fixed32.get_or_insert_with(Default::default).insert(key, value);
                    Ok(())
                })?,
                506 => s.read_message_like(|s| {
                    let tag = s.read_tag()?;
                    let (mut key, mut value) = Default::default();
                    loop {
                        match tag {
                            9 => key = s.read_fixed64()?,
                            17 => value = s.read_fixed64()?,
                            0 => break,
                            tag => s.discard_field(tag)?,
                        }
                    }
                    self.map_fixed64_fixed64.get_or_insert_with(Default::default).insert(key, value);
                    Ok(())
                })?,
                514 => s.read_message_like(|s| {
                    let tag = s.read_tag()?;
                    let (mut key, mut value) = Default::default();
                    loop {
                        match tag {
                            13 => key = s.read_sfixed32()?,
                            21 => value = s.read_sfixed32()?,
                            0 => break,
                            tag => s.discard_field(tag)?,
                        }
                    }
                    self.map_sfixed32_sfixed32.get_or_insert_with(Default::default).insert(key, value);
                    Ok(())
                })?,
                522 => s.read_message_like(|s| {
                    let tag = s.read_tag()?;
                    let (mut key, mut value) = Default::default();
                    loop {
                        match tag {
                            9 => key = s.read_sfixed64()?,
                            17 => value = s.read_sfixed64()?,
                            0 => break,
                            tag => s.discard_field(tag)?,
                        }
                    }
                    self.map_sfixed64_sfixed64.get_or_insert_with(Default::default).insert(key, value);
                    Ok(())
                })?,
                530 => s.read_message_like(|s| {
                    let tag = s.read_tag()?;
                    let (mut key, mut value) = Default::default();
                    loop {
                        match tag {
                            8 => key = s.read_var_i32()?,
                            21 => value = s.read_f32()?,
                            0 => break,
                            tag => s.discard_field(tag)?,
                        }
                    }
                    self.map_int32_float.get_or_insert_with(Default::default).insert(key, value);
                    Ok(())
                })?,
                538 => s.read_message_like(|s| {
                    let tag = s.read_tag()?;
                    let (mut key, mut value) = Default::default();
                    loop {
                        match tag {
                            8 => key = s.read_var_i32()?,
                            17 => value = s.read_f64()?,
                            0 => break,
                            tag => s.discard_field(tag)?,
                        }
                    }
                    self.map_int32_double.get_or_insert_with(Default::default).insert(key, value);
                    Ok(())
                })?,
                546 => s.read_message_like(|s| {
                    let tag = s.read_tag()?;
                    let (mut key, mut value) = Default::default();
                    loop {
                        match tag {
                            8 => key = s.read_bool()?,
                            16 => value = s.read_bool()?,
                            0 => break,
                            tag => s.discard_field(tag)?,
                        }
                    }
                    self.map_bool_bool.get_or_insert_with(Default::default).insert(key, value);
                    Ok(())
                })?,
                554 => s.read_message_like(|s| {
                    let tag = s.read_tag()?;
                    let (mut key, mut value) = Default::default();
                    loop {
                        match tag {
                            10 => key = s.read_string()?,
                            18 => value = s.read_string()?,
                            0 => break,
                            tag => s.discard_field(tag)?,
                        }
                    }
                    self.map_string_string.get_or_insert_with(Default::default).insert(key, value);
                    Ok(())
                })?,
                562 => s.read_message_like(|s| {
                    let tag = s.read_tag()?;
                    let (mut key, mut value) = Default::default();
                    loop {
                        match tag {
                            10 => key = s.read_string()?,
                            18 => value = s.read_bytes()?,
                            0 => break,
                            tag => s.discard_field(tag)?,
                        }
                    }
                    self.map_string_bytes.get_or_insert_with(Default::default).insert(key, value);
                    Ok(())
                })?,
                570 => s.read_message_like(|s| {
                    let tag = s.read_tag()?;
                    let (mut key, mut value) = Default::default();
                    loop {
                        match tag {
                            10 => key = s.read_string()?,
                            18 => s.read_message(&mut value)?,
                            0 => break,
                            tag => s.discard_field(tag)?,
                        }
                    }
                    self.map_string_nested_message.get_or_insert_with(Default::default).insert(key, value);
                    Ok(())
                })?,
                578 => s.read_message_like(|s| {
                    let tag = s.read_tag()?;
                    let (mut key, mut value) = Default::default();
                    loop {
                        match tag {
                            10 => key = s.read_string()?,
                            18 => s.read_message(&mut value)?,
                            0 => break,
                            tag => s.discard_field(tag)?,
                        }
                    }
                    self.map_string_foreign_message.get_or_insert_with(Default::default).insert(key, value);
                    Ok(())
                })?,
                586 => s.read_message_like(|s| {
                    let tag = s.read_tag()?;
                    let (mut key, mut value) = Default::default();
                    loop {
                        match tag {
                            10 => key = s.read_string()?,
                            16 => value = s.read_enum()?,
                            0 => break,
                            tag => s.discard_field(tag)?,
                        }
                    }
                    self.map_string_nested_enum.get_or_insert_with(Default::default).insert(key, value);
                    Ok(())
                })?,
                594 => s.read_message_like(|s| {
                    let tag = s.read_tag()?;
                    let (mut key, mut value) = Default::default();
                    loop {
                        match tag {
                            10 => key = s.read_string()?,
                            16 => value = s.read_enum()?,
                            0 => break,
                            tag => s.discard_field(tag)?,
                        }
                    }
                    self.map_string_foreign_enum.get_or_insert_with(Default::default).insert(key, value);
                    Ok(())
                })?,
                1610 => {
                    let msg = self.optional_bool_wrapper.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                1618 => {
                    let msg = self.optional_int32_wrapper.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                1626 => {
                    let msg = self.optional_int64_wrapper.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                1634 => {
                    let msg = self.optional_uint32_wrapper.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                1642 => {
                    let msg = self.optional_uint64_wrapper.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                1650 => {
                    let msg = self.optional_float_wrapper.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                1658 => {
                    let msg = self.optional_double_wrapper.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                1666 => {
                    let msg = self.optional_string_wrapper.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                1674 => {
                    let msg = self.optional_bytes_wrapper.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                1690 => s.read_message_to(&mut self.repeated_bool_wrapper)?,
                1698 => s.read_message_to(&mut self.repeated_int32_wrapper)?,
                1706 => s.read_message_to(&mut self.repeated_int64_wrapper)?,
                1714 => s.read_message_to(&mut self.repeated_uint32_wrapper)?,
                1722 => s.read_message_to(&mut self.repeated_uint64_wrapper)?,
                1730 => s.read_message_to(&mut self.repeated_float_wrapper)?,
                1738 => s.read_message_to(&mut self.repeated_double_wrapper)?,
                1746 => s.read_message_to(&mut self.repeated_string_wrapper)?,
                1754 => s.read_message_to(&mut self.repeated_bytes_wrapper)?,
                2410 => {
                    let msg = self.optional_duration.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                2418 => {
                    let msg = self.optional_timestamp.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                2426 => {
                    let msg = self.optional_field_mask.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                2434 => {
                    let msg = self.optional_struct.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                2442 => {
                    let msg = self.optional_any.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                2450 => {
                    let msg = self.optional_value.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                2490 => s.read_message_to(&mut self.repeated_duration)?,
                2498 => s.read_message_to(&mut self.repeated_timestamp)?,
                2506 => s.read_message_to(&mut self.repeated_fieldmask)?,
                2594 => s.read_message_to(&mut self.repeated_struct)?,
                2522 => s.read_message_to(&mut self.repeated_any)?,
                2530 => s.read_message_to(&mut self.repeated_value)?,
                2538 => s.read_message_to(&mut self.repeated_list_value)?,
                3208 => self.fieldname1 = s.read_var_i32()?,
                3216 => self.field_name2 = s.read_var_i32()?,
                3224 => self.field_name3 = s.read_var_i32()?,
                3232 => self.field_name4_ = s.read_var_i32()?,
                3240 => self.field0name5 = s.read_var_i32()?,
                3248 => self.field_0_name6 = s.read_var_i32()?,
                3256 => self.field_name7 = s.read_var_i32()?,
                3264 => self.field_name8 = s.read_var_i32()?,
                3272 => self.field_name9 = s.read_var_i32()?,
                3280 => self.field_name10 = s.read_var_i32()?,
                3288 => self.f_i_e_l_d_n_a_m_e11 = s.read_var_i32()?,
                3296 => self.f_i_e_l_d_name12 = s.read_var_i32()?,
                3304 => self.field_name13 = s.read_var_i32()?,
                3312 => self.field_name14 = s.read_var_i32()?,
                3320 => self.field_name15 = s.read_var_i32()?,
                3328 => self.field_name16 = s.read_var_i32()?,
                3336 => self.field_name17_ = s.read_var_i32()?,
                3344 => self.field_name18_ = s.read_var_i32()?,
                888 => self.oneof_field = Some(TestAllTypesProto3NestedOneofField::OneofUint32(s.read_var_u32()?)),
                898 => {
                    let msg = self.oneof_nested_message_mut();
                    s.read_message(msg)?;
                }
                906 => self.oneof_field = Some(TestAllTypesProto3NestedOneofField::OneofString(s.read_string()?)),
                914 => self.oneof_field = Some(TestAllTypesProto3NestedOneofField::OneofBytes(s.read_bytes()?)),
                920 => self.oneof_field = Some(TestAllTypesProto3NestedOneofField::OneofBool(s.read_bool()?)),
                928 => self.oneof_field = Some(TestAllTypesProto3NestedOneofField::OneofUint64(s.read_var_u64()?)),
                941 => self.oneof_field = Some(TestAllTypesProto3NestedOneofField::OneofFloat(s.read_f32()?)),
                945 => self.oneof_field = Some(TestAllTypesProto3NestedOneofField::OneofDouble(s.read_f64()?)),
                952 => self.oneof_field = Some(TestAllTypesProto3NestedOneofField::OneofEnum(s.read_enum()?)),
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.optional_int32 {
            s.write_raw_1_byte([8])?;
            s.write_var_i32(self.optional_int32)?;
        }
        if 0 != self.optional_int64 {
            s.write_raw_1_byte([16])?;
            s.write_var_i64(self.optional_int64)?;
        }
        if 0 != self.optional_uint32 {
            s.write_raw_1_byte([24])?;
            s.write_var_u32(self.optional_uint32)?;
        }
        if 0 != self.optional_uint64 {
            s.write_raw_1_byte([32])?;
            s.write_var_u64(self.optional_uint64)?;
        }
        if 0 != self.optional_sint32 {
            s.write_raw_1_byte([40])?;
            s.write_var_s32(self.optional_sint32)?;
        }
        if 0 != self.optional_sint64 {
            s.write_raw_1_byte([48])?;
            s.write_var_s64(self.optional_sint64)?;
        }
        if 0 != self.optional_fixed32 {
            s.write_raw_1_byte([61])?;
            s.write_fixed32(self.optional_fixed32)?;
        }
        if 0 != self.optional_fixed64 {
            s.write_raw_1_byte([65])?;
            s.write_fixed64(self.optional_fixed64)?;
        }
        if 0 != self.optional_sfixed32 {
            s.write_raw_1_byte([77])?;
            s.write_sfixed32(self.optional_sfixed32)?;
        }
        if 0 != self.optional_sfixed64 {
            s.write_raw_1_byte([81])?;
            s.write_sfixed64(self.optional_sfixed64)?;
        }
        if 0f32 != self.optional_float {
            s.write_raw_1_byte([93])?;
            s.write_f32(self.optional_float)?;
        }
        if 0f64 != self.optional_double {
            s.write_raw_1_byte([97])?;
            s.write_f64(self.optional_double)?;
        }
        if self.optional_bool {
            s.write_raw_1_byte([104])?;
            s.write_bool(self.optional_bool)?;
        }
        if !&self.optional_string.is_empty() {
            s.write_raw_1_byte([114])?;
            s.write_string(&self.optional_string)?;
        }
        if !&self.optional_bytes.is_empty() {
            s.write_raw_1_byte([122])?;
            s.write_bytes(&self.optional_bytes)?;
        }
        if let Some(v) = &self.optional_nested_message {
            s.write_raw_2_byte([146, 1])?;
            s.write_message(v)?;
        }
        if let Some(v) = &self.optional_foreign_message {
            s.write_raw_2_byte([154, 1])?;
            s.write_message(v)?;
        }
        if self.optional_nested_enum.value() != 0 {
            s.write_raw_2_byte([168, 1])?;
            s.write_enum(self.optional_nested_enum)?;
        }
        if self.optional_foreign_enum.value() != 0 {
            s.write_raw_2_byte([176, 1])?;
            s.write_enum(self.optional_foreign_enum)?;
        }
        if self.optional_aliased_enum.value() != 0 {
            s.write_raw_2_byte([184, 1])?;
            s.write_enum(self.optional_aliased_enum)?;
        }
        if !&self.optional_string_piece.is_empty() {
            s.write_raw_2_byte([194, 1])?;
            s.write_string(&self.optional_string_piece)?;
        }
        if !&self.optional_cord.is_empty() {
            s.write_raw_2_byte([202, 1])?;
            s.write_string(&self.optional_cord)?;
        }
        if let Some(v) = &self.recursive_message {
            s.write_raw_2_byte([218, 1])?;
            s.write_message(v)?;
        }
        if !self.repeated_int32.is_empty() {
            s.write_raw_2_byte([250, 1])?;
            s.write_var_i32_array(&self.repeated_int32)?;
        }
        if !self.repeated_int64.is_empty() {
            s.write_raw_2_byte([130, 2])?;
            s.write_var_i64_array(&self.repeated_int64)?;
        }
        if !self.repeated_uint32.is_empty() {
            s.write_raw_2_byte([138, 2])?;
            s.write_var_u32_array(&self.repeated_uint32)?;
        }
        if !self.repeated_uint64.is_empty() {
            s.write_raw_2_byte([146, 2])?;
            s.write_var_u64_array(&self.repeated_uint64)?;
        }
        if !self.repeated_sint32.is_empty() {
            s.write_raw_2_byte([154, 2])?;
            s.write_var_s32_array(&self.repeated_sint32)?;
        }
        if !self.repeated_sint64.is_empty() {
            s.write_raw_2_byte([162, 2])?;
            s.write_var_s64_array(&self.repeated_sint64)?;
        }
        if !self.repeated_fixed32.is_empty() {
            s.write_raw_2_byte([170, 2])?;
            s.write_fixed32_array(&self.repeated_fixed32)?;
        }
        if !self.repeated_fixed64.is_empty() {
            s.write_raw_2_byte([178, 2])?;
            s.write_fixed64_array(&self.repeated_fixed64)?;
        }
        if !self.repeated_sfixed32.is_empty() {
            s.write_raw_2_byte([186, 2])?;
            s.write_sfixed32_array(&self.repeated_sfixed32)?;
        }
        if !self.repeated_sfixed64.is_empty() {
            s.write_raw_2_byte([194, 2])?;
            s.write_sfixed64_array(&self.repeated_sfixed64)?;
        }
        if !self.repeated_float.is_empty() {
            s.write_raw_2_byte([202, 2])?;
            s.write_f32_array(&self.repeated_float)?;
        }
        if !self.repeated_double.is_empty() {
            s.write_raw_2_byte([210, 2])?;
            s.write_f64_array(&self.repeated_double)?;
        }
        if !self.repeated_bool.is_empty() {
            s.write_raw_2_byte([218, 2])?;
            s.write_bool_array(&self.repeated_bool)?;
        }
        if !self.repeated_string.is_empty() {
            for v in &self.repeated_string {
                s.write_raw_2_byte([226, 2])?;
                s.write_string(v)?;
            }
        }
        if !self.repeated_bytes.is_empty() {
            for v in &self.repeated_bytes {
                s.write_raw_2_byte([234, 2])?;
                s.write_bytes(v)?;
            }
        }
        if !self.repeated_nested_message.is_empty() {
            for v in &self.repeated_nested_message {
                s.write_raw_2_byte([130, 3])?;
                s.write_message(v)?;
            }
        }
        if !self.repeated_foreign_message.is_empty() {
            for v in &self.repeated_foreign_message {
                s.write_raw_2_byte([138, 3])?;
                s.write_message(v)?;
            }
        }
        if !self.repeated_nested_enum.is_empty() {
            s.write_raw_2_byte([154, 3])?;
            s.write_enum_array(&self.repeated_nested_enum)?;
        }
        if !self.repeated_foreign_enum.is_empty() {
            s.write_raw_2_byte([162, 3])?;
            s.write_enum_array(&self.repeated_foreign_enum)?;
        }
        if !self.repeated_string_piece.is_empty() {
            for v in &self.repeated_string_piece {
                s.write_raw_2_byte([178, 3])?;
                s.write_string(v)?;
            }
        }
        if !self.repeated_cord.is_empty() {
            for v in &self.repeated_cord {
                s.write_raw_2_byte([186, 3])?;
                s.write_string(v)?;
            }
        }
        if !self.packed_int32.is_empty() {
            s.write_raw_2_byte([218, 4])?;
            s.write_var_i32_array(&self.packed_int32)?;
        }
        if !self.packed_int64.is_empty() {
            s.write_raw_2_byte([226, 4])?;
            s.write_var_i64_array(&self.packed_int64)?;
        }
        if !self.packed_uint32.is_empty() {
            s.write_raw_2_byte([234, 4])?;
            s.write_var_u32_array(&self.packed_uint32)?;
        }
        if !self.packed_uint64.is_empty() {
            s.write_raw_2_byte([242, 4])?;
            s.write_var_u64_array(&self.packed_uint64)?;
        }
        if !self.packed_sint32.is_empty() {
            s.write_raw_2_byte([250, 4])?;
            s.write_var_s32_array(&self.packed_sint32)?;
        }
        if !self.packed_sint64.is_empty() {
            s.write_raw_2_byte([130, 5])?;
            s.write_var_s64_array(&self.packed_sint64)?;
        }
        if !self.packed_fixed32.is_empty() {
            s.write_raw_2_byte([138, 5])?;
            s.write_fixed32_array(&self.packed_fixed32)?;
        }
        if !self.packed_fixed64.is_empty() {
            s.write_raw_2_byte([146, 5])?;
            s.write_fixed64_array(&self.packed_fixed64)?;
        }
        if !self.packed_sfixed32.is_empty() {
            s.write_raw_2_byte([154, 5])?;
            s.write_sfixed32_array(&self.packed_sfixed32)?;
        }
        if !self.packed_sfixed64.is_empty() {
            s.write_raw_2_byte([162, 5])?;
            s.write_sfixed64_array(&self.packed_sfixed64)?;
        }
        if !self.packed_float.is_empty() {
            s.write_raw_2_byte([170, 5])?;
            s.write_f32_array(&self.packed_float)?;
        }
        if !self.packed_double.is_empty() {
            s.write_raw_2_byte([178, 5])?;
            s.write_f64_array(&self.packed_double)?;
        }
        if !self.packed_bool.is_empty() {
            s.write_raw_2_byte([186, 5])?;
            s.write_bool_array(&self.packed_bool)?;
        }
        if !self.packed_nested_enum.is_empty() {
            s.write_raw_2_byte([194, 5])?;
            s.write_enum_array(&self.packed_nested_enum)?;
        }
        if !self.unpacked_int32.is_empty() {
            s.write_raw_2_byte([202, 5])?;
            s.write_var_i32_array(&self.unpacked_int32)?;
        }
        if !self.unpacked_int64.is_empty() {
            s.write_raw_2_byte([210, 5])?;
            s.write_var_i64_array(&self.unpacked_int64)?;
        }
        if !self.unpacked_uint32.is_empty() {
            s.write_raw_2_byte([218, 5])?;
            s.write_var_u32_array(&self.unpacked_uint32)?;
        }
        if !self.unpacked_uint64.is_empty() {
            s.write_raw_2_byte([226, 5])?;
            s.write_var_u64_array(&self.unpacked_uint64)?;
        }
        if !self.unpacked_sint32.is_empty() {
            s.write_raw_2_byte([234, 5])?;
            s.write_var_s32_array(&self.unpacked_sint32)?;
        }
        if !self.unpacked_sint64.is_empty() {
            s.write_raw_2_byte([242, 5])?;
            s.write_var_s64_array(&self.unpacked_sint64)?;
        }
        if !self.unpacked_fixed32.is_empty() {
            s.write_raw_2_byte([250, 5])?;
            s.write_fixed32_array(&self.unpacked_fixed32)?;
        }
        if !self.unpacked_fixed64.is_empty() {
            s.write_raw_2_byte([130, 6])?;
            s.write_fixed64_array(&self.unpacked_fixed64)?;
        }
        if !self.unpacked_sfixed32.is_empty() {
            s.write_raw_2_byte([138, 6])?;
            s.write_sfixed32_array(&self.unpacked_sfixed32)?;
        }
        if !self.unpacked_sfixed64.is_empty() {
            s.write_raw_2_byte([146, 6])?;
            s.write_sfixed64_array(&self.unpacked_sfixed64)?;
        }
        if !self.unpacked_float.is_empty() {
            s.write_raw_2_byte([154, 6])?;
            s.write_f32_array(&self.unpacked_float)?;
        }
        if !self.unpacked_double.is_empty() {
            s.write_raw_2_byte([162, 6])?;
            s.write_f64_array(&self.unpacked_double)?;
        }
        if !self.unpacked_bool.is_empty() {
            s.write_raw_2_byte([170, 6])?;
            s.write_bool_array(&self.unpacked_bool)?;
        }
        if !self.unpacked_nested_enum.is_empty() {
            s.write_raw_2_byte([178, 6])?;
            s.write_enum_array(&self.unpacked_nested_enum)?;
        }
        if let Some(m) = &self.map_int32_int32 {
            for (&k, &v) in m {
                s.write_raw_2_byte([194, 3])?;
                let mut n = 0;
                if 0 != k {
                    n += 1 + codec::varint_i64_bytes_len(k as i64) as usize;
                }
                if 0 != v {
                    n += 1 + codec::varint_i64_bytes_len(v as i64) as usize;
                }
                s.write_var_u32(n as u32)?;
                if 0 != k {
                    s.write_raw_1_byte([8])?;
                    s.write_var_i32(k)?;
                }
                if 0 != v {
                    s.write_raw_1_byte([16])?;
                    s.write_var_i32(v)?;
                }
            }
        }
        if let Some(m) = &self.map_int64_int64 {
            for (&k, &v) in m {
                s.write_raw_2_byte([202, 3])?;
                let mut n = 0;
                if 0 != k {
                    n += 1 + codec::varint_i64_bytes_len(k) as usize;
                }
                if 0 != v {
                    n += 1 + codec::varint_i64_bytes_len(v) as usize;
                }
                s.write_var_u32(n as u32)?;
                if 0 != k {
                    s.write_raw_1_byte([8])?;
                    s.write_var_i64(k)?;
                }
                if 0 != v {
                    s.write_raw_1_byte([16])?;
                    s.write_var_i64(v)?;
                }
            }
        }
        if let Some(m) = &self.map_uint32_uint32 {
            for (&k, &v) in m {
                s.write_raw_2_byte([210, 3])?;
                let mut n = 0;
                if 0 != k {
                    n += 1 + codec::varint_u32_bytes_len(k) as usize;
                }
                if 0 != v {
                    n += 1 + codec::varint_u32_bytes_len(v) as usize;
                }
                s.write_var_u32(n as u32)?;
                if 0 != k {
                    s.write_raw_1_byte([8])?;
                    s.write_var_u32(k)?;
                }
                if 0 != v {
                    s.write_raw_1_byte([16])?;
                    s.write_var_u32(v)?;
                }
            }
        }
        if let Some(m) = &self.map_uint64_uint64 {
            for (&k, &v) in m {
                s.write_raw_2_byte([218, 3])?;
                let mut n = 0;
                if 0 != k {
                    n += 1 + codec::varint_u64_bytes_len(k) as usize;
                }
                if 0 != v {
                    n += 1 + codec::varint_u64_bytes_len(v) as usize;
                }
                s.write_var_u32(n as u32)?;
                if 0 != k {
                    s.write_raw_1_byte([8])?;
                    s.write_var_u64(k)?;
                }
                if 0 != v {
                    s.write_raw_1_byte([16])?;
                    s.write_var_u64(v)?;
                }
            }
        }
        if let Some(m) = &self.map_sint32_sint32 {
            for (&k, &v) in m {
                s.write_raw_2_byte([226, 3])?;
                let mut n = 0;
                if 0 != k {
                    n += 1 + codec::varint_s32_bytes_len(k) as usize;
                }
                if 0 != v {
                    n += 1 + codec::varint_s32_bytes_len(v) as usize;
                }
                s.write_var_u32(n as u32)?;
                if 0 != k {
                    s.write_raw_1_byte([8])?;
                    s.write_var_s32(k)?;
                }
                if 0 != v {
                    s.write_raw_1_byte([16])?;
                    s.write_var_s32(v)?;
                }
            }
        }
        if let Some(m) = &self.map_sint64_sint64 {
            for (&k, &v) in m {
                s.write_raw_2_byte([234, 3])?;
                let mut n = 0;
                if 0 != k {
                    n += 1 + codec::varint_s64_bytes_len(k) as usize;
                }
                if 0 != v {
                    n += 1 + codec::varint_s64_bytes_len(v) as usize;
                }
                s.write_var_u32(n as u32)?;
                if 0 != k {
                    s.write_raw_1_byte([8])?;
                    s.write_var_s64(k)?;
                }
                if 0 != v {
                    s.write_raw_1_byte([16])?;
                    s.write_var_s64(v)?;
                }
            }
        }
        if let Some(m) = &self.map_fixed32_fixed32 {
            for (&k, &v) in m {
                s.write_raw_2_byte([242, 3])?;
                let mut n = 0;
                if 0 != k {
                    n += 5;
                }
                if 0 != v {
                    n += 5;
                }
                s.write_var_u32(n as u32)?;
                if 0 != k {
                    s.write_raw_1_byte([13])?;
                    s.write_fixed32(k)?;
                }
                if 0 != v {
                    s.write_raw_1_byte([21])?;
                    s.write_fixed32(v)?;
                }
            }
        }
        if let Some(m) = &self.map_fixed64_fixed64 {
            for (&k, &v) in m {
                s.write_raw_2_byte([250, 3])?;
                let mut n = 0;
                if 0 != k {
                    n += 9;
                }
                if 0 != v {
                    n += 9;
                }
                s.write_var_u32(n as u32)?;
                if 0 != k {
                    s.write_raw_1_byte([9])?;
                    s.write_fixed64(k)?;
                }
                if 0 != v {
                    s.write_raw_1_byte([17])?;
                    s.write_fixed64(v)?;
                }
            }
        }
        if let Some(m) = &self.map_sfixed32_sfixed32 {
            for (&k, &v) in m {
                s.write_raw_2_byte([130, 4])?;
                let mut n = 0;
                if 0 != k {
                    n += 5;
                }
                if 0 != v {
                    n += 5;
                }
                s.write_var_u32(n as u32)?;
                if 0 != k {
                    s.write_raw_1_byte([13])?;
                    s.write_sfixed32(k)?;
                }
                if 0 != v {
                    s.write_raw_1_byte([21])?;
                    s.write_sfixed32(v)?;
                }
            }
        }
        if let Some(m) = &self.map_sfixed64_sfixed64 {
            for (&k, &v) in m {
                s.write_raw_2_byte([138, 4])?;
                let mut n = 0;
                if 0 != k {
                    n += 9;
                }
                if 0 != v {
                    n += 9;
                }
                s.write_var_u32(n as u32)?;
                if 0 != k {
                    s.write_raw_1_byte([9])?;
                    s.write_sfixed64(k)?;
                }
                if 0 != v {
                    s.write_raw_1_byte([17])?;
                    s.write_sfixed64(v)?;
                }
            }
        }
        if let Some(m) = &self.map_int32_float {
            for (&k, &v) in m {
                s.write_raw_2_byte([146, 4])?;
                let mut n = 0;
                if 0 != k {
                    n += 1 + codec::varint_i64_bytes_len(k as i64) as usize;
                }
                if 0f32 != v {
                    n += 5;
                }
                s.write_var_u32(n as u32)?;
                if 0 != k {
                    s.write_raw_1_byte([8])?;
                    s.write_var_i32(k)?;
                }
                if 0f32 != v {
                    s.write_raw_1_byte([21])?;
                    s.write_f32(v)?;
                }
            }
        }
        if let Some(m) = &self.map_int32_double {
            for (&k, &v) in m {
                s.write_raw_2_byte([154, 4])?;
                let mut n = 0;
                if 0 != k {
                    n += 1 + codec::varint_i64_bytes_len(k as i64) as usize;
                }
                if 0f64 != v {
                    n += 9;
                }
                s.write_var_u32(n as u32)?;
                if 0 != k {
                    s.write_raw_1_byte([8])?;
                    s.write_var_i32(k)?;
                }
                if 0f64 != v {
                    s.write_raw_1_byte([17])?;
                    s.write_f64(v)?;
                }
            }
        }
        if let Some(m) = &self.map_bool_bool {
            for (&k, &v) in m {
                s.write_raw_2_byte([162, 4])?;
                let mut n = 0;
                if k {
                    n += 2;
                }
                if v {
                    n += 2;
                }
                s.write_var_u32(n as u32)?;
                if k {
                    s.write_raw_1_byte([8])?;
                    s.write_bool(k)?;
                }
                if v {
                    s.write_raw_1_byte([16])?;
                    s.write_bool(v)?;
                }
            }
        }
        if let Some(m) = &self.map_string_string {
            for (k, v) in m {
                s.write_raw_2_byte([170, 4])?;
                let mut n = 0;
                if !k.is_empty() {
                    n += {
                        let l = k.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                if !v.is_empty() {
                    n += {
                        let l = v.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                s.write_var_u32(n as u32)?;
                if !k.is_empty() {
                    s.write_raw_1_byte([10])?;
                    s.write_string(k)?;
                }
                if !v.is_empty() {
                    s.write_raw_1_byte([18])?;
                    s.write_string(v)?;
                }
            }
        }
        if let Some(m) = &self.map_string_bytes {
            for (k, v) in m {
                s.write_raw_2_byte([178, 4])?;
                let mut n = 0;
                if !k.is_empty() {
                    n += {
                        let l = k.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                if !v.is_empty() {
                    n += {
                        let l = v.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                s.write_var_u32(n as u32)?;
                if !k.is_empty() {
                    s.write_raw_1_byte([10])?;
                    s.write_string(k)?;
                }
                if !v.is_empty() {
                    s.write_raw_1_byte([18])?;
                    s.write_bytes(v)?;
                }
            }
        }
        if let Some(m) = &self.map_string_nested_message {
            for (k, v) in m {
                s.write_raw_2_byte([186, 4])?;
                let mut n = 0;
                if !k.is_empty() {
                    n += {
                        let l = k.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                n += {
                    let l = v.len();
                    1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                };
                s.write_var_u32(n as u32)?;
                if !k.is_empty() {
                    s.write_raw_1_byte([10])?;
                    s.write_string(k)?;
                }
                s.write_raw_1_byte([18])?;
                s.write_message(v)?;
            }
        }
        if let Some(m) = &self.map_string_foreign_message {
            for (k, v) in m {
                s.write_raw_2_byte([194, 4])?;
                let mut n = 0;
                if !k.is_empty() {
                    n += {
                        let l = k.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                n += {
                    let l = v.len();
                    1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                };
                s.write_var_u32(n as u32)?;
                if !k.is_empty() {
                    s.write_raw_1_byte([10])?;
                    s.write_string(k)?;
                }
                s.write_raw_1_byte([18])?;
                s.write_message(v)?;
            }
        }
        if let Some(m) = &self.map_string_nested_enum {
            for (k, &v) in m {
                s.write_raw_2_byte([202, 4])?;
                let mut n = 0;
                if !k.is_empty() {
                    n += {
                        let l = k.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                if v.value() != 0 {
                    n += 1 + codec::varint_i64_bytes_len(v.value() as i64) as usize;
                }
                s.write_var_u32(n as u32)?;
                if !k.is_empty() {
                    s.write_raw_1_byte([10])?;
                    s.write_string(k)?;
                }
                if v.value() != 0 {
                    s.write_raw_1_byte([16])?;
                    s.write_enum(v)?;
                }
            }
        }
        if let Some(m) = &self.map_string_foreign_enum {
            for (k, &v) in m {
                s.write_raw_2_byte([210, 4])?;
                let mut n = 0;
                if !k.is_empty() {
                    n += {
                        let l = k.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                if v.value() != 0 {
                    n += 1 + codec::varint_i64_bytes_len(v.value() as i64) as usize;
                }
                s.write_var_u32(n as u32)?;
                if !k.is_empty() {
                    s.write_raw_1_byte([10])?;
                    s.write_string(k)?;
                }
                if v.value() != 0 {
                    s.write_raw_1_byte([16])?;
                    s.write_enum(v)?;
                }
            }
        }
        if let Some(v) = &self.optional_bool_wrapper {
            s.write_raw_2_byte([202, 12])?;
            s.write_message(v)?;
        }
        if let Some(v) = &self.optional_int32_wrapper {
            s.write_raw_2_byte([210, 12])?;
            s.write_message(v)?;
        }
        if let Some(v) = &self.optional_int64_wrapper {
            s.write_raw_2_byte([218, 12])?;
            s.write_message(v)?;
        }
        if let Some(v) = &self.optional_uint32_wrapper {
            s.write_raw_2_byte([226, 12])?;
            s.write_message(v)?;
        }
        if let Some(v) = &self.optional_uint64_wrapper {
            s.write_raw_2_byte([234, 12])?;
            s.write_message(v)?;
        }
        if let Some(v) = &self.optional_float_wrapper {
            s.write_raw_2_byte([242, 12])?;
            s.write_message(v)?;
        }
        if let Some(v) = &self.optional_double_wrapper {
            s.write_raw_2_byte([250, 12])?;
            s.write_message(v)?;
        }
        if let Some(v) = &self.optional_string_wrapper {
            s.write_raw_2_byte([130, 13])?;
            s.write_message(v)?;
        }
        if let Some(v) = &self.optional_bytes_wrapper {
            s.write_raw_2_byte([138, 13])?;
            s.write_message(v)?;
        }
        if !self.repeated_bool_wrapper.is_empty() {
            for v in &self.repeated_bool_wrapper {
                s.write_raw_2_byte([154, 13])?;
                s.write_message(v)?;
            }
        }
        if !self.repeated_int32_wrapper.is_empty() {
            for v in &self.repeated_int32_wrapper {
                s.write_raw_2_byte([162, 13])?;
                s.write_message(v)?;
            }
        }
        if !self.repeated_int64_wrapper.is_empty() {
            for v in &self.repeated_int64_wrapper {
                s.write_raw_2_byte([170, 13])?;
                s.write_message(v)?;
            }
        }
        if !self.repeated_uint32_wrapper.is_empty() {
            for v in &self.repeated_uint32_wrapper {
                s.write_raw_2_byte([178, 13])?;
                s.write_message(v)?;
            }
        }
        if !self.repeated_uint64_wrapper.is_empty() {
            for v in &self.repeated_uint64_wrapper {
                s.write_raw_2_byte([186, 13])?;
                s.write_message(v)?;
            }
        }
        if !self.repeated_float_wrapper.is_empty() {
            for v in &self.repeated_float_wrapper {
                s.write_raw_2_byte([194, 13])?;
                s.write_message(v)?;
            }
        }
        if !self.repeated_double_wrapper.is_empty() {
            for v in &self.repeated_double_wrapper {
                s.write_raw_2_byte([202, 13])?;
                s.write_message(v)?;
            }
        }
        if !self.repeated_string_wrapper.is_empty() {
            for v in &self.repeated_string_wrapper {
                s.write_raw_2_byte([210, 13])?;
                s.write_message(v)?;
            }
        }
        if !self.repeated_bytes_wrapper.is_empty() {
            for v in &self.repeated_bytes_wrapper {
                s.write_raw_2_byte([218, 13])?;
                s.write_message(v)?;
            }
        }
        if let Some(v) = &self.optional_duration {
            s.write_raw_2_byte([234, 18])?;
            s.write_message(v)?;
        }
        if let Some(v) = &self.optional_timestamp {
            s.write_raw_2_byte([242, 18])?;
            s.write_message(v)?;
        }
        if let Some(v) = &self.optional_field_mask {
            s.write_raw_2_byte([250, 18])?;
            s.write_message(v)?;
        }
        if let Some(v) = &self.optional_struct {
            s.write_raw_2_byte([130, 19])?;
            s.write_message(v)?;
        }
        if let Some(v) = &self.optional_any {
            s.write_raw_2_byte([138, 19])?;
            s.write_message(v)?;
        }
        if let Some(v) = &self.optional_value {
            s.write_raw_2_byte([146, 19])?;
            s.write_message(v)?;
        }
        if !self.repeated_duration.is_empty() {
            for v in &self.repeated_duration {
                s.write_raw_2_byte([186, 19])?;
                s.write_message(v)?;
            }
        }
        if !self.repeated_timestamp.is_empty() {
            for v in &self.repeated_timestamp {
                s.write_raw_2_byte([194, 19])?;
                s.write_message(v)?;
            }
        }
        if !self.repeated_fieldmask.is_empty() {
            for v in &self.repeated_fieldmask {
                s.write_raw_2_byte([202, 19])?;
                s.write_message(v)?;
            }
        }
        if !self.repeated_struct.is_empty() {
            for v in &self.repeated_struct {
                s.write_raw_2_byte([162, 20])?;
                s.write_message(v)?;
            }
        }
        if !self.repeated_any.is_empty() {
            for v in &self.repeated_any {
                s.write_raw_2_byte([218, 19])?;
                s.write_message(v)?;
            }
        }
        if !self.repeated_value.is_empty() {
            for v in &self.repeated_value {
                s.write_raw_2_byte([226, 19])?;
                s.write_message(v)?;
            }
        }
        if !self.repeated_list_value.is_empty() {
            for v in &self.repeated_list_value {
                s.write_raw_2_byte([234, 19])?;
                s.write_message(v)?;
            }
        }
        if 0 != self.fieldname1 {
            s.write_raw_2_byte([136, 25])?;
            s.write_var_i32(self.fieldname1)?;
        }
        if 0 != self.field_name2 {
            s.write_raw_2_byte([144, 25])?;
            s.write_var_i32(self.field_name2)?;
        }
        if 0 != self.field_name3 {
            s.write_raw_2_byte([152, 25])?;
            s.write_var_i32(self.field_name3)?;
        }
        if 0 != self.field_name4_ {
            s.write_raw_2_byte([160, 25])?;
            s.write_var_i32(self.field_name4_)?;
        }
        if 0 != self.field0name5 {
            s.write_raw_2_byte([168, 25])?;
            s.write_var_i32(self.field0name5)?;
        }
        if 0 != self.field_0_name6 {
            s.write_raw_2_byte([176, 25])?;
            s.write_var_i32(self.field_0_name6)?;
        }
        if 0 != self.field_name7 {
            s.write_raw_2_byte([184, 25])?;
            s.write_var_i32(self.field_name7)?;
        }
        if 0 != self.field_name8 {
            s.write_raw_2_byte([192, 25])?;
            s.write_var_i32(self.field_name8)?;
        }
        if 0 != self.field_name9 {
            s.write_raw_2_byte([200, 25])?;
            s.write_var_i32(self.field_name9)?;
        }
        if 0 != self.field_name10 {
            s.write_raw_2_byte([208, 25])?;
            s.write_var_i32(self.field_name10)?;
        }
        if 0 != self.f_i_e_l_d_n_a_m_e11 {
            s.write_raw_2_byte([216, 25])?;
            s.write_var_i32(self.f_i_e_l_d_n_a_m_e11)?;
        }
        if 0 != self.f_i_e_l_d_name12 {
            s.write_raw_2_byte([224, 25])?;
            s.write_var_i32(self.f_i_e_l_d_name12)?;
        }
        if 0 != self.field_name13 {
            s.write_raw_2_byte([232, 25])?;
            s.write_var_i32(self.field_name13)?;
        }
        if 0 != self.field_name14 {
            s.write_raw_2_byte([240, 25])?;
            s.write_var_i32(self.field_name14)?;
        }
        if 0 != self.field_name15 {
            s.write_raw_2_byte([248, 25])?;
            s.write_var_i32(self.field_name15)?;
        }
        if 0 != self.field_name16 {
            s.write_raw_2_byte([128, 26])?;
            s.write_var_i32(self.field_name16)?;
        }
        if 0 != self.field_name17_ {
            s.write_raw_2_byte([136, 26])?;
            s.write_var_i32(self.field_name17_)?;
        }
        if 0 != self.field_name18_ {
            s.write_raw_2_byte([144, 26])?;
            s.write_var_i32(self.field_name18_)?;
        }
        if let Some(v) = &self.oneof_field {
            match v {
                TestAllTypesProto3NestedOneofField::OneofUint32(v) => {
                    s.write_raw_2_byte([248, 6])?;
                    s.write_var_u32(*v)?;
                }
                TestAllTypesProto3NestedOneofField::OneofNestedMessage(v) => {
                    s.write_raw_2_byte([130, 7])?;
                    s.write_message(v)?;
                }
                TestAllTypesProto3NestedOneofField::OneofString(v) => {
                    s.write_raw_2_byte([138, 7])?;
                    s.write_string(v)?;
                }
                TestAllTypesProto3NestedOneofField::OneofBytes(v) => {
                    s.write_raw_2_byte([146, 7])?;
                    s.write_bytes(v)?;
                }
                TestAllTypesProto3NestedOneofField::OneofBool(v) => {
                    s.write_raw_2_byte([152, 7])?;
                    s.write_bool(*v)?;
                }
                TestAllTypesProto3NestedOneofField::OneofUint64(v) => {
                    s.write_raw_2_byte([160, 7])?;
                    s.write_var_u64(*v)?;
                }
                TestAllTypesProto3NestedOneofField::OneofFloat(v) => {
                    s.write_raw_2_byte([173, 7])?;
                    s.write_f32(*v)?;
                }
                TestAllTypesProto3NestedOneofField::OneofDouble(v) => {
                    s.write_raw_2_byte([177, 7])?;
                    s.write_f64(*v)?;
                }
                TestAllTypesProto3NestedOneofField::OneofEnum(v) => {
                    s.write_raw_2_byte([184, 7])?;
                    s.write_enum(*v)?;
                }
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.optional_int32 {
            n += 1 + codec::varint_i64_bytes_len(self.optional_int32 as i64) as usize;
        }
        if 0 != self.optional_int64 {
            n += 1 + codec::varint_i64_bytes_len(self.optional_int64) as usize;
        }
        if 0 != self.optional_uint32 {
            n += 1 + codec::varint_u32_bytes_len(self.optional_uint32) as usize;
        }
        if 0 != self.optional_uint64 {
            n += 1 + codec::varint_u64_bytes_len(self.optional_uint64) as usize;
        }
        if 0 != self.optional_sint32 {
            n += 1 + codec::varint_s32_bytes_len(self.optional_sint32) as usize;
        }
        if 0 != self.optional_sint64 {
            n += 1 + codec::varint_s64_bytes_len(self.optional_sint64) as usize;
        }
        if 0 != self.optional_fixed32 {
            n += 5;
        }
        if 0 != self.optional_fixed64 {
            n += 9;
        }
        if 0 != self.optional_sfixed32 {
            n += 5;
        }
        if 0 != self.optional_sfixed64 {
            n += 9;
        }
        if 0f32 != self.optional_float {
            n += 5;
        }
        if 0f64 != self.optional_double {
            n += 9;
        }
        if self.optional_bool {
            n += 2;
        }
        if !self.optional_string.is_empty() {
            n += {
                let l = self.optional_string.len();
                1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.optional_bytes.is_empty() {
            n += {
                let l = self.optional_bytes.len();
                1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if let Some(v) = &self.optional_nested_message {
            n += {
                let l = v.len();
                2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if let Some(v) = &self.optional_foreign_message {
            n += {
                let l = v.len();
                2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if self.optional_nested_enum.value() != 0 {
            n += 2 + codec::varint_i64_bytes_len(self.optional_nested_enum.value() as i64) as usize;
        }
        if self.optional_foreign_enum.value() != 0 {
            n += 2 + codec::varint_i64_bytes_len(self.optional_foreign_enum.value() as i64) as usize;
        }
        if self.optional_aliased_enum.value() != 0 {
            n += 2 + codec::varint_i64_bytes_len(self.optional_aliased_enum.value() as i64) as usize;
        }
        if !self.optional_string_piece.is_empty() {
            n += {
                let l = self.optional_string_piece.len();
                2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.optional_cord.is_empty() {
            n += {
                let l = self.optional_cord.len();
                2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if let Some(v) = &self.recursive_message {
            n += {
                let l = v.len();
                2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.repeated_int32.is_empty() {
            n += {
                let l = self.repeated_int32.iter().map(|v| codec::varint_i64_bytes_len(*v as i64) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.repeated_int64.is_empty() {
            n += {
                let l = self.repeated_int64.iter().map(|v| codec::varint_i64_bytes_len(*v) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.repeated_uint32.is_empty() {
            n += {
                let l = self.repeated_uint32.iter().map(|v| codec::varint_u32_bytes_len(*v) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.repeated_uint64.is_empty() {
            n += {
                let l = self.repeated_uint64.iter().map(|v| codec::varint_u64_bytes_len(*v) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.repeated_sint32.is_empty() {
            n += {
                let l = self.repeated_sint32.iter().map(|v| codec::varint_s32_bytes_len(*v) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.repeated_sint64.is_empty() {
            n += {
                let l = self.repeated_sint64.iter().map(|v| codec::varint_s64_bytes_len(*v) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.repeated_fixed32.is_empty() {
            n += {
                let l = self.repeated_fixed32.len() * 4;
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.repeated_fixed64.is_empty() {
            n += {
                let l = self.repeated_fixed64.len() * 8;
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.repeated_sfixed32.is_empty() {
            n += {
                let l = self.repeated_sfixed32.len() * 4;
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.repeated_sfixed64.is_empty() {
            n += {
                let l = self.repeated_sfixed64.len() * 8;
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.repeated_float.is_empty() {
            n += {
                let l = self.repeated_float.len() * 4;
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.repeated_double.is_empty() {
            n += {
                let l = self.repeated_double.len() * 8;
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.repeated_bool.is_empty() {
            n += {
                let l = self.repeated_bool.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.repeated_string.is_empty() {
            n += self.repeated_string.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if !self.repeated_bytes.is_empty() {
            n += self.repeated_bytes.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if !self.repeated_nested_message.is_empty() {
            n += self.repeated_nested_message.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if !self.repeated_foreign_message.is_empty() {
            n += self.repeated_foreign_message.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if !self.repeated_nested_enum.is_empty() {
            n += {
                let l = self.repeated_nested_enum.iter().map(|v| codec::varint_i64_bytes_len(v.value() as i64) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.repeated_foreign_enum.is_empty() {
            n += {
                let l = self.repeated_foreign_enum.iter().map(|v| codec::varint_i64_bytes_len(v.value() as i64) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.repeated_string_piece.is_empty() {
            n += self.repeated_string_piece.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if !self.repeated_cord.is_empty() {
            n += self.repeated_cord.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if !self.packed_int32.is_empty() {
            n += {
                let l = self.packed_int32.iter().map(|v| codec::varint_i64_bytes_len(*v as i64) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.packed_int64.is_empty() {
            n += {
                let l = self.packed_int64.iter().map(|v| codec::varint_i64_bytes_len(*v) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.packed_uint32.is_empty() {
            n += {
                let l = self.packed_uint32.iter().map(|v| codec::varint_u32_bytes_len(*v) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.packed_uint64.is_empty() {
            n += {
                let l = self.packed_uint64.iter().map(|v| codec::varint_u64_bytes_len(*v) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.packed_sint32.is_empty() {
            n += {
                let l = self.packed_sint32.iter().map(|v| codec::varint_s32_bytes_len(*v) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.packed_sint64.is_empty() {
            n += {
                let l = self.packed_sint64.iter().map(|v| codec::varint_s64_bytes_len(*v) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.packed_fixed32.is_empty() {
            n += {
                let l = self.packed_fixed32.len() * 4;
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.packed_fixed64.is_empty() {
            n += {
                let l = self.packed_fixed64.len() * 8;
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.packed_sfixed32.is_empty() {
            n += {
                let l = self.packed_sfixed32.len() * 4;
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.packed_sfixed64.is_empty() {
            n += {
                let l = self.packed_sfixed64.len() * 8;
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.packed_float.is_empty() {
            n += {
                let l = self.packed_float.len() * 4;
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.packed_double.is_empty() {
            n += {
                let l = self.packed_double.len() * 8;
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.packed_bool.is_empty() {
            n += {
                let l = self.packed_bool.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.packed_nested_enum.is_empty() {
            n += {
                let l = self.packed_nested_enum.iter().map(|v| codec::varint_i64_bytes_len(v.value() as i64) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.unpacked_int32.is_empty() {
            n += {
                let l = self.unpacked_int32.iter().map(|v| codec::varint_i64_bytes_len(*v as i64) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.unpacked_int64.is_empty() {
            n += {
                let l = self.unpacked_int64.iter().map(|v| codec::varint_i64_bytes_len(*v) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.unpacked_uint32.is_empty() {
            n += {
                let l = self.unpacked_uint32.iter().map(|v| codec::varint_u32_bytes_len(*v) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.unpacked_uint64.is_empty() {
            n += {
                let l = self.unpacked_uint64.iter().map(|v| codec::varint_u64_bytes_len(*v) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.unpacked_sint32.is_empty() {
            n += {
                let l = self.unpacked_sint32.iter().map(|v| codec::varint_s32_bytes_len(*v) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.unpacked_sint64.is_empty() {
            n += {
                let l = self.unpacked_sint64.iter().map(|v| codec::varint_s64_bytes_len(*v) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.unpacked_fixed32.is_empty() {
            n += {
                let l = self.unpacked_fixed32.len() * 4;
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.unpacked_fixed64.is_empty() {
            n += {
                let l = self.unpacked_fixed64.len() * 8;
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.unpacked_sfixed32.is_empty() {
            n += {
                let l = self.unpacked_sfixed32.len() * 4;
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.unpacked_sfixed64.is_empty() {
            n += {
                let l = self.unpacked_sfixed64.len() * 8;
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.unpacked_float.is_empty() {
            n += {
                let l = self.unpacked_float.len() * 4;
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.unpacked_double.is_empty() {
            n += {
                let l = self.unpacked_double.len() * 8;
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.unpacked_bool.is_empty() {
            n += {
                let l = self.unpacked_bool.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.unpacked_nested_enum.is_empty() {
            n += {
                let l = self.unpacked_nested_enum.iter().map(|v| codec::varint_i64_bytes_len(v.value() as i64) as usize).sum::<usize>();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if let Some(m) = &self.map_int32_int32 {
            for (&k, &v) in m {
                n += 2;
                if 0 != k {
                    n += 1 + codec::varint_i64_bytes_len(k as i64) as usize;
                }
                if 0 != v {
                    n += 1 + codec::varint_i64_bytes_len(v as i64) as usize;
                }
            }
        }
        if let Some(m) = &self.map_int64_int64 {
            for (&k, &v) in m {
                n += 2;
                if 0 != k {
                    n += 1 + codec::varint_i64_bytes_len(k) as usize;
                }
                if 0 != v {
                    n += 1 + codec::varint_i64_bytes_len(v) as usize;
                }
            }
        }
        if let Some(m) = &self.map_uint32_uint32 {
            for (&k, &v) in m {
                n += 2;
                if 0 != k {
                    n += 1 + codec::varint_u32_bytes_len(k) as usize;
                }
                if 0 != v {
                    n += 1 + codec::varint_u32_bytes_len(v) as usize;
                }
            }
        }
        if let Some(m) = &self.map_uint64_uint64 {
            for (&k, &v) in m {
                n += 2;
                if 0 != k {
                    n += 1 + codec::varint_u64_bytes_len(k) as usize;
                }
                if 0 != v {
                    n += 1 + codec::varint_u64_bytes_len(v) as usize;
                }
            }
        }
        if let Some(m) = &self.map_sint32_sint32 {
            for (&k, &v) in m {
                n += 2;
                if 0 != k {
                    n += 1 + codec::varint_s32_bytes_len(k) as usize;
                }
                if 0 != v {
                    n += 1 + codec::varint_s32_bytes_len(v) as usize;
                }
            }
        }
        if let Some(m) = &self.map_sint64_sint64 {
            for (&k, &v) in m {
                n += 2;
                if 0 != k {
                    n += 1 + codec::varint_s64_bytes_len(k) as usize;
                }
                if 0 != v {
                    n += 1 + codec::varint_s64_bytes_len(v) as usize;
                }
            }
        }
        if let Some(m) = &self.map_fixed32_fixed32 {
            for (&k, &v) in m {
                n += 2;
                if 0 != k {
                    n += 5;
                }
                if 0 != v {
                    n += 5;
                }
            }
        }
        if let Some(m) = &self.map_fixed64_fixed64 {
            for (&k, &v) in m {
                n += 2;
                if 0 != k {
                    n += 9;
                }
                if 0 != v {
                    n += 9;
                }
            }
        }
        if let Some(m) = &self.map_sfixed32_sfixed32 {
            for (&k, &v) in m {
                n += 2;
                if 0 != k {
                    n += 5;
                }
                if 0 != v {
                    n += 5;
                }
            }
        }
        if let Some(m) = &self.map_sfixed64_sfixed64 {
            for (&k, &v) in m {
                n += 2;
                if 0 != k {
                    n += 9;
                }
                if 0 != v {
                    n += 9;
                }
            }
        }
        if let Some(m) = &self.map_int32_float {
            for (&k, &v) in m {
                n += 2;
                if 0 != k {
                    n += 1 + codec::varint_i64_bytes_len(k as i64) as usize;
                }
                if 0f32 != v {
                    n += 5;
                }
            }
        }
        if let Some(m) = &self.map_int32_double {
            for (&k, &v) in m {
                n += 2;
                if 0 != k {
                    n += 1 + codec::varint_i64_bytes_len(k as i64) as usize;
                }
                if 0f64 != v {
                    n += 9;
                }
            }
        }
        if let Some(m) = &self.map_bool_bool {
            for (&k, &v) in m {
                n += 2;
                if k {
                    n += 2;
                }
                if v {
                    n += 2;
                }
            }
        }
        if let Some(m) = &self.map_string_string {
            for (k, v) in m {
                n += 2;
                if !k.is_empty() {
                    n += {
                        let l = k.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                if !v.is_empty() {
                    n += {
                        let l = v.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
            }
        }
        if let Some(m) = &self.map_string_bytes {
            for (k, v) in m {
                n += 2;
                if !k.is_empty() {
                    n += {
                        let l = k.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                if !v.is_empty() {
                    n += {
                        let l = v.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
            }
        }
        if let Some(m) = &self.map_string_nested_message {
            for (k, v) in m {
                n += 2;
                if !k.is_empty() {
                    n += {
                        let l = k.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                n += {
                    let l = v.len();
                    1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                };
            }
        }
        if let Some(m) = &self.map_string_foreign_message {
            for (k, v) in m {
                n += 2;
                if !k.is_empty() {
                    n += {
                        let l = k.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                n += {
                    let l = v.len();
                    1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                };
            }
        }
        if let Some(m) = &self.map_string_nested_enum {
            for (k, &v) in m {
                n += 2;
                if !k.is_empty() {
                    n += {
                        let l = k.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                if v.value() != 0 {
                    n += 1 + codec::varint_i64_bytes_len(v.value() as i64) as usize;
                }
            }
        }
        if let Some(m) = &self.map_string_foreign_enum {
            for (k, &v) in m {
                n += 2;
                if !k.is_empty() {
                    n += {
                        let l = k.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                if v.value() != 0 {
                    n += 1 + codec::varint_i64_bytes_len(v.value() as i64) as usize;
                }
            }
        }
        if let Some(v) = &self.optional_bool_wrapper {
            n += {
                let l = v.len();
                2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if let Some(v) = &self.optional_int32_wrapper {
            n += {
                let l = v.len();
                2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if let Some(v) = &self.optional_int64_wrapper {
            n += {
                let l = v.len();
                2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if let Some(v) = &self.optional_uint32_wrapper {
            n += {
                let l = v.len();
                2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if let Some(v) = &self.optional_uint64_wrapper {
            n += {
                let l = v.len();
                2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if let Some(v) = &self.optional_float_wrapper {
            n += {
                let l = v.len();
                2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if let Some(v) = &self.optional_double_wrapper {
            n += {
                let l = v.len();
                2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if let Some(v) = &self.optional_string_wrapper {
            n += {
                let l = v.len();
                2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if let Some(v) = &self.optional_bytes_wrapper {
            n += {
                let l = v.len();
                2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.repeated_bool_wrapper.is_empty() {
            n += self.repeated_bool_wrapper.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if !self.repeated_int32_wrapper.is_empty() {
            n += self.repeated_int32_wrapper.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if !self.repeated_int64_wrapper.is_empty() {
            n += self.repeated_int64_wrapper.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if !self.repeated_uint32_wrapper.is_empty() {
            n += self.repeated_uint32_wrapper.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if !self.repeated_uint64_wrapper.is_empty() {
            n += self.repeated_uint64_wrapper.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if !self.repeated_float_wrapper.is_empty() {
            n += self.repeated_float_wrapper.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if !self.repeated_double_wrapper.is_empty() {
            n += self.repeated_double_wrapper.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if !self.repeated_string_wrapper.is_empty() {
            n += self.repeated_string_wrapper.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if !self.repeated_bytes_wrapper.is_empty() {
            n += self.repeated_bytes_wrapper.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if let Some(v) = &self.optional_duration {
            n += {
                let l = v.len();
                2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if let Some(v) = &self.optional_timestamp {
            n += {
                let l = v.len();
                2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if let Some(v) = &self.optional_field_mask {
            n += {
                let l = v.len();
                2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if let Some(v) = &self.optional_struct {
            n += {
                let l = v.len();
                2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if let Some(v) = &self.optional_any {
            n += {
                let l = v.len();
                2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if let Some(v) = &self.optional_value {
            n += {
                let l = v.len();
                2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.repeated_duration.is_empty() {
            n += self.repeated_duration.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if !self.repeated_timestamp.is_empty() {
            n += self.repeated_timestamp.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if !self.repeated_fieldmask.is_empty() {
            n += self.repeated_fieldmask.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if !self.repeated_struct.is_empty() {
            n += self.repeated_struct.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if !self.repeated_any.is_empty() {
            n += self.repeated_any.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if !self.repeated_value.is_empty() {
            n += self.repeated_value.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if !self.repeated_list_value.is_empty() {
            n += self.repeated_list_value.iter().fold(0, |n, m| {
                let l = m.len();
                n + 2 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        if 0 != self.fieldname1 {
            n += 2 + codec::varint_i64_bytes_len(self.fieldname1 as i64) as usize;
        }
        if 0 != self.field_name2 {
            n += 2 + codec::varint_i64_bytes_len(self.field_name2 as i64) as usize;
        }
        if 0 != self.field_name3 {
            n += 2 + codec::varint_i64_bytes_len(self.field_name3 as i64) as usize;
        }
        if 0 != self.field_name4_ {
            n += 2 + codec::varint_i64_bytes_len(self.field_name4_ as i64) as usize;
        }
        if 0 != self.field0name5 {
            n += 2 + codec::varint_i64_bytes_len(self.field0name5 as i64) as usize;
        }
        if 0 != self.field_0_name6 {
            n += 2 + codec::varint_i64_bytes_len(self.field_0_name6 as i64) as usize;
        }
        if 0 != self.field_name7 {
            n += 2 + codec::varint_i64_bytes_len(self.field_name7 as i64) as usize;
        }
        if 0 != self.field_name8 {
            n += 2 + codec::varint_i64_bytes_len(self.field_name8 as i64) as usize;
        }
        if 0 != self.field_name9 {
            n += 2 + codec::varint_i64_bytes_len(self.field_name9 as i64) as usize;
        }
        if 0 != self.field_name10 {
            n += 2 + codec::varint_i64_bytes_len(self.field_name10 as i64) as usize;
        }
        if 0 != self.f_i_e_l_d_n_a_m_e11 {
            n += 2 + codec::varint_i64_bytes_len(self.f_i_e_l_d_n_a_m_e11 as i64) as usize;
        }
        if 0 != self.f_i_e_l_d_name12 {
            n += 2 + codec::varint_i64_bytes_len(self.f_i_e_l_d_name12 as i64) as usize;
        }
        if 0 != self.field_name13 {
            n += 2 + codec::varint_i64_bytes_len(self.field_name13 as i64) as usize;
        }
        if 0 != self.field_name14 {
            n += 2 + codec::varint_i64_bytes_len(self.field_name14 as i64) as usize;
        }
        if 0 != self.field_name15 {
            n += 2 + codec::varint_i64_bytes_len(self.field_name15 as i64) as usize;
        }
        if 0 != self.field_name16 {
            n += 2 + codec::varint_i64_bytes_len(self.field_name16 as i64) as usize;
        }
        if 0 != self.field_name17_ {
            n += 2 + codec::varint_i64_bytes_len(self.field_name17_ as i64) as usize;
        }
        if 0 != self.field_name18_ {
            n += 2 + codec::varint_i64_bytes_len(self.field_name18_ as i64) as usize;
        }
        if let Some(v) = &self.oneof_field {
            match v {
                TestAllTypesProto3NestedOneofField::OneofUint32(v) => {
                    n += 2 + codec::varint_u32_bytes_len(*v) as usize;
                }
                TestAllTypesProto3NestedOneofField::OneofNestedMessage(v) => {
                    n += {
                        let l = v.len();
                        2 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                TestAllTypesProto3NestedOneofField::OneofString(v) => {
                    n += {
                        let l = v.len();
                        2 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                TestAllTypesProto3NestedOneofField::OneofBytes(v) => {
                    n += {
                        let l = v.len();
                        2 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                TestAllTypesProto3NestedOneofField::OneofBool(_) => {
                    n += 3;
                }
                TestAllTypesProto3NestedOneofField::OneofUint64(v) => {
                    n += 2 + codec::varint_u64_bytes_len(*v) as usize;
                }
                TestAllTypesProto3NestedOneofField::OneofFloat(_) => {
                    n += 6;
                }
                TestAllTypesProto3NestedOneofField::OneofDouble(_) => {
                    n += 10;
                }
                TestAllTypesProto3NestedOneofField::OneofEnum(v) => {
                    n += 2 + codec::varint_i64_bytes_len((*v).value() as i64) as usize;
                }
            }
        }
        n
    }
}

impl TestAllTypesProto3 {
    pub const fn new() -> TestAllTypesProto3 {
        TestAllTypesProto3 {
            optional_int32: 0,
            optional_int64: 0,
            optional_uint32: 0,
            optional_uint64: 0,
            optional_sint32: 0,
            optional_sint64: 0,
            optional_fixed32: 0,
            optional_fixed64: 0,
            optional_sfixed32: 0,
            optional_sfixed64: 0,
            optional_float: 0f32,
            optional_double: 0f64,
            optional_bool: false,
            optional_string: String::new(),
            optional_bytes: Vec::new(),
            optional_nested_message: None,
            optional_foreign_message: None,
            optional_nested_enum: TestAllTypesProto3NestedNestedEnum::new(),
            optional_foreign_enum: ForeignEnum::new(),
            optional_aliased_enum: TestAllTypesProto3NestedAliasedEnum::new(),
            optional_string_piece: String::new(),
            optional_cord: String::new(),
            recursive_message: None,
            repeated_int32: Vec::new(),
            repeated_int64: Vec::new(),
            repeated_uint32: Vec::new(),
            repeated_uint64: Vec::new(),
            repeated_sint32: Vec::new(),
            repeated_sint64: Vec::new(),
            repeated_fixed32: Vec::new(),
            repeated_fixed64: Vec::new(),
            repeated_sfixed32: Vec::new(),
            repeated_sfixed64: Vec::new(),
            repeated_float: Vec::new(),
            repeated_double: Vec::new(),
            repeated_bool: Vec::new(),
            repeated_string: Vec::new(),
            repeated_bytes: Vec::new(),
            repeated_nested_message: Vec::new(),
            repeated_foreign_message: Vec::new(),
            repeated_nested_enum: Vec::new(),
            repeated_foreign_enum: Vec::new(),
            repeated_string_piece: Vec::new(),
            repeated_cord: Vec::new(),
            packed_int32: Vec::new(),
            packed_int64: Vec::new(),
            packed_uint32: Vec::new(),
            packed_uint64: Vec::new(),
            packed_sint32: Vec::new(),
            packed_sint64: Vec::new(),
            packed_fixed32: Vec::new(),
            packed_fixed64: Vec::new(),
            packed_sfixed32: Vec::new(),
            packed_sfixed64: Vec::new(),
            packed_float: Vec::new(),
            packed_double: Vec::new(),
            packed_bool: Vec::new(),
            packed_nested_enum: Vec::new(),
            unpacked_int32: Vec::new(),
            unpacked_int64: Vec::new(),
            unpacked_uint32: Vec::new(),
            unpacked_uint64: Vec::new(),
            unpacked_sint32: Vec::new(),
            unpacked_sint64: Vec::new(),
            unpacked_fixed32: Vec::new(),
            unpacked_fixed64: Vec::new(),
            unpacked_sfixed32: Vec::new(),
            unpacked_sfixed64: Vec::new(),
            unpacked_float: Vec::new(),
            unpacked_double: Vec::new(),
            unpacked_bool: Vec::new(),
            unpacked_nested_enum: Vec::new(),
            map_int32_int32: None,
            map_int64_int64: None,
            map_uint32_uint32: None,
            map_uint64_uint64: None,
            map_sint32_sint32: None,
            map_sint64_sint64: None,
            map_fixed32_fixed32: None,
            map_fixed64_fixed64: None,
            map_sfixed32_sfixed32: None,
            map_sfixed64_sfixed64: None,
            map_int32_float: None,
            map_int32_double: None,
            map_bool_bool: None,
            map_string_string: None,
            map_string_bytes: None,
            map_string_nested_message: None,
            map_string_foreign_message: None,
            map_string_nested_enum: None,
            map_string_foreign_enum: None,
            optional_bool_wrapper: None,
            optional_int32_wrapper: None,
            optional_int64_wrapper: None,
            optional_uint32_wrapper: None,
            optional_uint64_wrapper: None,
            optional_float_wrapper: None,
            optional_double_wrapper: None,
            optional_string_wrapper: None,
            optional_bytes_wrapper: None,
            repeated_bool_wrapper: Vec::new(),
            repeated_int32_wrapper: Vec::new(),
            repeated_int64_wrapper: Vec::new(),
            repeated_uint32_wrapper: Vec::new(),
            repeated_uint64_wrapper: Vec::new(),
            repeated_float_wrapper: Vec::new(),
            repeated_double_wrapper: Vec::new(),
            repeated_string_wrapper: Vec::new(),
            repeated_bytes_wrapper: Vec::new(),
            optional_duration: None,
            optional_timestamp: None,
            optional_field_mask: None,
            optional_struct: None,
            optional_any: None,
            optional_value: None,
            repeated_duration: Vec::new(),
            repeated_timestamp: Vec::new(),
            repeated_fieldmask: Vec::new(),
            repeated_struct: Vec::new(),
            repeated_any: Vec::new(),
            repeated_value: Vec::new(),
            repeated_list_value: Vec::new(),
            fieldname1: 0,
            field_name2: 0,
            field_name3: 0,
            field_name4_: 0,
            field0name5: 0,
            field_0_name6: 0,
            field_name7: 0,
            field_name8: 0,
            field_name9: 0,
            field_name10: 0,
            f_i_e_l_d_n_a_m_e11: 0,
            f_i_e_l_d_name12: 0,
            field_name13: 0,
            field_name14: 0,
            field_name15: 0,
            field_name16: 0,
            field_name17_: 0,
            field_name18_: 0,
            oneof_field: None,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3 {
        static DEFAULT: TestAllTypesProto3 = TestAllTypesProto3::new();
        &DEFAULT
    }

    pub fn optional_int32(&self) -> i32 { self.optional_int32 }

    pub fn clear_optional_int32(&mut self) { self.optional_int32 = 0; }

    pub fn set_optional_int32(&mut self, v: i32) { self.optional_int32 = v; }

    pub fn optional_int64(&self) -> i64 { self.optional_int64 }

    pub fn clear_optional_int64(&mut self) { self.optional_int64 = 0; }

    pub fn set_optional_int64(&mut self, v: i64) { self.optional_int64 = v; }

    pub fn optional_uint32(&self) -> u32 { self.optional_uint32 }

    pub fn clear_optional_uint32(&mut self) { self.optional_uint32 = 0; }

    pub fn set_optional_uint32(&mut self, v: u32) { self.optional_uint32 = v; }

    pub fn optional_uint64(&self) -> u64 { self.optional_uint64 }

    pub fn clear_optional_uint64(&mut self) { self.optional_uint64 = 0; }

    pub fn set_optional_uint64(&mut self, v: u64) { self.optional_uint64 = v; }

    pub fn optional_sint32(&self) -> i32 { self.optional_sint32 }

    pub fn clear_optional_sint32(&mut self) { self.optional_sint32 = 0; }

    pub fn set_optional_sint32(&mut self, v: i32) { self.optional_sint32 = v; }

    pub fn optional_sint64(&self) -> i64 { self.optional_sint64 }

    pub fn clear_optional_sint64(&mut self) { self.optional_sint64 = 0; }

    pub fn set_optional_sint64(&mut self, v: i64) { self.optional_sint64 = v; }

    pub fn optional_fixed32(&self) -> u32 { self.optional_fixed32 }

    pub fn clear_optional_fixed32(&mut self) { self.optional_fixed32 = 0; }

    pub fn set_optional_fixed32(&mut self, v: u32) { self.optional_fixed32 = v; }

    pub fn optional_fixed64(&self) -> u64 { self.optional_fixed64 }

    pub fn clear_optional_fixed64(&mut self) { self.optional_fixed64 = 0; }

    pub fn set_optional_fixed64(&mut self, v: u64) { self.optional_fixed64 = v; }

    pub fn optional_sfixed32(&self) -> i32 { self.optional_sfixed32 }

    pub fn clear_optional_sfixed32(&mut self) { self.optional_sfixed32 = 0; }

    pub fn set_optional_sfixed32(&mut self, v: i32) { self.optional_sfixed32 = v; }

    pub fn optional_sfixed64(&self) -> i64 { self.optional_sfixed64 }

    pub fn clear_optional_sfixed64(&mut self) { self.optional_sfixed64 = 0; }

    pub fn set_optional_sfixed64(&mut self, v: i64) { self.optional_sfixed64 = v; }

    pub fn optional_float(&self) -> f32 { self.optional_float }

    pub fn clear_optional_float(&mut self) { self.optional_float = 0f32; }

    pub fn set_optional_float(&mut self, v: f32) { self.optional_float = v; }

    pub fn optional_double(&self) -> f64 { self.optional_double }

    pub fn clear_optional_double(&mut self) { self.optional_double = 0f64; }

    pub fn set_optional_double(&mut self, v: f64) { self.optional_double = v; }

    pub fn optional_bool(&self) -> bool { self.optional_bool }

    pub fn clear_optional_bool(&mut self) { self.optional_bool = false; }

    pub fn set_optional_bool(&mut self, v: bool) { self.optional_bool = v; }

    pub fn optional_string(&self) -> &str { &self.optional_string }

    pub fn clear_optional_string(&mut self) { self.optional_string = Default::default(); }

    pub fn set_optional_string(&mut self, v: String) { self.optional_string = v; }

    pub fn optional_string_mut(&mut self) -> &mut String { &mut self.optional_string }

    pub fn optional_bytes(&self) -> &[u8] { &self.optional_bytes }

    pub fn clear_optional_bytes(&mut self) { self.optional_bytes = Default::default(); }

    pub fn set_optional_bytes(&mut self, v: Vec<u8>) { self.optional_bytes = v; }

    pub fn optional_bytes_mut(&mut self) -> &mut Vec<u8> { &mut self.optional_bytes }

    pub fn optional_nested_message(&self) -> &TestAllTypesProto3NestedNestedMessage {
        self.optional_nested_message.as_ref().unwrap_or_else(|| TestAllTypesProto3NestedNestedMessage::default_instance())
    }

    pub fn clear_optional_nested_message(&mut self) { self.optional_nested_message = None; }

    pub fn has_optional_nested_message(&self) -> bool { self.optional_nested_message.is_some() }

    pub fn set_optional_nested_message(&mut self, v: TestAllTypesProto3NestedNestedMessage) { self.optional_nested_message = Some(v); }

    pub fn optional_nested_message_mut(&mut self) -> &mut TestAllTypesProto3NestedNestedMessage {
        self.optional_nested_message.get_or_insert_with(Default::default)
    }

    pub fn optional_foreign_message(&self) -> &ForeignMessage {
        self.optional_foreign_message.as_ref().unwrap_or_else(|| ForeignMessage::default_instance())
    }

    pub fn clear_optional_foreign_message(&mut self) { self.optional_foreign_message = None; }

    pub fn has_optional_foreign_message(&self) -> bool { self.optional_foreign_message.is_some() }

    pub fn set_optional_foreign_message(&mut self, v: ForeignMessage) { self.optional_foreign_message = Some(v); }

    pub fn optional_foreign_message_mut(&mut self) -> &mut ForeignMessage {
        self.optional_foreign_message.get_or_insert_with(Default::default)
    }

    pub fn optional_nested_enum(&self) -> TestAllTypesProto3NestedNestedEnum { self.optional_nested_enum }

    pub fn clear_optional_nested_enum(&mut self) { self.optional_nested_enum = Default::default(); }

    pub fn set_optional_nested_enum(&mut self, v: TestAllTypesProto3NestedNestedEnum) { self.optional_nested_enum = v; }

    pub fn optional_foreign_enum(&self) -> ForeignEnum { self.optional_foreign_enum }

    pub fn clear_optional_foreign_enum(&mut self) { self.optional_foreign_enum = Default::default(); }

    pub fn set_optional_foreign_enum(&mut self, v: ForeignEnum) { self.optional_foreign_enum = v; }

    pub fn optional_aliased_enum(&self) -> TestAllTypesProto3NestedAliasedEnum { self.optional_aliased_enum }

    pub fn clear_optional_aliased_enum(&mut self) { self.optional_aliased_enum = Default::default(); }

    pub fn set_optional_aliased_enum(&mut self, v: TestAllTypesProto3NestedAliasedEnum) { self.optional_aliased_enum = v; }

    pub fn optional_string_piece(&self) -> &str { &self.optional_string_piece }

    pub fn clear_optional_string_piece(&mut self) { self.optional_string_piece = Default::default(); }

    pub fn set_optional_string_piece(&mut self, v: String) { self.optional_string_piece = v; }

    pub fn optional_string_piece_mut(&mut self) -> &mut String { &mut self.optional_string_piece }

    pub fn optional_cord(&self) -> &str { &self.optional_cord }

    pub fn clear_optional_cord(&mut self) { self.optional_cord = Default::default(); }

    pub fn set_optional_cord(&mut self, v: String) { self.optional_cord = v; }

    pub fn optional_cord_mut(&mut self) -> &mut String { &mut self.optional_cord }

    pub fn recursive_message(&self) -> &TestAllTypesProto3 {
        self.recursive_message.as_ref().map_or_else(|| TestAllTypesProto3::default_instance(), |d| d.as_ref())
    }

    pub fn clear_recursive_message(&mut self) { self.recursive_message = None; }

    pub fn has_recursive_message(&self) -> bool { self.recursive_message.is_some() }

    pub fn set_recursive_message(&mut self, v: TestAllTypesProto3) { self.recursive_message = Some(Box::new(v)); }

    pub fn recursive_message_mut(&mut self) -> &mut TestAllTypesProto3 {
        self.recursive_message.get_or_insert_with(Default::default)
    }

    pub fn repeated_int32(&self) -> &[i32] { &self.repeated_int32 }

    pub fn clear_repeated_int32(&mut self) { self.repeated_int32.clear(); }

    pub fn set_repeated_int32(&mut self, v: impl Into<Vec<i32>>) { self.repeated_int32 = v.into(); }

    pub fn repeated_int32_mut(&mut self) -> &mut Vec<i32> { &mut self.repeated_int32 }

    pub fn repeated_int64(&self) -> &[i64] { &self.repeated_int64 }

    pub fn clear_repeated_int64(&mut self) { self.repeated_int64.clear(); }

    pub fn set_repeated_int64(&mut self, v: impl Into<Vec<i64>>) { self.repeated_int64 = v.into(); }

    pub fn repeated_int64_mut(&mut self) -> &mut Vec<i64> { &mut self.repeated_int64 }

    pub fn repeated_uint32(&self) -> &[u32] { &self.repeated_uint32 }

    pub fn clear_repeated_uint32(&mut self) { self.repeated_uint32.clear(); }

    pub fn set_repeated_uint32(&mut self, v: impl Into<Vec<u32>>) { self.repeated_uint32 = v.into(); }

    pub fn repeated_uint32_mut(&mut self) -> &mut Vec<u32> { &mut self.repeated_uint32 }

    pub fn repeated_uint64(&self) -> &[u64] { &self.repeated_uint64 }

    pub fn clear_repeated_uint64(&mut self) { self.repeated_uint64.clear(); }

    pub fn set_repeated_uint64(&mut self, v: impl Into<Vec<u64>>) { self.repeated_uint64 = v.into(); }

    pub fn repeated_uint64_mut(&mut self) -> &mut Vec<u64> { &mut self.repeated_uint64 }

    pub fn repeated_sint32(&self) -> &[i32] { &self.repeated_sint32 }

    pub fn clear_repeated_sint32(&mut self) { self.repeated_sint32.clear(); }

    pub fn set_repeated_sint32(&mut self, v: impl Into<Vec<i32>>) { self.repeated_sint32 = v.into(); }

    pub fn repeated_sint32_mut(&mut self) -> &mut Vec<i32> { &mut self.repeated_sint32 }

    pub fn repeated_sint64(&self) -> &[i64] { &self.repeated_sint64 }

    pub fn clear_repeated_sint64(&mut self) { self.repeated_sint64.clear(); }

    pub fn set_repeated_sint64(&mut self, v: impl Into<Vec<i64>>) { self.repeated_sint64 = v.into(); }

    pub fn repeated_sint64_mut(&mut self) -> &mut Vec<i64> { &mut self.repeated_sint64 }

    pub fn repeated_fixed32(&self) -> &[u32] { &self.repeated_fixed32 }

    pub fn clear_repeated_fixed32(&mut self) { self.repeated_fixed32.clear(); }

    pub fn set_repeated_fixed32(&mut self, v: impl Into<Vec<u32>>) { self.repeated_fixed32 = v.into(); }

    pub fn repeated_fixed32_mut(&mut self) -> &mut Vec<u32> { &mut self.repeated_fixed32 }

    pub fn repeated_fixed64(&self) -> &[u64] { &self.repeated_fixed64 }

    pub fn clear_repeated_fixed64(&mut self) { self.repeated_fixed64.clear(); }

    pub fn set_repeated_fixed64(&mut self, v: impl Into<Vec<u64>>) { self.repeated_fixed64 = v.into(); }

    pub fn repeated_fixed64_mut(&mut self) -> &mut Vec<u64> { &mut self.repeated_fixed64 }

    pub fn repeated_sfixed32(&self) -> &[i32] { &self.repeated_sfixed32 }

    pub fn clear_repeated_sfixed32(&mut self) { self.repeated_sfixed32.clear(); }

    pub fn set_repeated_sfixed32(&mut self, v: impl Into<Vec<i32>>) { self.repeated_sfixed32 = v.into(); }

    pub fn repeated_sfixed32_mut(&mut self) -> &mut Vec<i32> { &mut self.repeated_sfixed32 }

    pub fn repeated_sfixed64(&self) -> &[i64] { &self.repeated_sfixed64 }

    pub fn clear_repeated_sfixed64(&mut self) { self.repeated_sfixed64.clear(); }

    pub fn set_repeated_sfixed64(&mut self, v: impl Into<Vec<i64>>) { self.repeated_sfixed64 = v.into(); }

    pub fn repeated_sfixed64_mut(&mut self) -> &mut Vec<i64> { &mut self.repeated_sfixed64 }

    pub fn repeated_float(&self) -> &[f32] { &self.repeated_float }

    pub fn clear_repeated_float(&mut self) { self.repeated_float.clear(); }

    pub fn set_repeated_float(&mut self, v: impl Into<Vec<f32>>) { self.repeated_float = v.into(); }

    pub fn repeated_float_mut(&mut self) -> &mut Vec<f32> { &mut self.repeated_float }

    pub fn repeated_double(&self) -> &[f64] { &self.repeated_double }

    pub fn clear_repeated_double(&mut self) { self.repeated_double.clear(); }

    pub fn set_repeated_double(&mut self, v: impl Into<Vec<f64>>) { self.repeated_double = v.into(); }

    pub fn repeated_double_mut(&mut self) -> &mut Vec<f64> { &mut self.repeated_double }

    pub fn repeated_bool(&self) -> &[bool] { &self.repeated_bool }

    pub fn clear_repeated_bool(&mut self) { self.repeated_bool.clear(); }

    pub fn set_repeated_bool(&mut self, v: impl Into<Vec<bool>>) { self.repeated_bool = v.into(); }

    pub fn repeated_bool_mut(&mut self) -> &mut Vec<bool> { &mut self.repeated_bool }

    pub fn repeated_string(&self) -> &[String] { &self.repeated_string }

    pub fn clear_repeated_string(&mut self) { self.repeated_string.clear(); }

    pub fn set_repeated_string(&mut self, v: impl Into<Vec<String>>) { self.repeated_string = v.into(); }

    pub fn repeated_string_mut(&mut self) -> &mut Vec<String> { &mut self.repeated_string }

    pub fn repeated_bytes(&self) -> &[Vec<u8>] { &self.repeated_bytes }

    pub fn clear_repeated_bytes(&mut self) { self.repeated_bytes.clear(); }

    pub fn set_repeated_bytes(&mut self, v: impl Into<Vec<Vec<u8>>>) { self.repeated_bytes = v.into(); }

    pub fn repeated_bytes_mut(&mut self) -> &mut Vec<Vec<u8>> { &mut self.repeated_bytes }

    pub fn repeated_nested_message(&self) -> &[TestAllTypesProto3NestedNestedMessage] { &self.repeated_nested_message }

    pub fn clear_repeated_nested_message(&mut self) { self.repeated_nested_message.clear(); }

    pub fn set_repeated_nested_message(&mut self, v: impl Into<Vec<TestAllTypesProto3NestedNestedMessage>>) { self.repeated_nested_message = v.into(); }

    pub fn repeated_nested_message_mut(&mut self) -> &mut Vec<TestAllTypesProto3NestedNestedMessage> { &mut self.repeated_nested_message }

    pub fn repeated_foreign_message(&self) -> &[ForeignMessage] { &self.repeated_foreign_message }

    pub fn clear_repeated_foreign_message(&mut self) { self.repeated_foreign_message.clear(); }

    pub fn set_repeated_foreign_message(&mut self, v: impl Into<Vec<ForeignMessage>>) { self.repeated_foreign_message = v.into(); }

    pub fn repeated_foreign_message_mut(&mut self) -> &mut Vec<ForeignMessage> { &mut self.repeated_foreign_message }

    pub fn repeated_nested_enum(&self) -> &[TestAllTypesProto3NestedNestedEnum] { &self.repeated_nested_enum }

    pub fn clear_repeated_nested_enum(&mut self) { self.repeated_nested_enum.clear(); }

    pub fn set_repeated_nested_enum(&mut self, v: impl Into<Vec<TestAllTypesProto3NestedNestedEnum>>) { self.repeated_nested_enum = v.into(); }

    pub fn repeated_nested_enum_mut(&mut self) -> &mut Vec<TestAllTypesProto3NestedNestedEnum> { &mut self.repeated_nested_enum }

    pub fn repeated_foreign_enum(&self) -> &[ForeignEnum] { &self.repeated_foreign_enum }

    pub fn clear_repeated_foreign_enum(&mut self) { self.repeated_foreign_enum.clear(); }

    pub fn set_repeated_foreign_enum(&mut self, v: impl Into<Vec<ForeignEnum>>) { self.repeated_foreign_enum = v.into(); }

    pub fn repeated_foreign_enum_mut(&mut self) -> &mut Vec<ForeignEnum> { &mut self.repeated_foreign_enum }

    pub fn repeated_string_piece(&self) -> &[String] { &self.repeated_string_piece }

    pub fn clear_repeated_string_piece(&mut self) { self.repeated_string_piece.clear(); }

    pub fn set_repeated_string_piece(&mut self, v: impl Into<Vec<String>>) { self.repeated_string_piece = v.into(); }

    pub fn repeated_string_piece_mut(&mut self) -> &mut Vec<String> { &mut self.repeated_string_piece }

    pub fn repeated_cord(&self) -> &[String] { &self.repeated_cord }

    pub fn clear_repeated_cord(&mut self) { self.repeated_cord.clear(); }

    pub fn set_repeated_cord(&mut self, v: impl Into<Vec<String>>) { self.repeated_cord = v.into(); }

    pub fn repeated_cord_mut(&mut self) -> &mut Vec<String> { &mut self.repeated_cord }

    pub fn packed_int32(&self) -> &[i32] { &self.packed_int32 }

    pub fn clear_packed_int32(&mut self) { self.packed_int32.clear(); }

    pub fn set_packed_int32(&mut self, v: impl Into<Vec<i32>>) { self.packed_int32 = v.into(); }

    pub fn packed_int32_mut(&mut self) -> &mut Vec<i32> { &mut self.packed_int32 }

    pub fn packed_int64(&self) -> &[i64] { &self.packed_int64 }

    pub fn clear_packed_int64(&mut self) { self.packed_int64.clear(); }

    pub fn set_packed_int64(&mut self, v: impl Into<Vec<i64>>) { self.packed_int64 = v.into(); }

    pub fn packed_int64_mut(&mut self) -> &mut Vec<i64> { &mut self.packed_int64 }

    pub fn packed_uint32(&self) -> &[u32] { &self.packed_uint32 }

    pub fn clear_packed_uint32(&mut self) { self.packed_uint32.clear(); }

    pub fn set_packed_uint32(&mut self, v: impl Into<Vec<u32>>) { self.packed_uint32 = v.into(); }

    pub fn packed_uint32_mut(&mut self) -> &mut Vec<u32> { &mut self.packed_uint32 }

    pub fn packed_uint64(&self) -> &[u64] { &self.packed_uint64 }

    pub fn clear_packed_uint64(&mut self) { self.packed_uint64.clear(); }

    pub fn set_packed_uint64(&mut self, v: impl Into<Vec<u64>>) { self.packed_uint64 = v.into(); }

    pub fn packed_uint64_mut(&mut self) -> &mut Vec<u64> { &mut self.packed_uint64 }

    pub fn packed_sint32(&self) -> &[i32] { &self.packed_sint32 }

    pub fn clear_packed_sint32(&mut self) { self.packed_sint32.clear(); }

    pub fn set_packed_sint32(&mut self, v: impl Into<Vec<i32>>) { self.packed_sint32 = v.into(); }

    pub fn packed_sint32_mut(&mut self) -> &mut Vec<i32> { &mut self.packed_sint32 }

    pub fn packed_sint64(&self) -> &[i64] { &self.packed_sint64 }

    pub fn clear_packed_sint64(&mut self) { self.packed_sint64.clear(); }

    pub fn set_packed_sint64(&mut self, v: impl Into<Vec<i64>>) { self.packed_sint64 = v.into(); }

    pub fn packed_sint64_mut(&mut self) -> &mut Vec<i64> { &mut self.packed_sint64 }

    pub fn packed_fixed32(&self) -> &[u32] { &self.packed_fixed32 }

    pub fn clear_packed_fixed32(&mut self) { self.packed_fixed32.clear(); }

    pub fn set_packed_fixed32(&mut self, v: impl Into<Vec<u32>>) { self.packed_fixed32 = v.into(); }

    pub fn packed_fixed32_mut(&mut self) -> &mut Vec<u32> { &mut self.packed_fixed32 }

    pub fn packed_fixed64(&self) -> &[u64] { &self.packed_fixed64 }

    pub fn clear_packed_fixed64(&mut self) { self.packed_fixed64.clear(); }

    pub fn set_packed_fixed64(&mut self, v: impl Into<Vec<u64>>) { self.packed_fixed64 = v.into(); }

    pub fn packed_fixed64_mut(&mut self) -> &mut Vec<u64> { &mut self.packed_fixed64 }

    pub fn packed_sfixed32(&self) -> &[i32] { &self.packed_sfixed32 }

    pub fn clear_packed_sfixed32(&mut self) { self.packed_sfixed32.clear(); }

    pub fn set_packed_sfixed32(&mut self, v: impl Into<Vec<i32>>) { self.packed_sfixed32 = v.into(); }

    pub fn packed_sfixed32_mut(&mut self) -> &mut Vec<i32> { &mut self.packed_sfixed32 }

    pub fn packed_sfixed64(&self) -> &[i64] { &self.packed_sfixed64 }

    pub fn clear_packed_sfixed64(&mut self) { self.packed_sfixed64.clear(); }

    pub fn set_packed_sfixed64(&mut self, v: impl Into<Vec<i64>>) { self.packed_sfixed64 = v.into(); }

    pub fn packed_sfixed64_mut(&mut self) -> &mut Vec<i64> { &mut self.packed_sfixed64 }

    pub fn packed_float(&self) -> &[f32] { &self.packed_float }

    pub fn clear_packed_float(&mut self) { self.packed_float.clear(); }

    pub fn set_packed_float(&mut self, v: impl Into<Vec<f32>>) { self.packed_float = v.into(); }

    pub fn packed_float_mut(&mut self) -> &mut Vec<f32> { &mut self.packed_float }

    pub fn packed_double(&self) -> &[f64] { &self.packed_double }

    pub fn clear_packed_double(&mut self) { self.packed_double.clear(); }

    pub fn set_packed_double(&mut self, v: impl Into<Vec<f64>>) { self.packed_double = v.into(); }

    pub fn packed_double_mut(&mut self) -> &mut Vec<f64> { &mut self.packed_double }

    pub fn packed_bool(&self) -> &[bool] { &self.packed_bool }

    pub fn clear_packed_bool(&mut self) { self.packed_bool.clear(); }

    pub fn set_packed_bool(&mut self, v: impl Into<Vec<bool>>) { self.packed_bool = v.into(); }

    pub fn packed_bool_mut(&mut self) -> &mut Vec<bool> { &mut self.packed_bool }

    pub fn packed_nested_enum(&self) -> &[TestAllTypesProto3NestedNestedEnum] { &self.packed_nested_enum }

    pub fn clear_packed_nested_enum(&mut self) { self.packed_nested_enum.clear(); }

    pub fn set_packed_nested_enum(&mut self, v: impl Into<Vec<TestAllTypesProto3NestedNestedEnum>>) { self.packed_nested_enum = v.into(); }

    pub fn packed_nested_enum_mut(&mut self) -> &mut Vec<TestAllTypesProto3NestedNestedEnum> { &mut self.packed_nested_enum }

    pub fn unpacked_int32(&self) -> &[i32] { &self.unpacked_int32 }

    pub fn clear_unpacked_int32(&mut self) { self.unpacked_int32.clear(); }

    pub fn set_unpacked_int32(&mut self, v: impl Into<Vec<i32>>) { self.unpacked_int32 = v.into(); }

    pub fn unpacked_int32_mut(&mut self) -> &mut Vec<i32> { &mut self.unpacked_int32 }

    pub fn unpacked_int64(&self) -> &[i64] { &self.unpacked_int64 }

    pub fn clear_unpacked_int64(&mut self) { self.unpacked_int64.clear(); }

    pub fn set_unpacked_int64(&mut self, v: impl Into<Vec<i64>>) { self.unpacked_int64 = v.into(); }

    pub fn unpacked_int64_mut(&mut self) -> &mut Vec<i64> { &mut self.unpacked_int64 }

    pub fn unpacked_uint32(&self) -> &[u32] { &self.unpacked_uint32 }

    pub fn clear_unpacked_uint32(&mut self) { self.unpacked_uint32.clear(); }

    pub fn set_unpacked_uint32(&mut self, v: impl Into<Vec<u32>>) { self.unpacked_uint32 = v.into(); }

    pub fn unpacked_uint32_mut(&mut self) -> &mut Vec<u32> { &mut self.unpacked_uint32 }

    pub fn unpacked_uint64(&self) -> &[u64] { &self.unpacked_uint64 }

    pub fn clear_unpacked_uint64(&mut self) { self.unpacked_uint64.clear(); }

    pub fn set_unpacked_uint64(&mut self, v: impl Into<Vec<u64>>) { self.unpacked_uint64 = v.into(); }

    pub fn unpacked_uint64_mut(&mut self) -> &mut Vec<u64> { &mut self.unpacked_uint64 }

    pub fn unpacked_sint32(&self) -> &[i32] { &self.unpacked_sint32 }

    pub fn clear_unpacked_sint32(&mut self) { self.unpacked_sint32.clear(); }

    pub fn set_unpacked_sint32(&mut self, v: impl Into<Vec<i32>>) { self.unpacked_sint32 = v.into(); }

    pub fn unpacked_sint32_mut(&mut self) -> &mut Vec<i32> { &mut self.unpacked_sint32 }

    pub fn unpacked_sint64(&self) -> &[i64] { &self.unpacked_sint64 }

    pub fn clear_unpacked_sint64(&mut self) { self.unpacked_sint64.clear(); }

    pub fn set_unpacked_sint64(&mut self, v: impl Into<Vec<i64>>) { self.unpacked_sint64 = v.into(); }

    pub fn unpacked_sint64_mut(&mut self) -> &mut Vec<i64> { &mut self.unpacked_sint64 }

    pub fn unpacked_fixed32(&self) -> &[u32] { &self.unpacked_fixed32 }

    pub fn clear_unpacked_fixed32(&mut self) { self.unpacked_fixed32.clear(); }

    pub fn set_unpacked_fixed32(&mut self, v: impl Into<Vec<u32>>) { self.unpacked_fixed32 = v.into(); }

    pub fn unpacked_fixed32_mut(&mut self) -> &mut Vec<u32> { &mut self.unpacked_fixed32 }

    pub fn unpacked_fixed64(&self) -> &[u64] { &self.unpacked_fixed64 }

    pub fn clear_unpacked_fixed64(&mut self) { self.unpacked_fixed64.clear(); }

    pub fn set_unpacked_fixed64(&mut self, v: impl Into<Vec<u64>>) { self.unpacked_fixed64 = v.into(); }

    pub fn unpacked_fixed64_mut(&mut self) -> &mut Vec<u64> { &mut self.unpacked_fixed64 }

    pub fn unpacked_sfixed32(&self) -> &[i32] { &self.unpacked_sfixed32 }

    pub fn clear_unpacked_sfixed32(&mut self) { self.unpacked_sfixed32.clear(); }

    pub fn set_unpacked_sfixed32(&mut self, v: impl Into<Vec<i32>>) { self.unpacked_sfixed32 = v.into(); }

    pub fn unpacked_sfixed32_mut(&mut self) -> &mut Vec<i32> { &mut self.unpacked_sfixed32 }

    pub fn unpacked_sfixed64(&self) -> &[i64] { &self.unpacked_sfixed64 }

    pub fn clear_unpacked_sfixed64(&mut self) { self.unpacked_sfixed64.clear(); }

    pub fn set_unpacked_sfixed64(&mut self, v: impl Into<Vec<i64>>) { self.unpacked_sfixed64 = v.into(); }

    pub fn unpacked_sfixed64_mut(&mut self) -> &mut Vec<i64> { &mut self.unpacked_sfixed64 }

    pub fn unpacked_float(&self) -> &[f32] { &self.unpacked_float }

    pub fn clear_unpacked_float(&mut self) { self.unpacked_float.clear(); }

    pub fn set_unpacked_float(&mut self, v: impl Into<Vec<f32>>) { self.unpacked_float = v.into(); }

    pub fn unpacked_float_mut(&mut self) -> &mut Vec<f32> { &mut self.unpacked_float }

    pub fn unpacked_double(&self) -> &[f64] { &self.unpacked_double }

    pub fn clear_unpacked_double(&mut self) { self.unpacked_double.clear(); }

    pub fn set_unpacked_double(&mut self, v: impl Into<Vec<f64>>) { self.unpacked_double = v.into(); }

    pub fn unpacked_double_mut(&mut self) -> &mut Vec<f64> { &mut self.unpacked_double }

    pub fn unpacked_bool(&self) -> &[bool] { &self.unpacked_bool }

    pub fn clear_unpacked_bool(&mut self) { self.unpacked_bool.clear(); }

    pub fn set_unpacked_bool(&mut self, v: impl Into<Vec<bool>>) { self.unpacked_bool = v.into(); }

    pub fn unpacked_bool_mut(&mut self) -> &mut Vec<bool> { &mut self.unpacked_bool }

    pub fn unpacked_nested_enum(&self) -> &[TestAllTypesProto3NestedNestedEnum] { &self.unpacked_nested_enum }

    pub fn clear_unpacked_nested_enum(&mut self) { self.unpacked_nested_enum.clear(); }

    pub fn set_unpacked_nested_enum(&mut self, v: impl Into<Vec<TestAllTypesProto3NestedNestedEnum>>) { self.unpacked_nested_enum = v.into(); }

    pub fn unpacked_nested_enum_mut(&mut self) -> &mut Vec<TestAllTypesProto3NestedNestedEnum> { &mut self.unpacked_nested_enum }

    pub fn map_int32_int32(&self) -> &Option<HashMap<i32, i32>> { &self.map_int32_int32 }

    pub fn clear_map_int32_int32(&mut self) { self.map_int32_int32 = None; }

    pub fn set_map_int32_int32(&mut self, v: impl Into<Option<HashMap<i32, i32>>>) { self.map_int32_int32 = v.into(); }

    pub fn map_int32_int32_mut(&mut self) -> &mut Option<HashMap<i32, i32>> { &mut self.map_int32_int32 }

    pub fn map_int64_int64(&self) -> &Option<HashMap<i64, i64>> { &self.map_int64_int64 }

    pub fn clear_map_int64_int64(&mut self) { self.map_int64_int64 = None; }

    pub fn set_map_int64_int64(&mut self, v: impl Into<Option<HashMap<i64, i64>>>) { self.map_int64_int64 = v.into(); }

    pub fn map_int64_int64_mut(&mut self) -> &mut Option<HashMap<i64, i64>> { &mut self.map_int64_int64 }

    pub fn map_uint32_uint32(&self) -> &Option<HashMap<u32, u32>> { &self.map_uint32_uint32 }

    pub fn clear_map_uint32_uint32(&mut self) { self.map_uint32_uint32 = None; }

    pub fn set_map_uint32_uint32(&mut self, v: impl Into<Option<HashMap<u32, u32>>>) { self.map_uint32_uint32 = v.into(); }

    pub fn map_uint32_uint32_mut(&mut self) -> &mut Option<HashMap<u32, u32>> { &mut self.map_uint32_uint32 }

    pub fn map_uint64_uint64(&self) -> &Option<HashMap<u64, u64>> { &self.map_uint64_uint64 }

    pub fn clear_map_uint64_uint64(&mut self) { self.map_uint64_uint64 = None; }

    pub fn set_map_uint64_uint64(&mut self, v: impl Into<Option<HashMap<u64, u64>>>) { self.map_uint64_uint64 = v.into(); }

    pub fn map_uint64_uint64_mut(&mut self) -> &mut Option<HashMap<u64, u64>> { &mut self.map_uint64_uint64 }

    pub fn map_sint32_sint32(&self) -> &Option<HashMap<i32, i32>> { &self.map_sint32_sint32 }

    pub fn clear_map_sint32_sint32(&mut self) { self.map_sint32_sint32 = None; }

    pub fn set_map_sint32_sint32(&mut self, v: impl Into<Option<HashMap<i32, i32>>>) { self.map_sint32_sint32 = v.into(); }

    pub fn map_sint32_sint32_mut(&mut self) -> &mut Option<HashMap<i32, i32>> { &mut self.map_sint32_sint32 }

    pub fn map_sint64_sint64(&self) -> &Option<HashMap<i64, i64>> { &self.map_sint64_sint64 }

    pub fn clear_map_sint64_sint64(&mut self) { self.map_sint64_sint64 = None; }

    pub fn set_map_sint64_sint64(&mut self, v: impl Into<Option<HashMap<i64, i64>>>) { self.map_sint64_sint64 = v.into(); }

    pub fn map_sint64_sint64_mut(&mut self) -> &mut Option<HashMap<i64, i64>> { &mut self.map_sint64_sint64 }

    pub fn map_fixed32_fixed32(&self) -> &Option<HashMap<u32, u32>> { &self.map_fixed32_fixed32 }

    pub fn clear_map_fixed32_fixed32(&mut self) { self.map_fixed32_fixed32 = None; }

    pub fn set_map_fixed32_fixed32(&mut self, v: impl Into<Option<HashMap<u32, u32>>>) { self.map_fixed32_fixed32 = v.into(); }

    pub fn map_fixed32_fixed32_mut(&mut self) -> &mut Option<HashMap<u32, u32>> { &mut self.map_fixed32_fixed32 }

    pub fn map_fixed64_fixed64(&self) -> &Option<HashMap<u64, u64>> { &self.map_fixed64_fixed64 }

    pub fn clear_map_fixed64_fixed64(&mut self) { self.map_fixed64_fixed64 = None; }

    pub fn set_map_fixed64_fixed64(&mut self, v: impl Into<Option<HashMap<u64, u64>>>) { self.map_fixed64_fixed64 = v.into(); }

    pub fn map_fixed64_fixed64_mut(&mut self) -> &mut Option<HashMap<u64, u64>> { &mut self.map_fixed64_fixed64 }

    pub fn map_sfixed32_sfixed32(&self) -> &Option<HashMap<i32, i32>> { &self.map_sfixed32_sfixed32 }

    pub fn clear_map_sfixed32_sfixed32(&mut self) { self.map_sfixed32_sfixed32 = None; }

    pub fn set_map_sfixed32_sfixed32(&mut self, v: impl Into<Option<HashMap<i32, i32>>>) { self.map_sfixed32_sfixed32 = v.into(); }

    pub fn map_sfixed32_sfixed32_mut(&mut self) -> &mut Option<HashMap<i32, i32>> { &mut self.map_sfixed32_sfixed32 }

    pub fn map_sfixed64_sfixed64(&self) -> &Option<HashMap<i64, i64>> { &self.map_sfixed64_sfixed64 }

    pub fn clear_map_sfixed64_sfixed64(&mut self) { self.map_sfixed64_sfixed64 = None; }

    pub fn set_map_sfixed64_sfixed64(&mut self, v: impl Into<Option<HashMap<i64, i64>>>) { self.map_sfixed64_sfixed64 = v.into(); }

    pub fn map_sfixed64_sfixed64_mut(&mut self) -> &mut Option<HashMap<i64, i64>> { &mut self.map_sfixed64_sfixed64 }

    pub fn map_int32_float(&self) -> &Option<HashMap<i32, f32>> { &self.map_int32_float }

    pub fn clear_map_int32_float(&mut self) { self.map_int32_float = None; }

    pub fn set_map_int32_float(&mut self, v: impl Into<Option<HashMap<i32, f32>>>) { self.map_int32_float = v.into(); }

    pub fn map_int32_float_mut(&mut self) -> &mut Option<HashMap<i32, f32>> { &mut self.map_int32_float }

    pub fn map_int32_double(&self) -> &Option<HashMap<i32, f64>> { &self.map_int32_double }

    pub fn clear_map_int32_double(&mut self) { self.map_int32_double = None; }

    pub fn set_map_int32_double(&mut self, v: impl Into<Option<HashMap<i32, f64>>>) { self.map_int32_double = v.into(); }

    pub fn map_int32_double_mut(&mut self) -> &mut Option<HashMap<i32, f64>> { &mut self.map_int32_double }

    pub fn map_bool_bool(&self) -> &Option<HashMap<bool, bool>> { &self.map_bool_bool }

    pub fn clear_map_bool_bool(&mut self) { self.map_bool_bool = None; }

    pub fn set_map_bool_bool(&mut self, v: impl Into<Option<HashMap<bool, bool>>>) { self.map_bool_bool = v.into(); }

    pub fn map_bool_bool_mut(&mut self) -> &mut Option<HashMap<bool, bool>> { &mut self.map_bool_bool }

    pub fn map_string_string(&self) -> &Option<HashMap<String, String>> { &self.map_string_string }

    pub fn clear_map_string_string(&mut self) { self.map_string_string = None; }

    pub fn set_map_string_string(&mut self, v: impl Into<Option<HashMap<String, String>>>) { self.map_string_string = v.into(); }

    pub fn map_string_string_mut(&mut self) -> &mut Option<HashMap<String, String>> { &mut self.map_string_string }

    pub fn map_string_bytes(&self) -> &Option<HashMap<String, Vec<u8>>> { &self.map_string_bytes }

    pub fn clear_map_string_bytes(&mut self) { self.map_string_bytes = None; }

    pub fn set_map_string_bytes(&mut self, v: impl Into<Option<HashMap<String, Vec<u8>>>>) { self.map_string_bytes = v.into(); }

    pub fn map_string_bytes_mut(&mut self) -> &mut Option<HashMap<String, Vec<u8>>> { &mut self.map_string_bytes }

    pub fn map_string_nested_message(&self) -> &Option<HashMap<String, TestAllTypesProto3NestedNestedMessage>> { &self.map_string_nested_message }

    pub fn clear_map_string_nested_message(&mut self) { self.map_string_nested_message = None; }

    pub fn set_map_string_nested_message(&mut self, v: impl Into<Option<HashMap<String, TestAllTypesProto3NestedNestedMessage>>>) { self.map_string_nested_message = v.into(); }

    pub fn map_string_nested_message_mut(&mut self) -> &mut Option<HashMap<String, TestAllTypesProto3NestedNestedMessage>> { &mut self.map_string_nested_message }

    pub fn map_string_foreign_message(&self) -> &Option<HashMap<String, ForeignMessage>> { &self.map_string_foreign_message }

    pub fn clear_map_string_foreign_message(&mut self) { self.map_string_foreign_message = None; }

    pub fn set_map_string_foreign_message(&mut self, v: impl Into<Option<HashMap<String, ForeignMessage>>>) { self.map_string_foreign_message = v.into(); }

    pub fn map_string_foreign_message_mut(&mut self) -> &mut Option<HashMap<String, ForeignMessage>> { &mut self.map_string_foreign_message }

    pub fn map_string_nested_enum(&self) -> &Option<HashMap<String, TestAllTypesProto3NestedNestedEnum>> { &self.map_string_nested_enum }

    pub fn clear_map_string_nested_enum(&mut self) { self.map_string_nested_enum = None; }

    pub fn set_map_string_nested_enum(&mut self, v: impl Into<Option<HashMap<String, TestAllTypesProto3NestedNestedEnum>>>) { self.map_string_nested_enum = v.into(); }

    pub fn map_string_nested_enum_mut(&mut self) -> &mut Option<HashMap<String, TestAllTypesProto3NestedNestedEnum>> { &mut self.map_string_nested_enum }

    pub fn map_string_foreign_enum(&self) -> &Option<HashMap<String, ForeignEnum>> { &self.map_string_foreign_enum }

    pub fn clear_map_string_foreign_enum(&mut self) { self.map_string_foreign_enum = None; }

    pub fn set_map_string_foreign_enum(&mut self, v: impl Into<Option<HashMap<String, ForeignEnum>>>) { self.map_string_foreign_enum = v.into(); }

    pub fn map_string_foreign_enum_mut(&mut self) -> &mut Option<HashMap<String, ForeignEnum>> { &mut self.map_string_foreign_enum }

    pub fn optional_bool_wrapper(&self) -> &google__protobuf__wrappers_pb::BoolValue {
        self.optional_bool_wrapper.as_ref().unwrap_or_else(|| google__protobuf__wrappers_pb::BoolValue::default_instance())
    }

    pub fn clear_optional_bool_wrapper(&mut self) { self.optional_bool_wrapper = None; }

    pub fn has_optional_bool_wrapper(&self) -> bool { self.optional_bool_wrapper.is_some() }

    pub fn set_optional_bool_wrapper(&mut self, v: google__protobuf__wrappers_pb::BoolValue) { self.optional_bool_wrapper = Some(v); }

    pub fn optional_bool_wrapper_mut(&mut self) -> &mut google__protobuf__wrappers_pb::BoolValue {
        self.optional_bool_wrapper.get_or_insert_with(Default::default)
    }

    pub fn optional_int32_wrapper(&self) -> &google__protobuf__wrappers_pb::Int32Value {
        self.optional_int32_wrapper.as_ref().unwrap_or_else(|| google__protobuf__wrappers_pb::Int32Value::default_instance())
    }

    pub fn clear_optional_int32_wrapper(&mut self) { self.optional_int32_wrapper = None; }

    pub fn has_optional_int32_wrapper(&self) -> bool { self.optional_int32_wrapper.is_some() }

    pub fn set_optional_int32_wrapper(&mut self, v: google__protobuf__wrappers_pb::Int32Value) { self.optional_int32_wrapper = Some(v); }

    pub fn optional_int32_wrapper_mut(&mut self) -> &mut google__protobuf__wrappers_pb::Int32Value {
        self.optional_int32_wrapper.get_or_insert_with(Default::default)
    }

    pub fn optional_int64_wrapper(&self) -> &google__protobuf__wrappers_pb::Int64Value {
        self.optional_int64_wrapper.as_ref().unwrap_or_else(|| google__protobuf__wrappers_pb::Int64Value::default_instance())
    }

    pub fn clear_optional_int64_wrapper(&mut self) { self.optional_int64_wrapper = None; }

    pub fn has_optional_int64_wrapper(&self) -> bool { self.optional_int64_wrapper.is_some() }

    pub fn set_optional_int64_wrapper(&mut self, v: google__protobuf__wrappers_pb::Int64Value) { self.optional_int64_wrapper = Some(v); }

    pub fn optional_int64_wrapper_mut(&mut self) -> &mut google__protobuf__wrappers_pb::Int64Value {
        self.optional_int64_wrapper.get_or_insert_with(Default::default)
    }

    pub fn optional_uint32_wrapper(&self) -> &google__protobuf__wrappers_pb::UInt32Value {
        self.optional_uint32_wrapper.as_ref().unwrap_or_else(|| google__protobuf__wrappers_pb::UInt32Value::default_instance())
    }

    pub fn clear_optional_uint32_wrapper(&mut self) { self.optional_uint32_wrapper = None; }

    pub fn has_optional_uint32_wrapper(&self) -> bool { self.optional_uint32_wrapper.is_some() }

    pub fn set_optional_uint32_wrapper(&mut self, v: google__protobuf__wrappers_pb::UInt32Value) { self.optional_uint32_wrapper = Some(v); }

    pub fn optional_uint32_wrapper_mut(&mut self) -> &mut google__protobuf__wrappers_pb::UInt32Value {
        self.optional_uint32_wrapper.get_or_insert_with(Default::default)
    }

    pub fn optional_uint64_wrapper(&self) -> &google__protobuf__wrappers_pb::UInt64Value {
        self.optional_uint64_wrapper.as_ref().unwrap_or_else(|| google__protobuf__wrappers_pb::UInt64Value::default_instance())
    }

    pub fn clear_optional_uint64_wrapper(&mut self) { self.optional_uint64_wrapper = None; }

    pub fn has_optional_uint64_wrapper(&self) -> bool { self.optional_uint64_wrapper.is_some() }

    pub fn set_optional_uint64_wrapper(&mut self, v: google__protobuf__wrappers_pb::UInt64Value) { self.optional_uint64_wrapper = Some(v); }

    pub fn optional_uint64_wrapper_mut(&mut self) -> &mut google__protobuf__wrappers_pb::UInt64Value {
        self.optional_uint64_wrapper.get_or_insert_with(Default::default)
    }

    pub fn optional_float_wrapper(&self) -> &google__protobuf__wrappers_pb::FloatValue {
        self.optional_float_wrapper.as_ref().unwrap_or_else(|| google__protobuf__wrappers_pb::FloatValue::default_instance())
    }

    pub fn clear_optional_float_wrapper(&mut self) { self.optional_float_wrapper = None; }

    pub fn has_optional_float_wrapper(&self) -> bool { self.optional_float_wrapper.is_some() }

    pub fn set_optional_float_wrapper(&mut self, v: google__protobuf__wrappers_pb::FloatValue) { self.optional_float_wrapper = Some(v); }

    pub fn optional_float_wrapper_mut(&mut self) -> &mut google__protobuf__wrappers_pb::FloatValue {
        self.optional_float_wrapper.get_or_insert_with(Default::default)
    }

    pub fn optional_double_wrapper(&self) -> &google__protobuf__wrappers_pb::DoubleValue {
        self.optional_double_wrapper.as_ref().unwrap_or_else(|| google__protobuf__wrappers_pb::DoubleValue::default_instance())
    }

    pub fn clear_optional_double_wrapper(&mut self) { self.optional_double_wrapper = None; }

    pub fn has_optional_double_wrapper(&self) -> bool { self.optional_double_wrapper.is_some() }

    pub fn set_optional_double_wrapper(&mut self, v: google__protobuf__wrappers_pb::DoubleValue) { self.optional_double_wrapper = Some(v); }

    pub fn optional_double_wrapper_mut(&mut self) -> &mut google__protobuf__wrappers_pb::DoubleValue {
        self.optional_double_wrapper.get_or_insert_with(Default::default)
    }

    pub fn optional_string_wrapper(&self) -> &google__protobuf__wrappers_pb::StringValue {
        self.optional_string_wrapper.as_ref().unwrap_or_else(|| google__protobuf__wrappers_pb::StringValue::default_instance())
    }

    pub fn clear_optional_string_wrapper(&mut self) { self.optional_string_wrapper = None; }

    pub fn has_optional_string_wrapper(&self) -> bool { self.optional_string_wrapper.is_some() }

    pub fn set_optional_string_wrapper(&mut self, v: google__protobuf__wrappers_pb::StringValue) { self.optional_string_wrapper = Some(v); }

    pub fn optional_string_wrapper_mut(&mut self) -> &mut google__protobuf__wrappers_pb::StringValue {
        self.optional_string_wrapper.get_or_insert_with(Default::default)
    }

    pub fn optional_bytes_wrapper(&self) -> &google__protobuf__wrappers_pb::BytesValue {
        self.optional_bytes_wrapper.as_ref().unwrap_or_else(|| google__protobuf__wrappers_pb::BytesValue::default_instance())
    }

    pub fn clear_optional_bytes_wrapper(&mut self) { self.optional_bytes_wrapper = None; }

    pub fn has_optional_bytes_wrapper(&self) -> bool { self.optional_bytes_wrapper.is_some() }

    pub fn set_optional_bytes_wrapper(&mut self, v: google__protobuf__wrappers_pb::BytesValue) { self.optional_bytes_wrapper = Some(v); }

    pub fn optional_bytes_wrapper_mut(&mut self) -> &mut google__protobuf__wrappers_pb::BytesValue {
        self.optional_bytes_wrapper.get_or_insert_with(Default::default)
    }

    pub fn repeated_bool_wrapper(&self) -> &[google__protobuf__wrappers_pb::BoolValue] { &self.repeated_bool_wrapper }

    pub fn clear_repeated_bool_wrapper(&mut self) { self.repeated_bool_wrapper.clear(); }

    pub fn set_repeated_bool_wrapper(&mut self, v: impl Into<Vec<google__protobuf__wrappers_pb::BoolValue>>) { self.repeated_bool_wrapper = v.into(); }

    pub fn repeated_bool_wrapper_mut(&mut self) -> &mut Vec<google__protobuf__wrappers_pb::BoolValue> { &mut self.repeated_bool_wrapper }

    pub fn repeated_int32_wrapper(&self) -> &[google__protobuf__wrappers_pb::Int32Value] { &self.repeated_int32_wrapper }

    pub fn clear_repeated_int32_wrapper(&mut self) { self.repeated_int32_wrapper.clear(); }

    pub fn set_repeated_int32_wrapper(&mut self, v: impl Into<Vec<google__protobuf__wrappers_pb::Int32Value>>) { self.repeated_int32_wrapper = v.into(); }

    pub fn repeated_int32_wrapper_mut(&mut self) -> &mut Vec<google__protobuf__wrappers_pb::Int32Value> { &mut self.repeated_int32_wrapper }

    pub fn repeated_int64_wrapper(&self) -> &[google__protobuf__wrappers_pb::Int64Value] { &self.repeated_int64_wrapper }

    pub fn clear_repeated_int64_wrapper(&mut self) { self.repeated_int64_wrapper.clear(); }

    pub fn set_repeated_int64_wrapper(&mut self, v: impl Into<Vec<google__protobuf__wrappers_pb::Int64Value>>) { self.repeated_int64_wrapper = v.into(); }

    pub fn repeated_int64_wrapper_mut(&mut self) -> &mut Vec<google__protobuf__wrappers_pb::Int64Value> { &mut self.repeated_int64_wrapper }

    pub fn repeated_uint32_wrapper(&self) -> &[google__protobuf__wrappers_pb::UInt32Value] { &self.repeated_uint32_wrapper }

    pub fn clear_repeated_uint32_wrapper(&mut self) { self.repeated_uint32_wrapper.clear(); }

    pub fn set_repeated_uint32_wrapper(&mut self, v: impl Into<Vec<google__protobuf__wrappers_pb::UInt32Value>>) { self.repeated_uint32_wrapper = v.into(); }

    pub fn repeated_uint32_wrapper_mut(&mut self) -> &mut Vec<google__protobuf__wrappers_pb::UInt32Value> { &mut self.repeated_uint32_wrapper }

    pub fn repeated_uint64_wrapper(&self) -> &[google__protobuf__wrappers_pb::UInt64Value] { &self.repeated_uint64_wrapper }

    pub fn clear_repeated_uint64_wrapper(&mut self) { self.repeated_uint64_wrapper.clear(); }

    pub fn set_repeated_uint64_wrapper(&mut self, v: impl Into<Vec<google__protobuf__wrappers_pb::UInt64Value>>) { self.repeated_uint64_wrapper = v.into(); }

    pub fn repeated_uint64_wrapper_mut(&mut self) -> &mut Vec<google__protobuf__wrappers_pb::UInt64Value> { &mut self.repeated_uint64_wrapper }

    pub fn repeated_float_wrapper(&self) -> &[google__protobuf__wrappers_pb::FloatValue] { &self.repeated_float_wrapper }

    pub fn clear_repeated_float_wrapper(&mut self) { self.repeated_float_wrapper.clear(); }

    pub fn set_repeated_float_wrapper(&mut self, v: impl Into<Vec<google__protobuf__wrappers_pb::FloatValue>>) { self.repeated_float_wrapper = v.into(); }

    pub fn repeated_float_wrapper_mut(&mut self) -> &mut Vec<google__protobuf__wrappers_pb::FloatValue> { &mut self.repeated_float_wrapper }

    pub fn repeated_double_wrapper(&self) -> &[google__protobuf__wrappers_pb::DoubleValue] { &self.repeated_double_wrapper }

    pub fn clear_repeated_double_wrapper(&mut self) { self.repeated_double_wrapper.clear(); }

    pub fn set_repeated_double_wrapper(&mut self, v: impl Into<Vec<google__protobuf__wrappers_pb::DoubleValue>>) { self.repeated_double_wrapper = v.into(); }

    pub fn repeated_double_wrapper_mut(&mut self) -> &mut Vec<google__protobuf__wrappers_pb::DoubleValue> { &mut self.repeated_double_wrapper }

    pub fn repeated_string_wrapper(&self) -> &[google__protobuf__wrappers_pb::StringValue] { &self.repeated_string_wrapper }

    pub fn clear_repeated_string_wrapper(&mut self) { self.repeated_string_wrapper.clear(); }

    pub fn set_repeated_string_wrapper(&mut self, v: impl Into<Vec<google__protobuf__wrappers_pb::StringValue>>) { self.repeated_string_wrapper = v.into(); }

    pub fn repeated_string_wrapper_mut(&mut self) -> &mut Vec<google__protobuf__wrappers_pb::StringValue> { &mut self.repeated_string_wrapper }

    pub fn repeated_bytes_wrapper(&self) -> &[google__protobuf__wrappers_pb::BytesValue] { &self.repeated_bytes_wrapper }

    pub fn clear_repeated_bytes_wrapper(&mut self) { self.repeated_bytes_wrapper.clear(); }

    pub fn set_repeated_bytes_wrapper(&mut self, v: impl Into<Vec<google__protobuf__wrappers_pb::BytesValue>>) { self.repeated_bytes_wrapper = v.into(); }

    pub fn repeated_bytes_wrapper_mut(&mut self) -> &mut Vec<google__protobuf__wrappers_pb::BytesValue> { &mut self.repeated_bytes_wrapper }

    pub fn optional_duration(&self) -> &google__protobuf__duration_pb::Duration {
        self.optional_duration.as_ref().unwrap_or_else(|| google__protobuf__duration_pb::Duration::default_instance())
    }

    pub fn clear_optional_duration(&mut self) { self.optional_duration = None; }

    pub fn has_optional_duration(&self) -> bool { self.optional_duration.is_some() }

    pub fn set_optional_duration(&mut self, v: google__protobuf__duration_pb::Duration) { self.optional_duration = Some(v); }

    pub fn optional_duration_mut(&mut self) -> &mut google__protobuf__duration_pb::Duration {
        self.optional_duration.get_or_insert_with(Default::default)
    }

    pub fn optional_timestamp(&self) -> &google__protobuf__timestamp_pb::Timestamp {
        self.optional_timestamp.as_ref().unwrap_or_else(|| google__protobuf__timestamp_pb::Timestamp::default_instance())
    }

    pub fn clear_optional_timestamp(&mut self) { self.optional_timestamp = None; }

    pub fn has_optional_timestamp(&self) -> bool { self.optional_timestamp.is_some() }

    pub fn set_optional_timestamp(&mut self, v: google__protobuf__timestamp_pb::Timestamp) { self.optional_timestamp = Some(v); }

    pub fn optional_timestamp_mut(&mut self) -> &mut google__protobuf__timestamp_pb::Timestamp {
        self.optional_timestamp.get_or_insert_with(Default::default)
    }

    pub fn optional_field_mask(&self) -> &google__protobuf__field_mask_pb::FieldMask {
        self.optional_field_mask.as_ref().unwrap_or_else(|| google__protobuf__field_mask_pb::FieldMask::default_instance())
    }

    pub fn clear_optional_field_mask(&mut self) { self.optional_field_mask = None; }

    pub fn has_optional_field_mask(&self) -> bool { self.optional_field_mask.is_some() }

    pub fn set_optional_field_mask(&mut self, v: google__protobuf__field_mask_pb::FieldMask) { self.optional_field_mask = Some(v); }

    pub fn optional_field_mask_mut(&mut self) -> &mut google__protobuf__field_mask_pb::FieldMask {
        self.optional_field_mask.get_or_insert_with(Default::default)
    }

    pub fn optional_struct(&self) -> &google__protobuf__struct_pb::Struct {
        self.optional_struct.as_ref().unwrap_or_else(|| google__protobuf__struct_pb::Struct::default_instance())
    }

    pub fn clear_optional_struct(&mut self) { self.optional_struct = None; }

    pub fn has_optional_struct(&self) -> bool { self.optional_struct.is_some() }

    pub fn set_optional_struct(&mut self, v: google__protobuf__struct_pb::Struct) { self.optional_struct = Some(v); }

    pub fn optional_struct_mut(&mut self) -> &mut google__protobuf__struct_pb::Struct {
        self.optional_struct.get_or_insert_with(Default::default)
    }

    pub fn optional_any(&self) -> &google__protobuf__any_pb::Any {
        self.optional_any.as_ref().unwrap_or_else(|| google__protobuf__any_pb::Any::default_instance())
    }

    pub fn clear_optional_any(&mut self) { self.optional_any = None; }

    pub fn has_optional_any(&self) -> bool { self.optional_any.is_some() }

    pub fn set_optional_any(&mut self, v: google__protobuf__any_pb::Any) { self.optional_any = Some(v); }

    pub fn optional_any_mut(&mut self) -> &mut google__protobuf__any_pb::Any {
        self.optional_any.get_or_insert_with(Default::default)
    }

    pub fn optional_value(&self) -> &google__protobuf__struct_pb::Value {
        self.optional_value.as_ref().unwrap_or_else(|| google__protobuf__struct_pb::Value::default_instance())
    }

    pub fn clear_optional_value(&mut self) { self.optional_value = None; }

    pub fn has_optional_value(&self) -> bool { self.optional_value.is_some() }

    pub fn set_optional_value(&mut self, v: google__protobuf__struct_pb::Value) { self.optional_value = Some(v); }

    pub fn optional_value_mut(&mut self) -> &mut google__protobuf__struct_pb::Value {
        self.optional_value.get_or_insert_with(Default::default)
    }

    pub fn repeated_duration(&self) -> &[google__protobuf__duration_pb::Duration] { &self.repeated_duration }

    pub fn clear_repeated_duration(&mut self) { self.repeated_duration.clear(); }

    pub fn set_repeated_duration(&mut self, v: impl Into<Vec<google__protobuf__duration_pb::Duration>>) { self.repeated_duration = v.into(); }

    pub fn repeated_duration_mut(&mut self) -> &mut Vec<google__protobuf__duration_pb::Duration> { &mut self.repeated_duration }

    pub fn repeated_timestamp(&self) -> &[google__protobuf__timestamp_pb::Timestamp] { &self.repeated_timestamp }

    pub fn clear_repeated_timestamp(&mut self) { self.repeated_timestamp.clear(); }

    pub fn set_repeated_timestamp(&mut self, v: impl Into<Vec<google__protobuf__timestamp_pb::Timestamp>>) { self.repeated_timestamp = v.into(); }

    pub fn repeated_timestamp_mut(&mut self) -> &mut Vec<google__protobuf__timestamp_pb::Timestamp> { &mut self.repeated_timestamp }

    pub fn repeated_fieldmask(&self) -> &[google__protobuf__field_mask_pb::FieldMask] { &self.repeated_fieldmask }

    pub fn clear_repeated_fieldmask(&mut self) { self.repeated_fieldmask.clear(); }

    pub fn set_repeated_fieldmask(&mut self, v: impl Into<Vec<google__protobuf__field_mask_pb::FieldMask>>) { self.repeated_fieldmask = v.into(); }

    pub fn repeated_fieldmask_mut(&mut self) -> &mut Vec<google__protobuf__field_mask_pb::FieldMask> { &mut self.repeated_fieldmask }

    pub fn repeated_struct(&self) -> &[google__protobuf__struct_pb::Struct] { &self.repeated_struct }

    pub fn clear_repeated_struct(&mut self) { self.repeated_struct.clear(); }

    pub fn set_repeated_struct(&mut self, v: impl Into<Vec<google__protobuf__struct_pb::Struct>>) { self.repeated_struct = v.into(); }

    pub fn repeated_struct_mut(&mut self) -> &mut Vec<google__protobuf__struct_pb::Struct> { &mut self.repeated_struct }

    pub fn repeated_any(&self) -> &[google__protobuf__any_pb::Any] { &self.repeated_any }

    pub fn clear_repeated_any(&mut self) { self.repeated_any.clear(); }

    pub fn set_repeated_any(&mut self, v: impl Into<Vec<google__protobuf__any_pb::Any>>) { self.repeated_any = v.into(); }

    pub fn repeated_any_mut(&mut self) -> &mut Vec<google__protobuf__any_pb::Any> { &mut self.repeated_any }

    pub fn repeated_value(&self) -> &[google__protobuf__struct_pb::Value] { &self.repeated_value }

    pub fn clear_repeated_value(&mut self) { self.repeated_value.clear(); }

    pub fn set_repeated_value(&mut self, v: impl Into<Vec<google__protobuf__struct_pb::Value>>) { self.repeated_value = v.into(); }

    pub fn repeated_value_mut(&mut self) -> &mut Vec<google__protobuf__struct_pb::Value> { &mut self.repeated_value }

    pub fn repeated_list_value(&self) -> &[google__protobuf__struct_pb::ListValue] { &self.repeated_list_value }

    pub fn clear_repeated_list_value(&mut self) { self.repeated_list_value.clear(); }

    pub fn set_repeated_list_value(&mut self, v: impl Into<Vec<google__protobuf__struct_pb::ListValue>>) { self.repeated_list_value = v.into(); }

    pub fn repeated_list_value_mut(&mut self) -> &mut Vec<google__protobuf__struct_pb::ListValue> { &mut self.repeated_list_value }

    pub fn fieldname1(&self) -> i32 { self.fieldname1 }

    pub fn clear_fieldname1(&mut self) { self.fieldname1 = 0; }

    pub fn set_fieldname1(&mut self, v: i32) { self.fieldname1 = v; }

    pub fn field_name2(&self) -> i32 { self.field_name2 }

    pub fn clear_field_name2(&mut self) { self.field_name2 = 0; }

    pub fn set_field_name2(&mut self, v: i32) { self.field_name2 = v; }

    pub fn field_name3(&self) -> i32 { self.field_name3 }

    pub fn clear_field_name3(&mut self) { self.field_name3 = 0; }

    pub fn set_field_name3(&mut self, v: i32) { self.field_name3 = v; }

    pub fn field_name4_(&self) -> i32 { self.field_name4_ }

    pub fn clear_field_name4_(&mut self) { self.field_name4_ = 0; }

    pub fn set_field_name4_(&mut self, v: i32) { self.field_name4_ = v; }

    pub fn field0name5(&self) -> i32 { self.field0name5 }

    pub fn clear_field0name5(&mut self) { self.field0name5 = 0; }

    pub fn set_field0name5(&mut self, v: i32) { self.field0name5 = v; }

    pub fn field_0_name6(&self) -> i32 { self.field_0_name6 }

    pub fn clear_field_0_name6(&mut self) { self.field_0_name6 = 0; }

    pub fn set_field_0_name6(&mut self, v: i32) { self.field_0_name6 = v; }

    pub fn field_name7(&self) -> i32 { self.field_name7 }

    pub fn clear_field_name7(&mut self) { self.field_name7 = 0; }

    pub fn set_field_name7(&mut self, v: i32) { self.field_name7 = v; }

    pub fn field_name8(&self) -> i32 { self.field_name8 }

    pub fn clear_field_name8(&mut self) { self.field_name8 = 0; }

    pub fn set_field_name8(&mut self, v: i32) { self.field_name8 = v; }

    pub fn field_name9(&self) -> i32 { self.field_name9 }

    pub fn clear_field_name9(&mut self) { self.field_name9 = 0; }

    pub fn set_field_name9(&mut self, v: i32) { self.field_name9 = v; }

    pub fn field_name10(&self) -> i32 { self.field_name10 }

    pub fn clear_field_name10(&mut self) { self.field_name10 = 0; }

    pub fn set_field_name10(&mut self, v: i32) { self.field_name10 = v; }

    pub fn f_i_e_l_d_n_a_m_e11(&self) -> i32 { self.f_i_e_l_d_n_a_m_e11 }

    pub fn clear_f_i_e_l_d_n_a_m_e11(&mut self) { self.f_i_e_l_d_n_a_m_e11 = 0; }

    pub fn set_f_i_e_l_d_n_a_m_e11(&mut self, v: i32) { self.f_i_e_l_d_n_a_m_e11 = v; }

    pub fn f_i_e_l_d_name12(&self) -> i32 { self.f_i_e_l_d_name12 }

    pub fn clear_f_i_e_l_d_name12(&mut self) { self.f_i_e_l_d_name12 = 0; }

    pub fn set_f_i_e_l_d_name12(&mut self, v: i32) { self.f_i_e_l_d_name12 = v; }

    pub fn field_name13(&self) -> i32 { self.field_name13 }

    pub fn clear_field_name13(&mut self) { self.field_name13 = 0; }

    pub fn set_field_name13(&mut self, v: i32) { self.field_name13 = v; }

    pub fn field_name14(&self) -> i32 { self.field_name14 }

    pub fn clear_field_name14(&mut self) { self.field_name14 = 0; }

    pub fn set_field_name14(&mut self, v: i32) { self.field_name14 = v; }

    pub fn field_name15(&self) -> i32 { self.field_name15 }

    pub fn clear_field_name15(&mut self) { self.field_name15 = 0; }

    pub fn set_field_name15(&mut self, v: i32) { self.field_name15 = v; }

    pub fn field_name16(&self) -> i32 { self.field_name16 }

    pub fn clear_field_name16(&mut self) { self.field_name16 = 0; }

    pub fn set_field_name16(&mut self, v: i32) { self.field_name16 = v; }

    pub fn field_name17_(&self) -> i32 { self.field_name17_ }

    pub fn clear_field_name17_(&mut self) { self.field_name17_ = 0; }

    pub fn set_field_name17_(&mut self, v: i32) { self.field_name17_ = v; }

    pub fn field_name18_(&self) -> i32 { self.field_name18_ }

    pub fn clear_field_name18_(&mut self) { self.field_name18_ = 0; }

    pub fn set_field_name18_(&mut self, v: i32) { self.field_name18_ = v; }

    pub fn oneof_uint32(&self) -> u32 {
        match self.oneof_field {
            Some(TestAllTypesProto3NestedOneofField::OneofUint32(v)) => v,
            _ => Default::default(),
        }
    }

    pub fn clear_oneof_uint32(&mut self) {
        if let Some(TestAllTypesProto3NestedOneofField::OneofUint32(_)) = self.oneof_field {
            self.oneof_field = None;
        }
    }

    pub fn set_oneof_uint32(&mut self, v: u32) {
        self.oneof_field = Some(TestAllTypesProto3NestedOneofField::OneofUint32(v));
    }

    pub fn oneof_nested_message(&self) -> &TestAllTypesProto3NestedNestedMessage {
        match &self.oneof_field {
            Some(TestAllTypesProto3NestedOneofField::OneofNestedMessage(v)) => v,
            _ => TestAllTypesProto3NestedNestedMessage::default_instance(),
        }
    }

    pub fn clear_oneof_nested_message(&mut self) {
        if let Some(TestAllTypesProto3NestedOneofField::OneofNestedMessage(_)) = self.oneof_field {
            self.oneof_field = None;
        }
    }

    pub fn set_oneof_nested_message(&mut self, v: TestAllTypesProto3NestedNestedMessage) {
        self.oneof_field = Some(TestAllTypesProto3NestedOneofField::OneofNestedMessage(v));
    }

    pub fn oneof_nested_message_mut(&mut self) -> &mut TestAllTypesProto3NestedNestedMessage {
        if let Some(TestAllTypesProto3NestedOneofField::OneofNestedMessage(ref mut v)) = self.oneof_field {
            return v;
        }
        self.oneof_field = Some(TestAllTypesProto3NestedOneofField::OneofNestedMessage(Default::default()));
        if let Some(TestAllTypesProto3NestedOneofField::OneofNestedMessage(ref mut v)) = self.oneof_field {
            return v;
        }
        unreachable!()
    }

    pub fn oneof_string(&self) -> &str {
        match &self.oneof_field {
            Some(TestAllTypesProto3NestedOneofField::OneofString(v)) => v,
            _ => "",
        }
    }

    pub fn clear_oneof_string(&mut self) {
        if let Some(TestAllTypesProto3NestedOneofField::OneofString(_)) = self.oneof_field {
            self.oneof_field = None;
        }
    }

    pub fn set_oneof_string(&mut self, v: String) {
        self.oneof_field = Some(TestAllTypesProto3NestedOneofField::OneofString(v));
    }

    pub fn oneof_string_mut(&mut self) -> &mut String {
        if let Some(TestAllTypesProto3NestedOneofField::OneofString(ref mut v)) = self.oneof_field {
            return v;
        }
        self.oneof_field = Some(TestAllTypesProto3NestedOneofField::OneofString(Default::default()));
        if let Some(TestAllTypesProto3NestedOneofField::OneofString(ref mut v)) = self.oneof_field {
            return v;
        }
        unreachable!()
    }

    pub fn oneof_bytes(&self) -> &[u8] {
        match &self.oneof_field {
            Some(TestAllTypesProto3NestedOneofField::OneofBytes(v)) => v,
            _ => &[],
        }
    }

    pub fn clear_oneof_bytes(&mut self) {
        if let Some(TestAllTypesProto3NestedOneofField::OneofBytes(_)) = self.oneof_field {
            self.oneof_field = None;
        }
    }

    pub fn set_oneof_bytes(&mut self, v: Vec<u8>) {
        self.oneof_field = Some(TestAllTypesProto3NestedOneofField::OneofBytes(v));
    }

    pub fn oneof_bytes_mut(&mut self) -> &mut Vec<u8> {
        if let Some(TestAllTypesProto3NestedOneofField::OneofBytes(ref mut v)) = self.oneof_field {
            return v;
        }
        self.oneof_field = Some(TestAllTypesProto3NestedOneofField::OneofBytes(Default::default()));
        if let Some(TestAllTypesProto3NestedOneofField::OneofBytes(ref mut v)) = self.oneof_field {
            return v;
        }
        unreachable!()
    }

    pub fn oneof_bool(&self) -> bool {
        match self.oneof_field {
            Some(TestAllTypesProto3NestedOneofField::OneofBool(v)) => v,
            _ => Default::default(),
        }
    }

    pub fn clear_oneof_bool(&mut self) {
        if let Some(TestAllTypesProto3NestedOneofField::OneofBool(_)) = self.oneof_field {
            self.oneof_field = None;
        }
    }

    pub fn set_oneof_bool(&mut self, v: bool) {
        self.oneof_field = Some(TestAllTypesProto3NestedOneofField::OneofBool(v));
    }

    pub fn oneof_uint64(&self) -> u64 {
        match self.oneof_field {
            Some(TestAllTypesProto3NestedOneofField::OneofUint64(v)) => v,
            _ => Default::default(),
        }
    }

    pub fn clear_oneof_uint64(&mut self) {
        if let Some(TestAllTypesProto3NestedOneofField::OneofUint64(_)) = self.oneof_field {
            self.oneof_field = None;
        }
    }

    pub fn set_oneof_uint64(&mut self, v: u64) {
        self.oneof_field = Some(TestAllTypesProto3NestedOneofField::OneofUint64(v));
    }

    pub fn oneof_float(&self) -> f32 {
        match self.oneof_field {
            Some(TestAllTypesProto3NestedOneofField::OneofFloat(v)) => v,
            _ => Default::default(),
        }
    }

    pub fn clear_oneof_float(&mut self) {
        if let Some(TestAllTypesProto3NestedOneofField::OneofFloat(_)) = self.oneof_field {
            self.oneof_field = None;
        }
    }

    pub fn set_oneof_float(&mut self, v: f32) {
        self.oneof_field = Some(TestAllTypesProto3NestedOneofField::OneofFloat(v));
    }

    pub fn oneof_double(&self) -> f64 {
        match self.oneof_field {
            Some(TestAllTypesProto3NestedOneofField::OneofDouble(v)) => v,
            _ => Default::default(),
        }
    }

    pub fn clear_oneof_double(&mut self) {
        if let Some(TestAllTypesProto3NestedOneofField::OneofDouble(_)) = self.oneof_field {
            self.oneof_field = None;
        }
    }

    pub fn set_oneof_double(&mut self, v: f64) {
        self.oneof_field = Some(TestAllTypesProto3NestedOneofField::OneofDouble(v));
    }

    pub fn oneof_enum(&self) -> TestAllTypesProto3NestedNestedEnum {
        match self.oneof_field {
            Some(TestAllTypesProto3NestedOneofField::OneofEnum(v)) => v,
            _ => Default::default(),
        }
    }

    pub fn clear_oneof_enum(&mut self) {
        if let Some(TestAllTypesProto3NestedOneofField::OneofEnum(_)) = self.oneof_field {
            self.oneof_field = None;
        }
    }

    pub fn set_oneof_enum(&mut self, v: TestAllTypesProto3NestedNestedEnum) {
        self.oneof_field = Some(TestAllTypesProto3NestedOneofField::OneofEnum(v));
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3NestedNestedMessage {
    pub a: i32,
    corecursive: Option<Box<TestAllTypesProto3>>,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for TestAllTypesProto3NestedNestedMessage {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.a = s.read_var_i32()?,
                18 => {
                    let msg = self.corecursive.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.a {
            s.write_raw_1_byte([8])?;
            s.write_var_i32(self.a)?;
        }
        if let Some(v) = &self.corecursive {
            s.write_raw_1_byte([18])?;
            s.write_message(v)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.a {
            n += 1 + codec::varint_i64_bytes_len(self.a as i64) as usize;
        }
        if let Some(v) = &self.corecursive {
            n += {
                let l = v.len();
                1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        n
    }
}

impl TestAllTypesProto3NestedNestedMessage {
    pub const fn new() -> TestAllTypesProto3NestedNestedMessage {
        TestAllTypesProto3NestedNestedMessage {
            a: 0,
            corecursive: None,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3NestedNestedMessage {
        static DEFAULT: TestAllTypesProto3NestedNestedMessage = TestAllTypesProto3NestedNestedMessage::new();
        &DEFAULT
    }

    pub fn a(&self) -> i32 { self.a }

    pub fn clear_a(&mut self) { self.a = 0; }

    pub fn set_a(&mut self, v: i32) { self.a = v; }

    pub fn corecursive(&self) -> &TestAllTypesProto3 {
        self.corecursive.as_ref().map_or_else(|| TestAllTypesProto3::default_instance(), |d| d.as_ref())
    }

    pub fn clear_corecursive(&mut self) { self.corecursive = None; }

    pub fn has_corecursive(&self) -> bool { self.corecursive.is_some() }

    pub fn set_corecursive(&mut self, v: TestAllTypesProto3) { self.corecursive = Some(Box::new(v)); }

    pub fn corecursive_mut(&mut self) -> &mut TestAllTypesProto3 {
        self.corecursive.get_or_insert_with(Default::default)
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3NestedMapInt32Int32Entry {
    pub key: i32,
    pub value: i32,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for TestAllTypesProto3NestedMapInt32Int32Entry {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.key = s.read_var_i32()?,
                16 => self.value = s.read_var_i32()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.key {
            s.write_raw_1_byte([8])?;
            s.write_var_i32(self.key)?;
        }
        if 0 != self.value {
            s.write_raw_1_byte([16])?;
            s.write_var_i32(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.key {
            n += 1 + codec::varint_i64_bytes_len(self.key as i64) as usize;
        }
        if 0 != self.value {
            n += 1 + codec::varint_i64_bytes_len(self.value as i64) as usize;
        }
        n
    }
}

impl TestAllTypesProto3NestedMapInt32Int32Entry {
    pub const fn new() -> TestAllTypesProto3NestedMapInt32Int32Entry {
        TestAllTypesProto3NestedMapInt32Int32Entry {
            key: 0,
            value: 0,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3NestedMapInt32Int32Entry {
        static DEFAULT: TestAllTypesProto3NestedMapInt32Int32Entry = TestAllTypesProto3NestedMapInt32Int32Entry::new();
        &DEFAULT
    }

    pub fn key(&self) -> i32 { self.key }

    pub fn clear_key(&mut self) { self.key = 0; }

    pub fn set_key(&mut self, v: i32) { self.key = v; }

    pub fn value(&self) -> i32 { self.value }

    pub fn clear_value(&mut self) { self.value = 0; }

    pub fn set_value(&mut self, v: i32) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3NestedMapInt64Int64Entry {
    pub key: i64,
    pub value: i64,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for TestAllTypesProto3NestedMapInt64Int64Entry {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.key = s.read_var_i64()?,
                16 => self.value = s.read_var_i64()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.key {
            s.write_raw_1_byte([8])?;
            s.write_var_i64(self.key)?;
        }
        if 0 != self.value {
            s.write_raw_1_byte([16])?;
            s.write_var_i64(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.key {
            n += 1 + codec::varint_i64_bytes_len(self.key) as usize;
        }
        if 0 != self.value {
            n += 1 + codec::varint_i64_bytes_len(self.value) as usize;
        }
        n
    }
}

impl TestAllTypesProto3NestedMapInt64Int64Entry {
    pub const fn new() -> TestAllTypesProto3NestedMapInt64Int64Entry {
        TestAllTypesProto3NestedMapInt64Int64Entry {
            key: 0,
            value: 0,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3NestedMapInt64Int64Entry {
        static DEFAULT: TestAllTypesProto3NestedMapInt64Int64Entry = TestAllTypesProto3NestedMapInt64Int64Entry::new();
        &DEFAULT
    }

    pub fn key(&self) -> i64 { self.key }

    pub fn clear_key(&mut self) { self.key = 0; }

    pub fn set_key(&mut self, v: i64) { self.key = v; }

    pub fn value(&self) -> i64 { self.value }

    pub fn clear_value(&mut self) { self.value = 0; }

    pub fn set_value(&mut self, v: i64) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3NestedMapUint32Uint32Entry {
    pub key: u32,
    pub value: u32,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for TestAllTypesProto3NestedMapUint32Uint32Entry {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.key = s.read_var_u32()?,
                16 => self.value = s.read_var_u32()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.key {
            s.write_raw_1_byte([8])?;
            s.write_var_u32(self.key)?;
        }
        if 0 != self.value {
            s.write_raw_1_byte([16])?;
            s.write_var_u32(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.key {
            n += 1 + codec::varint_u32_bytes_len(self.key) as usize;
        }
        if 0 != self.value {
            n += 1 + codec::varint_u32_bytes_len(self.value) as usize;
        }
        n
    }
}

impl TestAllTypesProto3NestedMapUint32Uint32Entry {
    pub const fn new() -> TestAllTypesProto3NestedMapUint32Uint32Entry {
        TestAllTypesProto3NestedMapUint32Uint32Entry {
            key: 0,
            value: 0,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3NestedMapUint32Uint32Entry {
        static DEFAULT: TestAllTypesProto3NestedMapUint32Uint32Entry = TestAllTypesProto3NestedMapUint32Uint32Entry::new();
        &DEFAULT
    }

    pub fn key(&self) -> u32 { self.key }

    pub fn clear_key(&mut self) { self.key = 0; }

    pub fn set_key(&mut self, v: u32) { self.key = v; }

    pub fn value(&self) -> u32 { self.value }

    pub fn clear_value(&mut self) { self.value = 0; }

    pub fn set_value(&mut self, v: u32) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3NestedMapUint64Uint64Entry {
    pub key: u64,
    pub value: u64,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for TestAllTypesProto3NestedMapUint64Uint64Entry {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.key = s.read_var_u64()?,
                16 => self.value = s.read_var_u64()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.key {
            s.write_raw_1_byte([8])?;
            s.write_var_u64(self.key)?;
        }
        if 0 != self.value {
            s.write_raw_1_byte([16])?;
            s.write_var_u64(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.key {
            n += 1 + codec::varint_u64_bytes_len(self.key) as usize;
        }
        if 0 != self.value {
            n += 1 + codec::varint_u64_bytes_len(self.value) as usize;
        }
        n
    }
}

impl TestAllTypesProto3NestedMapUint64Uint64Entry {
    pub const fn new() -> TestAllTypesProto3NestedMapUint64Uint64Entry {
        TestAllTypesProto3NestedMapUint64Uint64Entry {
            key: 0,
            value: 0,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3NestedMapUint64Uint64Entry {
        static DEFAULT: TestAllTypesProto3NestedMapUint64Uint64Entry = TestAllTypesProto3NestedMapUint64Uint64Entry::new();
        &DEFAULT
    }

    pub fn key(&self) -> u64 { self.key }

    pub fn clear_key(&mut self) { self.key = 0; }

    pub fn set_key(&mut self, v: u64) { self.key = v; }

    pub fn value(&self) -> u64 { self.value }

    pub fn clear_value(&mut self) { self.value = 0; }

    pub fn set_value(&mut self, v: u64) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3NestedMapSint32Sint32Entry {
    pub key: i32,
    pub value: i32,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for TestAllTypesProto3NestedMapSint32Sint32Entry {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.key = s.read_var_s32()?,
                16 => self.value = s.read_var_s32()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.key {
            s.write_raw_1_byte([8])?;
            s.write_var_s32(self.key)?;
        }
        if 0 != self.value {
            s.write_raw_1_byte([16])?;
            s.write_var_s32(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.key {
            n += 1 + codec::varint_s32_bytes_len(self.key) as usize;
        }
        if 0 != self.value {
            n += 1 + codec::varint_s32_bytes_len(self.value) as usize;
        }
        n
    }
}

impl TestAllTypesProto3NestedMapSint32Sint32Entry {
    pub const fn new() -> TestAllTypesProto3NestedMapSint32Sint32Entry {
        TestAllTypesProto3NestedMapSint32Sint32Entry {
            key: 0,
            value: 0,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3NestedMapSint32Sint32Entry {
        static DEFAULT: TestAllTypesProto3NestedMapSint32Sint32Entry = TestAllTypesProto3NestedMapSint32Sint32Entry::new();
        &DEFAULT
    }

    pub fn key(&self) -> i32 { self.key }

    pub fn clear_key(&mut self) { self.key = 0; }

    pub fn set_key(&mut self, v: i32) { self.key = v; }

    pub fn value(&self) -> i32 { self.value }

    pub fn clear_value(&mut self) { self.value = 0; }

    pub fn set_value(&mut self, v: i32) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3NestedMapSint64Sint64Entry {
    pub key: i64,
    pub value: i64,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for TestAllTypesProto3NestedMapSint64Sint64Entry {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.key = s.read_var_s64()?,
                16 => self.value = s.read_var_s64()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.key {
            s.write_raw_1_byte([8])?;
            s.write_var_s64(self.key)?;
        }
        if 0 != self.value {
            s.write_raw_1_byte([16])?;
            s.write_var_s64(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.key {
            n += 1 + codec::varint_s64_bytes_len(self.key) as usize;
        }
        if 0 != self.value {
            n += 1 + codec::varint_s64_bytes_len(self.value) as usize;
        }
        n
    }
}

impl TestAllTypesProto3NestedMapSint64Sint64Entry {
    pub const fn new() -> TestAllTypesProto3NestedMapSint64Sint64Entry {
        TestAllTypesProto3NestedMapSint64Sint64Entry {
            key: 0,
            value: 0,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3NestedMapSint64Sint64Entry {
        static DEFAULT: TestAllTypesProto3NestedMapSint64Sint64Entry = TestAllTypesProto3NestedMapSint64Sint64Entry::new();
        &DEFAULT
    }

    pub fn key(&self) -> i64 { self.key }

    pub fn clear_key(&mut self) { self.key = 0; }

    pub fn set_key(&mut self, v: i64) { self.key = v; }

    pub fn value(&self) -> i64 { self.value }

    pub fn clear_value(&mut self) { self.value = 0; }

    pub fn set_value(&mut self, v: i64) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3NestedMapFixed32Fixed32Entry {
    pub key: u32,
    pub value: u32,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for TestAllTypesProto3NestedMapFixed32Fixed32Entry {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                13 => self.key = s.read_fixed32()?,
                21 => self.value = s.read_fixed32()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.key {
            s.write_raw_1_byte([13])?;
            s.write_fixed32(self.key)?;
        }
        if 0 != self.value {
            s.write_raw_1_byte([21])?;
            s.write_fixed32(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.key {
            n += 5;
        }
        if 0 != self.value {
            n += 5;
        }
        n
    }
}

impl TestAllTypesProto3NestedMapFixed32Fixed32Entry {
    pub const fn new() -> TestAllTypesProto3NestedMapFixed32Fixed32Entry {
        TestAllTypesProto3NestedMapFixed32Fixed32Entry {
            key: 0,
            value: 0,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3NestedMapFixed32Fixed32Entry {
        static DEFAULT: TestAllTypesProto3NestedMapFixed32Fixed32Entry = TestAllTypesProto3NestedMapFixed32Fixed32Entry::new();
        &DEFAULT
    }

    pub fn key(&self) -> u32 { self.key }

    pub fn clear_key(&mut self) { self.key = 0; }

    pub fn set_key(&mut self, v: u32) { self.key = v; }

    pub fn value(&self) -> u32 { self.value }

    pub fn clear_value(&mut self) { self.value = 0; }

    pub fn set_value(&mut self, v: u32) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3NestedMapFixed64Fixed64Entry {
    pub key: u64,
    pub value: u64,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for TestAllTypesProto3NestedMapFixed64Fixed64Entry {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                9 => self.key = s.read_fixed64()?,
                17 => self.value = s.read_fixed64()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.key {
            s.write_raw_1_byte([9])?;
            s.write_fixed64(self.key)?;
        }
        if 0 != self.value {
            s.write_raw_1_byte([17])?;
            s.write_fixed64(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.key {
            n += 9;
        }
        if 0 != self.value {
            n += 9;
        }
        n
    }
}

impl TestAllTypesProto3NestedMapFixed64Fixed64Entry {
    pub const fn new() -> TestAllTypesProto3NestedMapFixed64Fixed64Entry {
        TestAllTypesProto3NestedMapFixed64Fixed64Entry {
            key: 0,
            value: 0,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3NestedMapFixed64Fixed64Entry {
        static DEFAULT: TestAllTypesProto3NestedMapFixed64Fixed64Entry = TestAllTypesProto3NestedMapFixed64Fixed64Entry::new();
        &DEFAULT
    }

    pub fn key(&self) -> u64 { self.key }

    pub fn clear_key(&mut self) { self.key = 0; }

    pub fn set_key(&mut self, v: u64) { self.key = v; }

    pub fn value(&self) -> u64 { self.value }

    pub fn clear_value(&mut self) { self.value = 0; }

    pub fn set_value(&mut self, v: u64) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3NestedMapSfixed32Sfixed32Entry {
    pub key: i32,
    pub value: i32,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for TestAllTypesProto3NestedMapSfixed32Sfixed32Entry {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                13 => self.key = s.read_sfixed32()?,
                21 => self.value = s.read_sfixed32()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.key {
            s.write_raw_1_byte([13])?;
            s.write_sfixed32(self.key)?;
        }
        if 0 != self.value {
            s.write_raw_1_byte([21])?;
            s.write_sfixed32(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.key {
            n += 5;
        }
        if 0 != self.value {
            n += 5;
        }
        n
    }
}

impl TestAllTypesProto3NestedMapSfixed32Sfixed32Entry {
    pub const fn new() -> TestAllTypesProto3NestedMapSfixed32Sfixed32Entry {
        TestAllTypesProto3NestedMapSfixed32Sfixed32Entry {
            key: 0,
            value: 0,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3NestedMapSfixed32Sfixed32Entry {
        static DEFAULT: TestAllTypesProto3NestedMapSfixed32Sfixed32Entry = TestAllTypesProto3NestedMapSfixed32Sfixed32Entry::new();
        &DEFAULT
    }

    pub fn key(&self) -> i32 { self.key }

    pub fn clear_key(&mut self) { self.key = 0; }

    pub fn set_key(&mut self, v: i32) { self.key = v; }

    pub fn value(&self) -> i32 { self.value }

    pub fn clear_value(&mut self) { self.value = 0; }

    pub fn set_value(&mut self, v: i32) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3NestedMapSfixed64Sfixed64Entry {
    pub key: i64,
    pub value: i64,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for TestAllTypesProto3NestedMapSfixed64Sfixed64Entry {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                9 => self.key = s.read_sfixed64()?,
                17 => self.value = s.read_sfixed64()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.key {
            s.write_raw_1_byte([9])?;
            s.write_sfixed64(self.key)?;
        }
        if 0 != self.value {
            s.write_raw_1_byte([17])?;
            s.write_sfixed64(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.key {
            n += 9;
        }
        if 0 != self.value {
            n += 9;
        }
        n
    }
}

impl TestAllTypesProto3NestedMapSfixed64Sfixed64Entry {
    pub const fn new() -> TestAllTypesProto3NestedMapSfixed64Sfixed64Entry {
        TestAllTypesProto3NestedMapSfixed64Sfixed64Entry {
            key: 0,
            value: 0,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3NestedMapSfixed64Sfixed64Entry {
        static DEFAULT: TestAllTypesProto3NestedMapSfixed64Sfixed64Entry = TestAllTypesProto3NestedMapSfixed64Sfixed64Entry::new();
        &DEFAULT
    }

    pub fn key(&self) -> i64 { self.key }

    pub fn clear_key(&mut self) { self.key = 0; }

    pub fn set_key(&mut self, v: i64) { self.key = v; }

    pub fn value(&self) -> i64 { self.value }

    pub fn clear_value(&mut self) { self.value = 0; }

    pub fn set_value(&mut self, v: i64) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3NestedMapInt32FloatEntry {
    pub key: i32,
    pub value: f32,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for TestAllTypesProto3NestedMapInt32FloatEntry {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.key = s.read_var_i32()?,
                21 => self.value = s.read_f32()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.key {
            s.write_raw_1_byte([8])?;
            s.write_var_i32(self.key)?;
        }
        if 0f32 != self.value {
            s.write_raw_1_byte([21])?;
            s.write_f32(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.key {
            n += 1 + codec::varint_i64_bytes_len(self.key as i64) as usize;
        }
        if 0f32 != self.value {
            n += 5;
        }
        n
    }
}

impl TestAllTypesProto3NestedMapInt32FloatEntry {
    pub const fn new() -> TestAllTypesProto3NestedMapInt32FloatEntry {
        TestAllTypesProto3NestedMapInt32FloatEntry {
            key: 0,
            value: 0f32,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3NestedMapInt32FloatEntry {
        static DEFAULT: TestAllTypesProto3NestedMapInt32FloatEntry = TestAllTypesProto3NestedMapInt32FloatEntry::new();
        &DEFAULT
    }

    pub fn key(&self) -> i32 { self.key }

    pub fn clear_key(&mut self) { self.key = 0; }

    pub fn set_key(&mut self, v: i32) { self.key = v; }

    pub fn value(&self) -> f32 { self.value }

    pub fn clear_value(&mut self) { self.value = 0f32; }

    pub fn set_value(&mut self, v: f32) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3NestedMapInt32DoubleEntry {
    pub key: i32,
    pub value: f64,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for TestAllTypesProto3NestedMapInt32DoubleEntry {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.key = s.read_var_i32()?,
                17 => self.value = s.read_f64()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.key {
            s.write_raw_1_byte([8])?;
            s.write_var_i32(self.key)?;
        }
        if 0f64 != self.value {
            s.write_raw_1_byte([17])?;
            s.write_f64(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.key {
            n += 1 + codec::varint_i64_bytes_len(self.key as i64) as usize;
        }
        if 0f64 != self.value {
            n += 9;
        }
        n
    }
}

impl TestAllTypesProto3NestedMapInt32DoubleEntry {
    pub const fn new() -> TestAllTypesProto3NestedMapInt32DoubleEntry {
        TestAllTypesProto3NestedMapInt32DoubleEntry {
            key: 0,
            value: 0f64,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3NestedMapInt32DoubleEntry {
        static DEFAULT: TestAllTypesProto3NestedMapInt32DoubleEntry = TestAllTypesProto3NestedMapInt32DoubleEntry::new();
        &DEFAULT
    }

    pub fn key(&self) -> i32 { self.key }

    pub fn clear_key(&mut self) { self.key = 0; }

    pub fn set_key(&mut self, v: i32) { self.key = v; }

    pub fn value(&self) -> f64 { self.value }

    pub fn clear_value(&mut self) { self.value = 0f64; }

    pub fn set_value(&mut self, v: f64) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3NestedMapBoolBoolEntry {
    pub key: bool,
    pub value: bool,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for TestAllTypesProto3NestedMapBoolBoolEntry {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.key = s.read_bool()?,
                16 => self.value = s.read_bool()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if self.key {
            s.write_raw_1_byte([8])?;
            s.write_bool(self.key)?;
        }
        if self.value {
            s.write_raw_1_byte([16])?;
            s.write_bool(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if self.key {
            n += 2;
        }
        if self.value {
            n += 2;
        }
        n
    }
}

impl TestAllTypesProto3NestedMapBoolBoolEntry {
    pub const fn new() -> TestAllTypesProto3NestedMapBoolBoolEntry {
        TestAllTypesProto3NestedMapBoolBoolEntry {
            key: false,
            value: false,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3NestedMapBoolBoolEntry {
        static DEFAULT: TestAllTypesProto3NestedMapBoolBoolEntry = TestAllTypesProto3NestedMapBoolBoolEntry::new();
        &DEFAULT
    }

    pub fn key(&self) -> bool { self.key }

    pub fn clear_key(&mut self) { self.key = false; }

    pub fn set_key(&mut self, v: bool) { self.key = v; }

    pub fn value(&self) -> bool { self.value }

    pub fn clear_value(&mut self) { self.value = false; }

    pub fn set_value(&mut self, v: bool) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3NestedMapStringStringEntry {
    pub key: String,
    pub value: String,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for TestAllTypesProto3NestedMapStringStringEntry {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.key = s.read_string()?,
                18 => self.value = s.read_string()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !&self.key.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.key)?;
        }
        if !&self.value.is_empty() {
            s.write_raw_1_byte([18])?;
            s.write_string(&self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.key.is_empty() {
            n += {
                let l = self.key.len();
                1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.value.is_empty() {
            n += {
                let l = self.value.len();
                1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        n
    }
}

impl TestAllTypesProto3NestedMapStringStringEntry {
    pub const fn new() -> TestAllTypesProto3NestedMapStringStringEntry {
        TestAllTypesProto3NestedMapStringStringEntry {
            key: String::new(),
            value: String::new(),
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3NestedMapStringStringEntry {
        static DEFAULT: TestAllTypesProto3NestedMapStringStringEntry = TestAllTypesProto3NestedMapStringStringEntry::new();
        &DEFAULT
    }

    pub fn key(&self) -> &str { &self.key }

    pub fn clear_key(&mut self) { self.key = Default::default(); }

    pub fn set_key(&mut self, v: String) { self.key = v; }

    pub fn key_mut(&mut self) -> &mut String { &mut self.key }

    pub fn value(&self) -> &str { &self.value }

    pub fn clear_value(&mut self) { self.value = Default::default(); }

    pub fn set_value(&mut self, v: String) { self.value = v; }

    pub fn value_mut(&mut self) -> &mut String { &mut self.value }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3NestedMapStringBytesEntry {
    pub key: String,
    pub value: Vec<u8>,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for TestAllTypesProto3NestedMapStringBytesEntry {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.key = s.read_string()?,
                18 => self.value = s.read_bytes()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !&self.key.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.key)?;
        }
        if !&self.value.is_empty() {
            s.write_raw_1_byte([18])?;
            s.write_bytes(&self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.key.is_empty() {
            n += {
                let l = self.key.len();
                1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if !self.value.is_empty() {
            n += {
                let l = self.value.len();
                1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        n
    }
}

impl TestAllTypesProto3NestedMapStringBytesEntry {
    pub const fn new() -> TestAllTypesProto3NestedMapStringBytesEntry {
        TestAllTypesProto3NestedMapStringBytesEntry {
            key: String::new(),
            value: Vec::new(),
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3NestedMapStringBytesEntry {
        static DEFAULT: TestAllTypesProto3NestedMapStringBytesEntry = TestAllTypesProto3NestedMapStringBytesEntry::new();
        &DEFAULT
    }

    pub fn key(&self) -> &str { &self.key }

    pub fn clear_key(&mut self) { self.key = Default::default(); }

    pub fn set_key(&mut self, v: String) { self.key = v; }

    pub fn key_mut(&mut self) -> &mut String { &mut self.key }

    pub fn value(&self) -> &[u8] { &self.value }

    pub fn clear_value(&mut self) { self.value = Default::default(); }

    pub fn set_value(&mut self, v: Vec<u8>) { self.value = v; }

    pub fn value_mut(&mut self) -> &mut Vec<u8> { &mut self.value }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3NestedMapStringNestedMessageEntry {
    pub key: String,
    value: Option<TestAllTypesProto3NestedNestedMessage>,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for TestAllTypesProto3NestedMapStringNestedMessageEntry {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.key = s.read_string()?,
                18 => {
                    let msg = self.value.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !&self.key.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.key)?;
        }
        if let Some(v) = &self.value {
            s.write_raw_1_byte([18])?;
            s.write_message(v)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.key.is_empty() {
            n += {
                let l = self.key.len();
                1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if let Some(v) = &self.value {
            n += {
                let l = v.len();
                1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        n
    }
}

impl TestAllTypesProto3NestedMapStringNestedMessageEntry {
    pub const fn new() -> TestAllTypesProto3NestedMapStringNestedMessageEntry {
        TestAllTypesProto3NestedMapStringNestedMessageEntry {
            key: String::new(),
            value: None,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3NestedMapStringNestedMessageEntry {
        static DEFAULT: TestAllTypesProto3NestedMapStringNestedMessageEntry = TestAllTypesProto3NestedMapStringNestedMessageEntry::new();
        &DEFAULT
    }

    pub fn key(&self) -> &str { &self.key }

    pub fn clear_key(&mut self) { self.key = Default::default(); }

    pub fn set_key(&mut self, v: String) { self.key = v; }

    pub fn key_mut(&mut self) -> &mut String { &mut self.key }

    pub fn value(&self) -> &TestAllTypesProto3NestedNestedMessage {
        self.value.as_ref().unwrap_or_else(|| TestAllTypesProto3NestedNestedMessage::default_instance())
    }

    pub fn clear_value(&mut self) { self.value = None; }

    pub fn has_value(&self) -> bool { self.value.is_some() }

    pub fn set_value(&mut self, v: TestAllTypesProto3NestedNestedMessage) { self.value = Some(v); }

    pub fn value_mut(&mut self) -> &mut TestAllTypesProto3NestedNestedMessage {
        self.value.get_or_insert_with(Default::default)
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3NestedMapStringForeignMessageEntry {
    pub key: String,
    value: Option<ForeignMessage>,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for TestAllTypesProto3NestedMapStringForeignMessageEntry {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.key = s.read_string()?,
                18 => {
                    let msg = self.value.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !&self.key.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.key)?;
        }
        if let Some(v) = &self.value {
            s.write_raw_1_byte([18])?;
            s.write_message(v)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.key.is_empty() {
            n += {
                let l = self.key.len();
                1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if let Some(v) = &self.value {
            n += {
                let l = v.len();
                1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        n
    }
}

impl TestAllTypesProto3NestedMapStringForeignMessageEntry {
    pub const fn new() -> TestAllTypesProto3NestedMapStringForeignMessageEntry {
        TestAllTypesProto3NestedMapStringForeignMessageEntry {
            key: String::new(),
            value: None,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3NestedMapStringForeignMessageEntry {
        static DEFAULT: TestAllTypesProto3NestedMapStringForeignMessageEntry = TestAllTypesProto3NestedMapStringForeignMessageEntry::new();
        &DEFAULT
    }

    pub fn key(&self) -> &str { &self.key }

    pub fn clear_key(&mut self) { self.key = Default::default(); }

    pub fn set_key(&mut self, v: String) { self.key = v; }

    pub fn key_mut(&mut self) -> &mut String { &mut self.key }

    pub fn value(&self) -> &ForeignMessage {
        self.value.as_ref().unwrap_or_else(|| ForeignMessage::default_instance())
    }

    pub fn clear_value(&mut self) { self.value = None; }

    pub fn has_value(&self) -> bool { self.value.is_some() }

    pub fn set_value(&mut self, v: ForeignMessage) { self.value = Some(v); }

    pub fn value_mut(&mut self) -> &mut ForeignMessage {
        self.value.get_or_insert_with(Default::default)
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3NestedMapStringNestedEnumEntry {
    pub key: String,
    pub value: TestAllTypesProto3NestedNestedEnum,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for TestAllTypesProto3NestedMapStringNestedEnumEntry {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.key = s.read_string()?,
                16 => self.value = s.read_enum()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !&self.key.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.key)?;
        }
        if self.value.value() != 0 {
            s.write_raw_1_byte([16])?;
            s.write_enum(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.key.is_empty() {
            n += {
                let l = self.key.len();
                1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if self.value.value() != 0 {
            n += 1 + codec::varint_i64_bytes_len(self.value.value() as i64) as usize;
        }
        n
    }
}

impl TestAllTypesProto3NestedMapStringNestedEnumEntry {
    pub const fn new() -> TestAllTypesProto3NestedMapStringNestedEnumEntry {
        TestAllTypesProto3NestedMapStringNestedEnumEntry {
            key: String::new(),
            value: TestAllTypesProto3NestedNestedEnum::new(),
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3NestedMapStringNestedEnumEntry {
        static DEFAULT: TestAllTypesProto3NestedMapStringNestedEnumEntry = TestAllTypesProto3NestedMapStringNestedEnumEntry::new();
        &DEFAULT
    }

    pub fn key(&self) -> &str { &self.key }

    pub fn clear_key(&mut self) { self.key = Default::default(); }

    pub fn set_key(&mut self, v: String) { self.key = v; }

    pub fn key_mut(&mut self) -> &mut String { &mut self.key }

    pub fn value(&self) -> TestAllTypesProto3NestedNestedEnum { self.value }

    pub fn clear_value(&mut self) { self.value = Default::default(); }

    pub fn set_value(&mut self, v: TestAllTypesProto3NestedNestedEnum) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TestAllTypesProto3NestedMapStringForeignEnumEntry {
    pub key: String,
    pub value: ForeignEnum,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for TestAllTypesProto3NestedMapStringForeignEnumEntry {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.key = s.read_string()?,
                16 => self.value = s.read_enum()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !&self.key.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.key)?;
        }
        if self.value.value() != 0 {
            s.write_raw_1_byte([16])?;
            s.write_enum(self.value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.key.is_empty() {
            n += {
                let l = self.key.len();
                1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if self.value.value() != 0 {
            n += 1 + codec::varint_i64_bytes_len(self.value.value() as i64) as usize;
        }
        n
    }
}

impl TestAllTypesProto3NestedMapStringForeignEnumEntry {
    pub const fn new() -> TestAllTypesProto3NestedMapStringForeignEnumEntry {
        TestAllTypesProto3NestedMapStringForeignEnumEntry {
            key: String::new(),
            value: ForeignEnum::new(),
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static TestAllTypesProto3NestedMapStringForeignEnumEntry {
        static DEFAULT: TestAllTypesProto3NestedMapStringForeignEnumEntry = TestAllTypesProto3NestedMapStringForeignEnumEntry::new();
        &DEFAULT
    }

    pub fn key(&self) -> &str { &self.key }

    pub fn clear_key(&mut self) { self.key = Default::default(); }

    pub fn set_key(&mut self, v: String) { self.key = v; }

    pub fn key_mut(&mut self) -> &mut String { &mut self.key }

    pub fn value(&self) -> ForeignEnum { self.value }

    pub fn clear_value(&mut self) { self.value = Default::default(); }

    pub fn set_value(&mut self, v: ForeignEnum) { self.value = v; }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct ForeignMessage {
    pub c: i32,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for ForeignMessage {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.c = s.read_var_i32()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.c {
            s.write_raw_1_byte([8])?;
            s.write_var_i32(self.c)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.c {
            n += 1 + codec::varint_i64_bytes_len(self.c as i64) as usize;
        }
        n
    }
}

impl ForeignMessage {
    pub const fn new() -> ForeignMessage {
        ForeignMessage {
            c: 0,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static ForeignMessage {
        static DEFAULT: ForeignMessage = ForeignMessage::new();
        &DEFAULT
    }

    pub fn c(&self) -> i32 { self.c }

    pub fn clear_c(&mut self) { self.c = 0; }

    pub fn set_c(&mut self, v: i32) { self.c = v; }
}
