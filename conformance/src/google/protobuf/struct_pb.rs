// This file is generated by pecan 0.1.0, DO NOT EDIT!
// @generated
// source: google/protobuf/struct.proto

#![allow(non_upper_case_globals)]
#![allow(unused_imports)]

use pecan::{
    codec,
    EnumType,
    Message,
    Result,
    Buf,
    BufMut,
    CodedInputStream,
    CodedOutputStream,
    encoded,
};
use std::collections::HashMap;

pub static DESCRIPTOR: &[u8] = &[
    10, 28, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117,
    102, 47, 115, 116, 114, 117, 99, 116, 46, 112, 114, 111, 116, 111, 18, 15,
    103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 66,
    129, 1, 10, 19, 99, 111, 109, 46, 103, 111, 111, 103, 108, 101, 46, 112,
    114, 111, 116, 111, 98, 117, 102, 66, 11, 83, 116, 114, 117, 99, 116, 80,
    114, 111, 116, 111, 80, 1, 90, 49, 103, 105, 116, 104, 117, 98, 46, 99,
    111, 109, 47, 103, 111, 108, 97, 110, 103, 47, 112, 114, 111, 116, 111, 98,
    117, 102, 47, 112, 116, 121, 112, 101, 115, 47, 115, 116, 114, 117, 99, 116,
    59, 115, 116, 114, 117, 99, 116, 112, 98, 248, 1, 1, 162, 2, 3, 71,
    80, 66, 170, 2, 30, 71, 111, 111, 103, 108, 101, 46, 80, 114, 111, 116,
    111, 98, 117, 102, 46, 87, 101, 108, 108, 75, 110, 111, 119, 110, 84, 121,
    112, 101, 115, 98, 6, 112, 114, 111, 116, 111, 51,
];

#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]
pub struct NullValue(i32);

impl NullValue {
    pub const NullValue: NullValue = NullValue(0);

    pub const fn new() -> NullValue {
        NullValue::NullValue
    }
}

impl From<i32> for NullValue {
    #[inline]
    fn from(u: i32) -> NullValue {
        NullValue(u)
    }
}

impl EnumType for NullValue {
    #[inline]
    fn values() -> &'static [NullValue] {
        &[
            NullValue::NullValue,
        ]
    }

    #[inline]
    fn value(&self) -> i32 { self.0 }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct Struct {
    fields: Option<HashMap<String, Value>>,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for Struct {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => s.read_message_like(|s| {
                    let tag = s.read_tag()?;
                    let (mut key, mut value) = Default::default();
                    loop {
                        match tag {
                            10 => key = s.read_string()?,
                            18 => s.read_message(&mut value)?,
                            0 => break,
                            tag => s.discard_field(tag)?,
                        }
                    }
                    self.fields.get_or_insert_with(Default::default).insert(key, value);
                    Ok(())
                })?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if let Some(m) = &self.fields {
            for (k, v) in m {
                s.write_raw_1_byte([10])?;
                let mut n = 0;
                if !k.is_empty() {
                    n += {
                        let l = k.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                n += {
                    let l = v.len();
                    1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                };
                s.write_var_u32(n as u32)?;
                if !k.is_empty() {
                    s.write_raw_1_byte([10])?;
                    s.write_string(k)?;
                }
                s.write_raw_1_byte([18])?;
                s.write_message(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if let Some(m) = &self.fields {
            for (k, v) in m {
                n += 1;
                if !k.is_empty() {
                    n += {
                        let l = k.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                n += {
                    let l = v.len();
                    1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                };
            }
        }
        n
    }
}

impl Struct {
    pub const fn new() -> Struct {
        Struct {
            fields: None,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static Struct {
        static DEFAULT: Struct = Struct::new();
        &DEFAULT
    }

    pub fn fields(&self) -> &Option<HashMap<String, Value>> { &self.fields }

    pub fn clear_fields(&mut self) { self.fields = None; }

    pub fn set_fields(&mut self, v: impl Into<Option<HashMap<String, Value>>>) { self.fields = v.into(); }

    pub fn fields_mut(&mut self) -> &mut Option<HashMap<String, Value>> { &mut self.fields }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct StructNestedFieldsEntry {
    pub key: String,
    value: Option<Value>,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for StructNestedFieldsEntry {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.key = s.read_string()?,
                18 => {
                    let msg = self.value.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !&self.key.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.key)?;
        }
        if let Some(v) = &self.value {
            s.write_raw_1_byte([18])?;
            s.write_message(v)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.key.is_empty() {
            n += {
                let l = self.key.len();
                1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        if let Some(v) = &self.value {
            n += {
                let l = v.len();
                1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            };
        }
        n
    }
}

impl StructNestedFieldsEntry {
    pub const fn new() -> StructNestedFieldsEntry {
        StructNestedFieldsEntry {
            key: String::new(),
            value: None,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static StructNestedFieldsEntry {
        static DEFAULT: StructNestedFieldsEntry = StructNestedFieldsEntry::new();
        &DEFAULT
    }

    pub fn key(&self) -> &str { &self.key }

    pub fn clear_key(&mut self) { self.key = Default::default(); }

    pub fn set_key(&mut self, v: String) { self.key = v; }

    pub fn key_mut(&mut self) -> &mut String { &mut self.key }

    pub fn value(&self) -> &Value {
        self.value.as_ref().unwrap_or_else(|| Value::default_instance())
    }

    pub fn clear_value(&mut self) { self.value = None; }

    pub fn has_value(&self) -> bool { self.value.is_some() }

    pub fn set_value(&mut self, v: Value) { self.value = Some(v); }

    pub fn value_mut(&mut self) -> &mut Value {
        self.value.get_or_insert_with(Default::default)
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct Value {
    pub kind: Option<ValueNestedKind>,
    cache_size: u32,
    unknown: Vec<u8>,
}

#[derive(Clone, Debug, PartialEq)]
pub enum ValueNestedKind {
    NullValue(NullValue),
    NumberValue(f64),
    StringValue(String),
    BoolValue(bool),
    StructValue(Struct),
    ListValue(ListValue),
}

impl Message for Value {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.kind = Some(ValueNestedKind::NullValue(s.read_enum()?)),
                17 => self.kind = Some(ValueNestedKind::NumberValue(s.read_f64()?)),
                26 => self.kind = Some(ValueNestedKind::StringValue(s.read_string()?)),
                32 => self.kind = Some(ValueNestedKind::BoolValue(s.read_bool()?)),
                42 => {
                    let msg = self.struct_value_mut();
                    s.read_message(msg)?;
                }
                50 => {
                    let msg = self.list_value_mut();
                    s.read_message(msg)?;
                }
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if let Some(v) = &self.kind {
            match v {
                ValueNestedKind::NullValue(v) => {
                    s.write_raw_1_byte([8])?;
                    s.write_enum(*v)?;
                }
                ValueNestedKind::NumberValue(v) => {
                    s.write_raw_1_byte([17])?;
                    s.write_f64(*v)?;
                }
                ValueNestedKind::StringValue(v) => {
                    s.write_raw_1_byte([26])?;
                    s.write_string(v)?;
                }
                ValueNestedKind::BoolValue(v) => {
                    s.write_raw_1_byte([32])?;
                    s.write_bool(*v)?;
                }
                ValueNestedKind::StructValue(v) => {
                    s.write_raw_1_byte([42])?;
                    s.write_message(v)?;
                }
                ValueNestedKind::ListValue(v) => {
                    s.write_raw_1_byte([50])?;
                    s.write_message(v)?;
                }
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if let Some(v) = &self.kind {
            match v {
                ValueNestedKind::NullValue(v) => {
                    n += 1 + codec::varint_i64_bytes_len((*v).value() as i64) as usize;
                }
                ValueNestedKind::NumberValue(_) => {
                    n += 9;
                }
                ValueNestedKind::StringValue(v) => {
                    n += {
                        let l = v.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                ValueNestedKind::BoolValue(_) => {
                    n += 2;
                }
                ValueNestedKind::StructValue(v) => {
                    n += {
                        let l = v.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
                ValueNestedKind::ListValue(v) => {
                    n += {
                        let l = v.len();
                        1 + codec::varint_u32_bytes_len(l as u32) as usize + l
                    };
                }
            }
        }
        n
    }
}

impl Value {
    pub const fn new() -> Value {
        Value {
            kind: None,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static Value {
        static DEFAULT: Value = Value::new();
        &DEFAULT
    }

    pub fn null_value(&self) -> NullValue {
        match self.kind {
            Some(ValueNestedKind::NullValue(v)) => v,
            _ => Default::default(),
        }
    }

    pub fn clear_null_value(&mut self) {
        if let Some(ValueNestedKind::NullValue(_)) = self.kind {
            self.kind = None;
        }
    }

    pub fn set_null_value(&mut self, v: NullValue) {
        self.kind = Some(ValueNestedKind::NullValue(v));
    }

    pub fn number_value(&self) -> f64 {
        match self.kind {
            Some(ValueNestedKind::NumberValue(v)) => v,
            _ => Default::default(),
        }
    }

    pub fn clear_number_value(&mut self) {
        if let Some(ValueNestedKind::NumberValue(_)) = self.kind {
            self.kind = None;
        }
    }

    pub fn set_number_value(&mut self, v: f64) {
        self.kind = Some(ValueNestedKind::NumberValue(v));
    }

    pub fn string_value(&self) -> &str {
        match &self.kind {
            Some(ValueNestedKind::StringValue(v)) => v,
            _ => "",
        }
    }

    pub fn clear_string_value(&mut self) {
        if let Some(ValueNestedKind::StringValue(_)) = self.kind {
            self.kind = None;
        }
    }

    pub fn set_string_value(&mut self, v: String) {
        self.kind = Some(ValueNestedKind::StringValue(v));
    }

    pub fn string_value_mut(&mut self) -> &mut String {
        if let Some(ValueNestedKind::StringValue(ref mut v)) = self.kind {
            return v;
        }
        self.kind = Some(ValueNestedKind::StringValue(Default::default()));
        if let Some(ValueNestedKind::StringValue(ref mut v)) = self.kind {
            return v;
        }
        unreachable!()
    }

    pub fn bool_value(&self) -> bool {
        match self.kind {
            Some(ValueNestedKind::BoolValue(v)) => v,
            _ => Default::default(),
        }
    }

    pub fn clear_bool_value(&mut self) {
        if let Some(ValueNestedKind::BoolValue(_)) = self.kind {
            self.kind = None;
        }
    }

    pub fn set_bool_value(&mut self, v: bool) {
        self.kind = Some(ValueNestedKind::BoolValue(v));
    }

    pub fn struct_value(&self) -> &Struct {
        match &self.kind {
            Some(ValueNestedKind::StructValue(v)) => v,
            _ => Struct::default_instance(),
        }
    }

    pub fn clear_struct_value(&mut self) {
        if let Some(ValueNestedKind::StructValue(_)) = self.kind {
            self.kind = None;
        }
    }

    pub fn set_struct_value(&mut self, v: Struct) {
        self.kind = Some(ValueNestedKind::StructValue(v));
    }

    pub fn struct_value_mut(&mut self) -> &mut Struct {
        if let Some(ValueNestedKind::StructValue(ref mut v)) = self.kind {
            return v;
        }
        self.kind = Some(ValueNestedKind::StructValue(Default::default()));
        if let Some(ValueNestedKind::StructValue(ref mut v)) = self.kind {
            return v;
        }
        unreachable!()
    }

    pub fn list_value(&self) -> &ListValue {
        match &self.kind {
            Some(ValueNestedKind::ListValue(v)) => v,
            _ => ListValue::default_instance(),
        }
    }

    pub fn clear_list_value(&mut self) {
        if let Some(ValueNestedKind::ListValue(_)) = self.kind {
            self.kind = None;
        }
    }

    pub fn set_list_value(&mut self, v: ListValue) {
        self.kind = Some(ValueNestedKind::ListValue(v));
    }

    pub fn list_value_mut(&mut self) -> &mut ListValue {
        if let Some(ValueNestedKind::ListValue(ref mut v)) = self.kind {
            return v;
        }
        self.kind = Some(ValueNestedKind::ListValue(Default::default()));
        if let Some(ValueNestedKind::ListValue(ref mut v)) = self.kind {
            return v;
        }
        unreachable!()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct ListValue {
    values: Vec<Value>,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for ListValue {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => s.read_message_to(&mut self.values)?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.values.is_empty() {
            for v in &self.values {
                s.write_raw_1_byte([10])?;
                s.write_message(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.values.is_empty() {
            n += self.values.iter().fold(0, |n, m| {
                let l = m.len();
                n + 1 + codec::varint_u32_bytes_len(l as u32) as usize + l
            });
        }
        n
    }
}

impl ListValue {
    pub const fn new() -> ListValue {
        ListValue {
            values: Vec::new(),
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static ListValue {
        static DEFAULT: ListValue = ListValue::new();
        &DEFAULT
    }

    pub fn values(&self) -> &[Value] { &self.values }

    pub fn clear_values(&mut self) { self.values.clear(); }

    pub fn set_values(&mut self, v: impl Into<Vec<Value>>) { self.values = v.into(); }

    pub fn values_mut(&mut self) -> &mut Vec<Value> { &mut self.values }
}
