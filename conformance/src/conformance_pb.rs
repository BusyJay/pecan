// This file is generated by pecan 0.1.0, DO NOT EDIT!
// @generated
// source: conformance.proto

#![allow(non_upper_case_globals)]
#![allow(unused_imports)]

use pecan::{
    EnumType,
    Message,
    Result,
    Buf,
    BufMut,
    CodedInputStream,
    CodedOutputStream,
    encoded,
};

pub static DESCRIPTOR: &[u8] = &[
    10, 17, 99, 111, 110, 102, 111, 114, 109, 97, 110, 99, 101, 46, 112, 114,
    111, 116, 111, 18, 11, 99, 111, 110, 102, 111, 114, 109, 97, 110, 99, 101,
    66, 33, 10, 31, 99, 111, 109, 46, 103, 111, 111, 103, 108, 101, 46, 112,
    114, 111, 116, 111, 98, 117, 102, 46, 99, 111, 110, 102, 111, 114, 109, 97,
    110, 99, 101, 98, 6, 112, 114, 111, 116, 111, 51,
];

#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]
pub struct WireFormat(i32);

impl WireFormat {
    pub const Unspecified: WireFormat = WireFormat(0);
    pub const Protobuf: WireFormat = WireFormat(1);
    pub const Json: WireFormat = WireFormat(2);
    pub const Jspb: WireFormat = WireFormat(3);
    pub const TextFormat: WireFormat = WireFormat(4);

    pub const fn new() -> WireFormat {
        WireFormat::Unspecified
    }
}

impl From<i32> for WireFormat {
    #[inline]
    fn from(u: i32) -> WireFormat {
        WireFormat(u)
    }
}

impl EnumType for WireFormat {
    #[inline]
    fn values() -> &'static [WireFormat] {
        &[
            WireFormat::Unspecified,
            WireFormat::Protobuf,
            WireFormat::Json,
            WireFormat::Jspb,
            WireFormat::TextFormat,
        ]
    }

    #[inline]
    fn value(&self) -> i32 { self.0 }
}

#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]
pub struct TestCategory(i32);

impl TestCategory {
    pub const UnspecifiedTest: TestCategory = TestCategory(0);
    pub const BinaryTest: TestCategory = TestCategory(1);
    pub const JsonTest: TestCategory = TestCategory(2);
    pub const JsonIgnoreUnknownParsingTest: TestCategory = TestCategory(3);
    pub const JspbTest: TestCategory = TestCategory(4);
    pub const TextFormatTest: TestCategory = TestCategory(5);

    pub const fn new() -> TestCategory {
        TestCategory::UnspecifiedTest
    }
}

impl From<i32> for TestCategory {
    #[inline]
    fn from(u: i32) -> TestCategory {
        TestCategory(u)
    }
}

impl EnumType for TestCategory {
    #[inline]
    fn values() -> &'static [TestCategory] {
        &[
            TestCategory::UnspecifiedTest,
            TestCategory::BinaryTest,
            TestCategory::JsonTest,
            TestCategory::JsonIgnoreUnknownParsingTest,
            TestCategory::JspbTest,
            TestCategory::TextFormatTest,
        ]
    }

    #[inline]
    fn value(&self) -> i32 { self.0 }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct FailureSet {
    failure: Vec<String>,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for FailureSet {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.failure.push(s.read_string()?),
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.failure.is_empty() {
            for v in &self.failure {
                s.write_raw_1_byte([10])?;
                s.write_string(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.failure.is_empty() {
            n += encoded::arr_string_len(1, &self.failure);
        }
        n
    }
}

impl FailureSet {
    pub const fn new() -> FailureSet {
        FailureSet {
            failure: Vec::new(),
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static FailureSet {
        static DEFAULT: FailureSet = FailureSet::new();
        &DEFAULT
    }

    pub fn failure(&self) -> &[String] { &self.failure }

    pub fn clear_failure(&mut self) { self.failure.clear(); }

    pub fn set_failure(&mut self, v: impl Into<Vec<String>>) { self.failure = v.into(); }

    pub fn failure_mut(&mut self) -> &mut Vec<String> { &mut self.failure }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct ConformanceRequest {
    pub requested_output_format: WireFormat,
    pub message_type: String,
    pub test_category: TestCategory,
    jspb_encoding_options: Option<JspbEncodingConfig>,
    pub print_unknown_fields: bool,
    pub payload: Option<ConformanceRequestNestedPayload>,
    cache_size: u32,
    unknown: Vec<u8>,
}

#[derive(Clone, Debug, PartialEq)]
pub enum ConformanceRequestNestedPayload {
    ProtobufPayload(Vec<u8>),
    JsonPayload(String),
    JspbPayload(String),
    TextPayload(String),
}

impl Message for ConformanceRequest {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                24 => self.requested_output_format = s.read_enum()?,
                34 => self.message_type = s.read_string()?,
                40 => self.test_category = s.read_enum()?,
                50 => {
                    let msg = self.jspb_encoding_options.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                72 => self.print_unknown_fields = s.read_bool()?,
                10 => self.payload = Some(ConformanceRequestNestedPayload::ProtobufPayload(s.read_bytes()?)),
                18 => self.payload = Some(ConformanceRequestNestedPayload::JsonPayload(s.read_string()?)),
                58 => self.payload = Some(ConformanceRequestNestedPayload::JspbPayload(s.read_string()?)),
                66 => self.payload = Some(ConformanceRequestNestedPayload::TextPayload(s.read_string()?)),
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if self.requested_output_format.value() != 0 {
            s.write_raw_1_byte([24])?;
            s.write_enum(self.requested_output_format)?;
        }
        if !self.message_type.is_empty() {
            s.write_raw_1_byte([34])?;
            s.write_string(&self.message_type)?;
        }
        if self.test_category.value() != 0 {
            s.write_raw_1_byte([40])?;
            s.write_enum(self.test_category)?;
        }
        if let Some(v) = &self.jspb_encoding_options {
            s.write_raw_1_byte([50])?;
            s.write_message(v)?;
        }
        if self.print_unknown_fields {
            s.write_raw_1_byte([72])?;
            s.write_bool(self.print_unknown_fields)?;
        }
        if let Some(v) = &self.payload {
            match v {
                ConformanceRequestNestedPayload::ProtobufPayload(v) => {
                    s.write_raw_1_byte([10])?;
                    s.write_bytes(v)?;
                }
                ConformanceRequestNestedPayload::JsonPayload(v) => {
                    s.write_raw_1_byte([18])?;
                    s.write_string(v)?;
                }
                ConformanceRequestNestedPayload::JspbPayload(v) => {
                    s.write_raw_1_byte([58])?;
                    s.write_string(v)?;
                }
                ConformanceRequestNestedPayload::TextPayload(v) => {
                    s.write_raw_1_byte([66])?;
                    s.write_string(v)?;
                }
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if self.requested_output_format.value() != 0 {
            n += 1 + encoded::enum_len(self.requested_output_format);
        }
        if !self.message_type.is_empty() {
            n += 1 + encoded::string_len(&self.message_type);
        }
        if self.test_category.value() != 0 {
            n += 1 + encoded::enum_len(self.test_category);
        }
        if let Some(v) = &self.jspb_encoding_options {
            n += 1 + encoded::message_len(v);
        }
        if self.print_unknown_fields {
            n += 2;
        }
        if let Some(v) = &self.payload {
            match v {
                ConformanceRequestNestedPayload::ProtobufPayload(v) => {
                    n += 1 + encoded::bytes_len(v);
                }
                ConformanceRequestNestedPayload::JsonPayload(v) => {
                    n += 1 + encoded::string_len(v);
                }
                ConformanceRequestNestedPayload::JspbPayload(v) => {
                    n += 1 + encoded::string_len(v);
                }
                ConformanceRequestNestedPayload::TextPayload(v) => {
                    n += 1 + encoded::string_len(v);
                }
            }
        }
        n
    }
}

impl ConformanceRequest {
    pub const fn new() -> ConformanceRequest {
        ConformanceRequest {
            requested_output_format: WireFormat::new(),
            message_type: String::new(),
            test_category: TestCategory::new(),
            jspb_encoding_options: None,
            print_unknown_fields: false,
            payload: None,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static ConformanceRequest {
        static DEFAULT: ConformanceRequest = ConformanceRequest::new();
        &DEFAULT
    }

    pub fn requested_output_format(&self) -> WireFormat { self.requested_output_format }

    pub fn clear_requested_output_format(&mut self) { self.requested_output_format = Default::default(); }

    pub fn set_requested_output_format(&mut self, v: WireFormat) { self.requested_output_format = v; }

    pub fn message_type(&self) -> &str { &self.message_type }

    pub fn clear_message_type(&mut self) { self.message_type = Default::default(); }

    pub fn set_message_type(&mut self, v: String) { self.message_type = v; }

    pub fn message_type_mut(&mut self) -> &mut String { &mut self.message_type }

    pub fn test_category(&self) -> TestCategory { self.test_category }

    pub fn clear_test_category(&mut self) { self.test_category = Default::default(); }

    pub fn set_test_category(&mut self, v: TestCategory) { self.test_category = v; }

    pub fn jspb_encoding_options(&self) -> &JspbEncodingConfig {
        self.jspb_encoding_options.as_ref().unwrap_or_else(|| JspbEncodingConfig::default_instance())
    }

    pub fn clear_jspb_encoding_options(&mut self) { self.jspb_encoding_options = None; }

    pub fn has_jspb_encoding_options(&self) -> bool { self.jspb_encoding_options.is_some() }

    pub fn set_jspb_encoding_options(&mut self, v: JspbEncodingConfig) { self.jspb_encoding_options = Some(v); }

    pub fn jspb_encoding_options_mut(&mut self) -> &mut JspbEncodingConfig {
        self.jspb_encoding_options.get_or_insert_with(Default::default)
    }

    pub fn print_unknown_fields(&self) -> bool { self.print_unknown_fields }

    pub fn clear_print_unknown_fields(&mut self) { self.print_unknown_fields = false; }

    pub fn set_print_unknown_fields(&mut self, v: bool) { self.print_unknown_fields = v; }

    pub fn protobuf_payload(&self) -> &[u8] {
        match &self.payload {
            Some(ConformanceRequestNestedPayload::ProtobufPayload(v)) => v,
            _ => &[],
        }
    }

    pub fn clear_protobuf_payload(&mut self) {
        if let Some(ConformanceRequestNestedPayload::ProtobufPayload(_)) = self.payload {
            self.payload = None;
        }
    }

    pub fn set_protobuf_payload(&mut self, v: Vec<u8>) {
        self.payload = Some(ConformanceRequestNestedPayload::ProtobufPayload(v));
    }

    pub fn protobuf_payload_mut(&mut self) -> &mut Vec<u8> {
        if let Some(ConformanceRequestNestedPayload::ProtobufPayload(ref mut v)) = self.payload {
            return v;
        }
        self.payload = Some(ConformanceRequestNestedPayload::ProtobufPayload(Default::default()));
        if let Some(ConformanceRequestNestedPayload::ProtobufPayload(ref mut v)) = self.payload {
            return v;
        }
        unreachable!()
    }

    pub fn json_payload(&self) -> &str {
        match &self.payload {
            Some(ConformanceRequestNestedPayload::JsonPayload(v)) => v,
            _ => "",
        }
    }

    pub fn clear_json_payload(&mut self) {
        if let Some(ConformanceRequestNestedPayload::JsonPayload(_)) = self.payload {
            self.payload = None;
        }
    }

    pub fn set_json_payload(&mut self, v: String) {
        self.payload = Some(ConformanceRequestNestedPayload::JsonPayload(v));
    }

    pub fn json_payload_mut(&mut self) -> &mut String {
        if let Some(ConformanceRequestNestedPayload::JsonPayload(ref mut v)) = self.payload {
            return v;
        }
        self.payload = Some(ConformanceRequestNestedPayload::JsonPayload(Default::default()));
        if let Some(ConformanceRequestNestedPayload::JsonPayload(ref mut v)) = self.payload {
            return v;
        }
        unreachable!()
    }

    pub fn jspb_payload(&self) -> &str {
        match &self.payload {
            Some(ConformanceRequestNestedPayload::JspbPayload(v)) => v,
            _ => "",
        }
    }

    pub fn clear_jspb_payload(&mut self) {
        if let Some(ConformanceRequestNestedPayload::JspbPayload(_)) = self.payload {
            self.payload = None;
        }
    }

    pub fn set_jspb_payload(&mut self, v: String) {
        self.payload = Some(ConformanceRequestNestedPayload::JspbPayload(v));
    }

    pub fn jspb_payload_mut(&mut self) -> &mut String {
        if let Some(ConformanceRequestNestedPayload::JspbPayload(ref mut v)) = self.payload {
            return v;
        }
        self.payload = Some(ConformanceRequestNestedPayload::JspbPayload(Default::default()));
        if let Some(ConformanceRequestNestedPayload::JspbPayload(ref mut v)) = self.payload {
            return v;
        }
        unreachable!()
    }

    pub fn text_payload(&self) -> &str {
        match &self.payload {
            Some(ConformanceRequestNestedPayload::TextPayload(v)) => v,
            _ => "",
        }
    }

    pub fn clear_text_payload(&mut self) {
        if let Some(ConformanceRequestNestedPayload::TextPayload(_)) = self.payload {
            self.payload = None;
        }
    }

    pub fn set_text_payload(&mut self, v: String) {
        self.payload = Some(ConformanceRequestNestedPayload::TextPayload(v));
    }

    pub fn text_payload_mut(&mut self) -> &mut String {
        if let Some(ConformanceRequestNestedPayload::TextPayload(ref mut v)) = self.payload {
            return v;
        }
        self.payload = Some(ConformanceRequestNestedPayload::TextPayload(Default::default()));
        if let Some(ConformanceRequestNestedPayload::TextPayload(ref mut v)) = self.payload {
            return v;
        }
        unreachable!()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct ConformanceResponse {
    pub result: Option<ConformanceResponseNestedResult>,
    cache_size: u32,
    unknown: Vec<u8>,
}

#[derive(Clone, Debug, PartialEq)]
pub enum ConformanceResponseNestedResult {
    ParseError(String),
    SerializeError(String),
    RuntimeError(String),
    ProtobufPayload(Vec<u8>),
    JsonPayload(String),
    Skipped(String),
    JspbPayload(String),
    TextPayload(String),
}

impl Message for ConformanceResponse {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.result = Some(ConformanceResponseNestedResult::ParseError(s.read_string()?)),
                50 => self.result = Some(ConformanceResponseNestedResult::SerializeError(s.read_string()?)),
                18 => self.result = Some(ConformanceResponseNestedResult::RuntimeError(s.read_string()?)),
                26 => self.result = Some(ConformanceResponseNestedResult::ProtobufPayload(s.read_bytes()?)),
                34 => self.result = Some(ConformanceResponseNestedResult::JsonPayload(s.read_string()?)),
                42 => self.result = Some(ConformanceResponseNestedResult::Skipped(s.read_string()?)),
                58 => self.result = Some(ConformanceResponseNestedResult::JspbPayload(s.read_string()?)),
                66 => self.result = Some(ConformanceResponseNestedResult::TextPayload(s.read_string()?)),
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if let Some(v) = &self.result {
            match v {
                ConformanceResponseNestedResult::ParseError(v) => {
                    s.write_raw_1_byte([10])?;
                    s.write_string(v)?;
                }
                ConformanceResponseNestedResult::SerializeError(v) => {
                    s.write_raw_1_byte([50])?;
                    s.write_string(v)?;
                }
                ConformanceResponseNestedResult::RuntimeError(v) => {
                    s.write_raw_1_byte([18])?;
                    s.write_string(v)?;
                }
                ConformanceResponseNestedResult::ProtobufPayload(v) => {
                    s.write_raw_1_byte([26])?;
                    s.write_bytes(v)?;
                }
                ConformanceResponseNestedResult::JsonPayload(v) => {
                    s.write_raw_1_byte([34])?;
                    s.write_string(v)?;
                }
                ConformanceResponseNestedResult::Skipped(v) => {
                    s.write_raw_1_byte([42])?;
                    s.write_string(v)?;
                }
                ConformanceResponseNestedResult::JspbPayload(v) => {
                    s.write_raw_1_byte([58])?;
                    s.write_string(v)?;
                }
                ConformanceResponseNestedResult::TextPayload(v) => {
                    s.write_raw_1_byte([66])?;
                    s.write_string(v)?;
                }
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if let Some(v) = &self.result {
            match v {
                ConformanceResponseNestedResult::ParseError(v) => {
                    n += 1 + encoded::string_len(v);
                }
                ConformanceResponseNestedResult::SerializeError(v) => {
                    n += 1 + encoded::string_len(v);
                }
                ConformanceResponseNestedResult::RuntimeError(v) => {
                    n += 1 + encoded::string_len(v);
                }
                ConformanceResponseNestedResult::ProtobufPayload(v) => {
                    n += 1 + encoded::bytes_len(v);
                }
                ConformanceResponseNestedResult::JsonPayload(v) => {
                    n += 1 + encoded::string_len(v);
                }
                ConformanceResponseNestedResult::Skipped(v) => {
                    n += 1 + encoded::string_len(v);
                }
                ConformanceResponseNestedResult::JspbPayload(v) => {
                    n += 1 + encoded::string_len(v);
                }
                ConformanceResponseNestedResult::TextPayload(v) => {
                    n += 1 + encoded::string_len(v);
                }
            }
        }
        n
    }
}

impl ConformanceResponse {
    pub const fn new() -> ConformanceResponse {
        ConformanceResponse {
            result: None,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static ConformanceResponse {
        static DEFAULT: ConformanceResponse = ConformanceResponse::new();
        &DEFAULT
    }

    pub fn parse_error(&self) -> &str {
        match &self.result {
            Some(ConformanceResponseNestedResult::ParseError(v)) => v,
            _ => "",
        }
    }

    pub fn clear_parse_error(&mut self) {
        if let Some(ConformanceResponseNestedResult::ParseError(_)) = self.result {
            self.result = None;
        }
    }

    pub fn set_parse_error(&mut self, v: String) {
        self.result = Some(ConformanceResponseNestedResult::ParseError(v));
    }

    pub fn parse_error_mut(&mut self) -> &mut String {
        if let Some(ConformanceResponseNestedResult::ParseError(ref mut v)) = self.result {
            return v;
        }
        self.result = Some(ConformanceResponseNestedResult::ParseError(Default::default()));
        if let Some(ConformanceResponseNestedResult::ParseError(ref mut v)) = self.result {
            return v;
        }
        unreachable!()
    }

    pub fn serialize_error(&self) -> &str {
        match &self.result {
            Some(ConformanceResponseNestedResult::SerializeError(v)) => v,
            _ => "",
        }
    }

    pub fn clear_serialize_error(&mut self) {
        if let Some(ConformanceResponseNestedResult::SerializeError(_)) = self.result {
            self.result = None;
        }
    }

    pub fn set_serialize_error(&mut self, v: String) {
        self.result = Some(ConformanceResponseNestedResult::SerializeError(v));
    }

    pub fn serialize_error_mut(&mut self) -> &mut String {
        if let Some(ConformanceResponseNestedResult::SerializeError(ref mut v)) = self.result {
            return v;
        }
        self.result = Some(ConformanceResponseNestedResult::SerializeError(Default::default()));
        if let Some(ConformanceResponseNestedResult::SerializeError(ref mut v)) = self.result {
            return v;
        }
        unreachable!()
    }

    pub fn runtime_error(&self) -> &str {
        match &self.result {
            Some(ConformanceResponseNestedResult::RuntimeError(v)) => v,
            _ => "",
        }
    }

    pub fn clear_runtime_error(&mut self) {
        if let Some(ConformanceResponseNestedResult::RuntimeError(_)) = self.result {
            self.result = None;
        }
    }

    pub fn set_runtime_error(&mut self, v: String) {
        self.result = Some(ConformanceResponseNestedResult::RuntimeError(v));
    }

    pub fn runtime_error_mut(&mut self) -> &mut String {
        if let Some(ConformanceResponseNestedResult::RuntimeError(ref mut v)) = self.result {
            return v;
        }
        self.result = Some(ConformanceResponseNestedResult::RuntimeError(Default::default()));
        if let Some(ConformanceResponseNestedResult::RuntimeError(ref mut v)) = self.result {
            return v;
        }
        unreachable!()
    }

    pub fn protobuf_payload(&self) -> &[u8] {
        match &self.result {
            Some(ConformanceResponseNestedResult::ProtobufPayload(v)) => v,
            _ => &[],
        }
    }

    pub fn clear_protobuf_payload(&mut self) {
        if let Some(ConformanceResponseNestedResult::ProtobufPayload(_)) = self.result {
            self.result = None;
        }
    }

    pub fn set_protobuf_payload(&mut self, v: Vec<u8>) {
        self.result = Some(ConformanceResponseNestedResult::ProtobufPayload(v));
    }

    pub fn protobuf_payload_mut(&mut self) -> &mut Vec<u8> {
        if let Some(ConformanceResponseNestedResult::ProtobufPayload(ref mut v)) = self.result {
            return v;
        }
        self.result = Some(ConformanceResponseNestedResult::ProtobufPayload(Default::default()));
        if let Some(ConformanceResponseNestedResult::ProtobufPayload(ref mut v)) = self.result {
            return v;
        }
        unreachable!()
    }

    pub fn json_payload(&self) -> &str {
        match &self.result {
            Some(ConformanceResponseNestedResult::JsonPayload(v)) => v,
            _ => "",
        }
    }

    pub fn clear_json_payload(&mut self) {
        if let Some(ConformanceResponseNestedResult::JsonPayload(_)) = self.result {
            self.result = None;
        }
    }

    pub fn set_json_payload(&mut self, v: String) {
        self.result = Some(ConformanceResponseNestedResult::JsonPayload(v));
    }

    pub fn json_payload_mut(&mut self) -> &mut String {
        if let Some(ConformanceResponseNestedResult::JsonPayload(ref mut v)) = self.result {
            return v;
        }
        self.result = Some(ConformanceResponseNestedResult::JsonPayload(Default::default()));
        if let Some(ConformanceResponseNestedResult::JsonPayload(ref mut v)) = self.result {
            return v;
        }
        unreachable!()
    }

    pub fn skipped(&self) -> &str {
        match &self.result {
            Some(ConformanceResponseNestedResult::Skipped(v)) => v,
            _ => "",
        }
    }

    pub fn clear_skipped(&mut self) {
        if let Some(ConformanceResponseNestedResult::Skipped(_)) = self.result {
            self.result = None;
        }
    }

    pub fn set_skipped(&mut self, v: String) {
        self.result = Some(ConformanceResponseNestedResult::Skipped(v));
    }

    pub fn skipped_mut(&mut self) -> &mut String {
        if let Some(ConformanceResponseNestedResult::Skipped(ref mut v)) = self.result {
            return v;
        }
        self.result = Some(ConformanceResponseNestedResult::Skipped(Default::default()));
        if let Some(ConformanceResponseNestedResult::Skipped(ref mut v)) = self.result {
            return v;
        }
        unreachable!()
    }

    pub fn jspb_payload(&self) -> &str {
        match &self.result {
            Some(ConformanceResponseNestedResult::JspbPayload(v)) => v,
            _ => "",
        }
    }

    pub fn clear_jspb_payload(&mut self) {
        if let Some(ConformanceResponseNestedResult::JspbPayload(_)) = self.result {
            self.result = None;
        }
    }

    pub fn set_jspb_payload(&mut self, v: String) {
        self.result = Some(ConformanceResponseNestedResult::JspbPayload(v));
    }

    pub fn jspb_payload_mut(&mut self) -> &mut String {
        if let Some(ConformanceResponseNestedResult::JspbPayload(ref mut v)) = self.result {
            return v;
        }
        self.result = Some(ConformanceResponseNestedResult::JspbPayload(Default::default()));
        if let Some(ConformanceResponseNestedResult::JspbPayload(ref mut v)) = self.result {
            return v;
        }
        unreachable!()
    }

    pub fn text_payload(&self) -> &str {
        match &self.result {
            Some(ConformanceResponseNestedResult::TextPayload(v)) => v,
            _ => "",
        }
    }

    pub fn clear_text_payload(&mut self) {
        if let Some(ConformanceResponseNestedResult::TextPayload(_)) = self.result {
            self.result = None;
        }
    }

    pub fn set_text_payload(&mut self, v: String) {
        self.result = Some(ConformanceResponseNestedResult::TextPayload(v));
    }

    pub fn text_payload_mut(&mut self) -> &mut String {
        if let Some(ConformanceResponseNestedResult::TextPayload(ref mut v)) = self.result {
            return v;
        }
        self.result = Some(ConformanceResponseNestedResult::TextPayload(Default::default()));
        if let Some(ConformanceResponseNestedResult::TextPayload(ref mut v)) = self.result {
            return v;
        }
        unreachable!()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct JspbEncodingConfig {
    pub use_jspb_array_any_format: bool,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for JspbEncodingConfig {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.use_jspb_array_any_format = s.read_bool()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if self.use_jspb_array_any_format {
            s.write_raw_1_byte([8])?;
            s.write_bool(self.use_jspb_array_any_format)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if self.use_jspb_array_any_format {
            n += 2;
        }
        n
    }
}

impl JspbEncodingConfig {
    pub const fn new() -> JspbEncodingConfig {
        JspbEncodingConfig {
            use_jspb_array_any_format: false,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static JspbEncodingConfig {
        static DEFAULT: JspbEncodingConfig = JspbEncodingConfig::new();
        &DEFAULT
    }

    pub fn use_jspb_array_any_format(&self) -> bool { self.use_jspb_array_any_format }

    pub fn clear_use_jspb_array_any_format(&mut self) { self.use_jspb_array_any_format = false; }

    pub fn set_use_jspb_array_any_format(&mut self, v: bool) { self.use_jspb_array_any_format = v; }
}
