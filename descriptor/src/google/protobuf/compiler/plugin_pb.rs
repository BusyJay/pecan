// This file is generated by pecan 0.1.0, DO NOT EDIT!
// @generated
// source: google/protobuf/compiler/plugin.proto

#![allow(non_upper_case_globals)]
#![allow(unused_imports)]

use pecan::{
    EnumType,
    Message,
    Result,
    Buf,
    BufMut,
    CodedInputStream,
    CodedOutputStream,
    CacheSize,
    encoded,
};

use crate::google::protobuf::descriptor_pb as google__protobuf__descriptor_pb;

pub static DESCRIPTOR: &[u8] = &[
    10, 37, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117,
    102, 47, 99, 111, 109, 112, 105, 108, 101, 114, 47, 112, 108, 117, 103, 105,
    110, 46, 112, 114, 111, 116, 111, 18, 24, 103, 111, 111, 103, 108, 101, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 46, 99, 111, 109, 112, 105, 108, 101,
    114, 26, 32, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98,
    117, 102, 47, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 46, 112, 114,
    111, 116, 111, 66, 103, 10, 28, 99, 111, 109, 46, 103, 111, 111, 103, 108,
    101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 99, 111, 109, 112, 105,
    108, 101, 114, 66, 12, 80, 108, 117, 103, 105, 110, 80, 114, 111, 116, 111,
    115, 90, 57, 103, 105, 116, 104, 117, 98, 46, 99, 111, 109, 47, 103, 111,
    108, 97, 110, 103, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 112, 114,
    111, 116, 111, 99, 45, 103, 101, 110, 45, 103, 111, 47, 112, 108, 117, 103,
    105, 110, 59, 112, 108, 117, 103, 105, 110, 95, 103, 111,
];

#[derive(Clone, Debug, Default, PartialEq)]
pub struct Version {
    pub major: i32,
    pub minor: i32,
    pub patch: i32,
    pub suffix: String,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for Version {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.major = s.read_var_i32()?,
                16 => self.minor = s.read_var_i32()?,
                24 => self.patch = s.read_var_i32()?,
                34 => self.suffix = s.read_string()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.major {
            s.write_raw_1_byte([8])?;
            s.write_var_i32(self.major)?;
        }
        if 0 != self.minor {
            s.write_raw_1_byte([16])?;
            s.write_var_i32(self.minor)?;
        }
        if 0 != self.patch {
            s.write_raw_1_byte([24])?;
            s.write_var_i32(self.patch)?;
        }
        if !self.suffix.is_empty() {
            s.write_raw_1_byte([34])?;
            s.write_string(&self.suffix)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.major {
            n += 1 + encoded::var_i32_len(self.major);
        }
        if 0 != self.minor {
            n += 1 + encoded::var_i32_len(self.minor);
        }
        if 0 != self.patch {
            n += 1 + encoded::var_i32_len(self.patch);
        }
        if !self.suffix.is_empty() {
            n += 1 + encoded::string_len(&self.suffix);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct CodeGeneratorRequest {
    pub file_to_generate: Vec<String>,
    pub parameter: String,
    pub proto_file: Vec<google__protobuf__descriptor_pb::FileDescriptorProto>,
    pub compiler_version: Option<Version>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for CodeGeneratorRequest {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.file_to_generate.push(s.read_string()?),
                18 => self.parameter = s.read_string()?,
                122 => s.read_message_to(&mut self.proto_file)?,
                26 => {
                    let msg = self.compiler_version.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.file_to_generate.is_empty() {
            for v in &self.file_to_generate {
                s.write_raw_1_byte([10])?;
                s.write_string(v)?;
            }
        }
        if !self.parameter.is_empty() {
            s.write_raw_1_byte([18])?;
            s.write_string(&self.parameter)?;
        }
        if !self.proto_file.is_empty() {
            for v in &self.proto_file {
                s.write_raw_1_byte([122])?;
                s.write_message(v)?;
            }
        }
        if let Some(v) = &self.compiler_version {
            s.write_raw_1_byte([26])?;
            s.write_message(v)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.file_to_generate.is_empty() {
            n += encoded::arr_string_len(1, &self.file_to_generate);
        }
        if !self.parameter.is_empty() {
            n += 1 + encoded::string_len(&self.parameter);
        }
        if !self.proto_file.is_empty() {
            n += encoded::arr_message_len(1, &self.proto_file);
        }
        if let Some(v) = &self.compiler_version {
            n += 1 + encoded::message_len(v);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct CodeGeneratorResponse {
    pub error: String,
    pub file: Vec<CodeGeneratorResponseNestedFile>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for CodeGeneratorResponse {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.error = s.read_string()?,
                122 => s.read_message_to(&mut self.file)?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.error.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.error)?;
        }
        if !self.file.is_empty() {
            for v in &self.file {
                s.write_raw_1_byte([122])?;
                s.write_message(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.error.is_empty() {
            n += 1 + encoded::string_len(&self.error);
        }
        if !self.file.is_empty() {
            n += encoded::arr_message_len(1, &self.file);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct CodeGeneratorResponseNestedFile {
    pub name: String,
    pub insertion_point: String,
    pub content: String,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for CodeGeneratorResponseNestedFile {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.name = s.read_string()?,
                18 => self.insertion_point = s.read_string()?,
                122 => self.content = s.read_string()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.name.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.name)?;
        }
        if !self.insertion_point.is_empty() {
            s.write_raw_1_byte([18])?;
            s.write_string(&self.insertion_point)?;
        }
        if !self.content.is_empty() {
            s.write_raw_1_byte([122])?;
            s.write_string(&self.content)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.name.is_empty() {
            n += 1 + encoded::string_len(&self.name);
        }
        if !self.insertion_point.is_empty() {
            n += 1 + encoded::string_len(&self.insertion_point);
        }
        if !self.content.is_empty() {
            n += 1 + encoded::string_len(&self.content);
        }
        n
    }
}
