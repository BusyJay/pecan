// This file is generated by pecan 0.1.0, DO NOT EDIT!
// @generated
// source: google/protobuf/compiler/plugin.proto

#![allow(non_upper_case_globals)]
#![allow(unused_imports)]

use pecan::{
    EnumType,
    Message,
    Result,
    Buf,
    BufMut,
    CodedInputStream,
    CodedOutputStream,
    encoded,
};

use crate::google::protobuf::descriptor_pb as google__protobuf__descriptor_pb;

pub static DESCRIPTOR: &[u8] = &[
    10, 37, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117,
    102, 47, 99, 111, 109, 112, 105, 108, 101, 114, 47, 112, 108, 117, 103, 105,
    110, 46, 112, 114, 111, 116, 111, 18, 24, 103, 111, 111, 103, 108, 101, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 46, 99, 111, 109, 112, 105, 108, 101,
    114, 26, 32, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98,
    117, 102, 47, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 46, 112, 114,
    111, 116, 111, 66, 103, 10, 28, 99, 111, 109, 46, 103, 111, 111, 103, 108,
    101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 99, 111, 109, 112, 105,
    108, 101, 114, 66, 12, 80, 108, 117, 103, 105, 110, 80, 114, 111, 116, 111,
    115, 90, 57, 103, 105, 116, 104, 117, 98, 46, 99, 111, 109, 47, 103, 111,
    108, 97, 110, 103, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 112, 114,
    111, 116, 111, 99, 45, 103, 101, 110, 45, 103, 111, 47, 112, 108, 117, 103,
    105, 110, 59, 112, 108, 117, 103, 105, 110, 95, 103, 111,
];

#[derive(Clone, Debug, Default, PartialEq)]
pub struct Version {
    major: Option<i32>,
    minor: Option<i32>,
    patch: Option<i32>,
    suffix: Option<String>,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for Version {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.major = Some(s.read_var_i32()?),
                16 => self.minor = Some(s.read_var_i32()?),
                24 => self.patch = Some(s.read_var_i32()?),
                34 => self.suffix = Some(s.read_string()?),
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if let Some(v) = self.major {
            s.write_raw_1_byte([8])?;
            s.write_var_i32(v)?;
        }
        if let Some(v) = self.minor {
            s.write_raw_1_byte([16])?;
            s.write_var_i32(v)?;
        }
        if let Some(v) = self.patch {
            s.write_raw_1_byte([24])?;
            s.write_var_i32(v)?;
        }
        if let Some(v) = &self.suffix {
            s.write_raw_1_byte([34])?;
            s.write_string(v)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if let Some(v) = self.major {
            n += 1 + encoded::var_i32_len(v);
        }
        if let Some(v) = self.minor {
            n += 1 + encoded::var_i32_len(v);
        }
        if let Some(v) = self.patch {
            n += 1 + encoded::var_i32_len(v);
        }
        if let Some(v) = &self.suffix {
            n += 1 + encoded::string_len(v);
        }
        n
    }
}

impl Version {
    pub const fn new() -> Version {
        Version {
            major: None,
            minor: None,
            patch: None,
            suffix: None,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static Version {
        static DEFAULT: Version = Version::new();
        &DEFAULT
    }

    pub fn major(&self) -> i32 {
        self.major.unwrap_or_default()
    }

    pub fn clear_major(&mut self) { self.major = None; }

    pub fn has_major(&self) -> bool { self.major.is_some() }

    pub fn set_major(&mut self, v: i32) { self.major = Some(v); }

    pub fn minor(&self) -> i32 {
        self.minor.unwrap_or_default()
    }

    pub fn clear_minor(&mut self) { self.minor = None; }

    pub fn has_minor(&self) -> bool { self.minor.is_some() }

    pub fn set_minor(&mut self, v: i32) { self.minor = Some(v); }

    pub fn patch(&self) -> i32 {
        self.patch.unwrap_or_default()
    }

    pub fn clear_patch(&mut self) { self.patch = None; }

    pub fn has_patch(&self) -> bool { self.patch.is_some() }

    pub fn set_patch(&mut self, v: i32) { self.patch = Some(v); }

    pub fn suffix(&self) -> &str {
        self.suffix.as_ref().map_or("", |s| s.as_str())
    }

    pub fn clear_suffix(&mut self) { self.suffix = None; }

    pub fn has_suffix(&self) -> bool { self.suffix.is_some() }

    pub fn set_suffix(&mut self, v: String) { self.suffix = Some(v); }

    pub fn suffix_mut(&mut self) -> &mut String {
        self.suffix.get_or_insert_with(Default::default)
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct CodeGeneratorRequest {
    file_to_generate: Vec<String>,
    parameter: Option<String>,
    proto_file: Vec<google__protobuf__descriptor_pb::FileDescriptorProto>,
    compiler_version: Option<Version>,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for CodeGeneratorRequest {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.file_to_generate.push(s.read_string()?),
                18 => self.parameter = Some(s.read_string()?),
                122 => s.read_message_to(&mut self.proto_file)?,
                26 => {
                    let msg = self.compiler_version.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.file_to_generate.is_empty() {
            for v in &self.file_to_generate {
                s.write_raw_1_byte([10])?;
                s.write_string(v)?;
            }
        }
        if let Some(v) = &self.parameter {
            s.write_raw_1_byte([18])?;
            s.write_string(v)?;
        }
        if !self.proto_file.is_empty() {
            for v in &self.proto_file {
                s.write_raw_1_byte([122])?;
                s.write_message(v)?;
            }
        }
        if let Some(v) = &self.compiler_version {
            s.write_raw_1_byte([26])?;
            s.write_message(v)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.file_to_generate.is_empty() {
            n += encoded::arr_string_len(1, &self.file_to_generate);
        }
        if let Some(v) = &self.parameter {
            n += 1 + encoded::string_len(v);
        }
        if !self.proto_file.is_empty() {
            n += encoded::arr_message_len(1, &self.proto_file);
        }
        if let Some(v) = &self.compiler_version {
            n += 1 + encoded::message_len(v);
        }
        n
    }
}

impl CodeGeneratorRequest {
    pub const fn new() -> CodeGeneratorRequest {
        CodeGeneratorRequest {
            file_to_generate: Vec::new(),
            parameter: None,
            proto_file: Vec::new(),
            compiler_version: None,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static CodeGeneratorRequest {
        static DEFAULT: CodeGeneratorRequest = CodeGeneratorRequest::new();
        &DEFAULT
    }

    pub fn file_to_generate(&self) -> &[String] { &self.file_to_generate }

    pub fn clear_file_to_generate(&mut self) { self.file_to_generate.clear(); }

    pub fn set_file_to_generate(&mut self, v: impl Into<Vec<String>>) { self.file_to_generate = v.into(); }

    pub fn file_to_generate_mut(&mut self) -> &mut Vec<String> { &mut self.file_to_generate }

    pub fn parameter(&self) -> &str {
        self.parameter.as_ref().map_or("", |s| s.as_str())
    }

    pub fn clear_parameter(&mut self) { self.parameter = None; }

    pub fn has_parameter(&self) -> bool { self.parameter.is_some() }

    pub fn set_parameter(&mut self, v: String) { self.parameter = Some(v); }

    pub fn parameter_mut(&mut self) -> &mut String {
        self.parameter.get_or_insert_with(Default::default)
    }

    pub fn proto_file(&self) -> &[google__protobuf__descriptor_pb::FileDescriptorProto] { &self.proto_file }

    pub fn clear_proto_file(&mut self) { self.proto_file.clear(); }

    pub fn set_proto_file(&mut self, v: impl Into<Vec<google__protobuf__descriptor_pb::FileDescriptorProto>>) { self.proto_file = v.into(); }

    pub fn proto_file_mut(&mut self) -> &mut Vec<google__protobuf__descriptor_pb::FileDescriptorProto> { &mut self.proto_file }

    pub fn compiler_version(&self) -> &Version {
        self.compiler_version.as_ref().unwrap_or_else(|| Version::default_instance())
    }

    pub fn clear_compiler_version(&mut self) { self.compiler_version = None; }

    pub fn has_compiler_version(&self) -> bool { self.compiler_version.is_some() }

    pub fn set_compiler_version(&mut self, v: Version) { self.compiler_version = Some(v); }

    pub fn compiler_version_mut(&mut self) -> &mut Version {
        self.compiler_version.get_or_insert_with(Default::default)
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct CodeGeneratorResponse {
    error: Option<String>,
    file: Vec<CodeGeneratorResponseNestedFile>,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for CodeGeneratorResponse {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.error = Some(s.read_string()?),
                122 => s.read_message_to(&mut self.file)?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if let Some(v) = &self.error {
            s.write_raw_1_byte([10])?;
            s.write_string(v)?;
        }
        if !self.file.is_empty() {
            for v in &self.file {
                s.write_raw_1_byte([122])?;
                s.write_message(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if let Some(v) = &self.error {
            n += 1 + encoded::string_len(v);
        }
        if !self.file.is_empty() {
            n += encoded::arr_message_len(1, &self.file);
        }
        n
    }
}

impl CodeGeneratorResponse {
    pub const fn new() -> CodeGeneratorResponse {
        CodeGeneratorResponse {
            error: None,
            file: Vec::new(),
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static CodeGeneratorResponse {
        static DEFAULT: CodeGeneratorResponse = CodeGeneratorResponse::new();
        &DEFAULT
    }

    pub fn error(&self) -> &str {
        self.error.as_ref().map_or("", |s| s.as_str())
    }

    pub fn clear_error(&mut self) { self.error = None; }

    pub fn has_error(&self) -> bool { self.error.is_some() }

    pub fn set_error(&mut self, v: String) { self.error = Some(v); }

    pub fn error_mut(&mut self) -> &mut String {
        self.error.get_or_insert_with(Default::default)
    }

    pub fn file(&self) -> &[CodeGeneratorResponseNestedFile] { &self.file }

    pub fn clear_file(&mut self) { self.file.clear(); }

    pub fn set_file(&mut self, v: impl Into<Vec<CodeGeneratorResponseNestedFile>>) { self.file = v.into(); }

    pub fn file_mut(&mut self) -> &mut Vec<CodeGeneratorResponseNestedFile> { &mut self.file }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct CodeGeneratorResponseNestedFile {
    name: Option<String>,
    insertion_point: Option<String>,
    content: Option<String>,
    cache_size: u32,
    unknown: Vec<u8>,
}

impl Message for CodeGeneratorResponseNestedFile {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.name = Some(s.read_string()?),
                18 => self.insertion_point = Some(s.read_string()?),
                122 => self.content = Some(s.read_string()?),
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if let Some(v) = &self.name {
            s.write_raw_1_byte([10])?;
            s.write_string(v)?;
        }
        if let Some(v) = &self.insertion_point {
            s.write_raw_1_byte([18])?;
            s.write_string(v)?;
        }
        if let Some(v) = &self.content {
            s.write_raw_1_byte([122])?;
            s.write_string(v)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if let Some(v) = &self.name {
            n += 1 + encoded::string_len(v);
        }
        if let Some(v) = &self.insertion_point {
            n += 1 + encoded::string_len(v);
        }
        if let Some(v) = &self.content {
            n += 1 + encoded::string_len(v);
        }
        n
    }
}

impl CodeGeneratorResponseNestedFile {
    pub const fn new() -> CodeGeneratorResponseNestedFile {
        CodeGeneratorResponseNestedFile {
            name: None,
            insertion_point: None,
            content: None,
            cache_size: 0,
            unknown: Vec::new(),
        }
    }

    pub fn default_instance() -> &'static CodeGeneratorResponseNestedFile {
        static DEFAULT: CodeGeneratorResponseNestedFile = CodeGeneratorResponseNestedFile::new();
        &DEFAULT
    }

    pub fn name(&self) -> &str {
        self.name.as_ref().map_or("", |s| s.as_str())
    }

    pub fn clear_name(&mut self) { self.name = None; }

    pub fn has_name(&self) -> bool { self.name.is_some() }

    pub fn set_name(&mut self, v: String) { self.name = Some(v); }

    pub fn name_mut(&mut self) -> &mut String {
        self.name.get_or_insert_with(Default::default)
    }

    pub fn insertion_point(&self) -> &str {
        self.insertion_point.as_ref().map_or("", |s| s.as_str())
    }

    pub fn clear_insertion_point(&mut self) { self.insertion_point = None; }

    pub fn has_insertion_point(&self) -> bool { self.insertion_point.is_some() }

    pub fn set_insertion_point(&mut self, v: String) { self.insertion_point = Some(v); }

    pub fn insertion_point_mut(&mut self) -> &mut String {
        self.insertion_point.get_or_insert_with(Default::default)
    }

    pub fn content(&self) -> &str {
        self.content.as_ref().map_or("", |s| s.as_str())
    }

    pub fn clear_content(&mut self) { self.content = None; }

    pub fn has_content(&self) -> bool { self.content.is_some() }

    pub fn set_content(&mut self, v: String) { self.content = Some(v); }

    pub fn content_mut(&mut self) -> &mut String {
        self.content.get_or_insert_with(Default::default)
    }
}
