// This file is generated by pecan 0.1.0, DO NOT EDIT!
// @generated
// source: google/protobuf/descriptor.proto

#![allow(non_upper_case_globals)]
#![allow(unused_imports)]

use pecan::{
    EnumType,
    Message,
    Result,
    Buf,
    BufMut,
    CodedInputStream,
    CodedOutputStream,
    CacheSize,
    encoded,
};

pub static DESCRIPTOR: &[u8] = &[
    10, 32, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117,
    102, 47, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 46, 112, 114, 111,
    116, 111, 18, 15, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111,
    98, 117, 102, 66, 143, 1, 10, 19, 99, 111, 109, 46, 103, 111, 111, 103,
    108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 66, 16, 68, 101, 115,
    99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 115, 72, 1, 90,
    62, 103, 105, 116, 104, 117, 98, 46, 99, 111, 109, 47, 103, 111, 108, 97,
    110, 103, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 112, 114, 111, 116,
    111, 99, 45, 103, 101, 110, 45, 103, 111, 47, 100, 101, 115, 99, 114, 105,
    112, 116, 111, 114, 59, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 248,
    1, 1, 162, 2, 3, 71, 80, 66, 170, 2, 26, 71, 111, 111, 103, 108,
    101, 46, 80, 114, 111, 116, 111, 98, 117, 102, 46, 82, 101, 102, 108, 101,
    99, 116, 105, 111, 110,
];

#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]
pub struct FieldDescriptorProtoNestedType(i32);

impl FieldDescriptorProtoNestedType {
    pub const TypeDouble: FieldDescriptorProtoNestedType = FieldDescriptorProtoNestedType(1);
    pub const TypeFloat: FieldDescriptorProtoNestedType = FieldDescriptorProtoNestedType(2);
    pub const TypeInt64: FieldDescriptorProtoNestedType = FieldDescriptorProtoNestedType(3);
    pub const TypeUint64: FieldDescriptorProtoNestedType = FieldDescriptorProtoNestedType(4);
    pub const TypeInt32: FieldDescriptorProtoNestedType = FieldDescriptorProtoNestedType(5);
    pub const TypeFixed64: FieldDescriptorProtoNestedType = FieldDescriptorProtoNestedType(6);
    pub const TypeFixed32: FieldDescriptorProtoNestedType = FieldDescriptorProtoNestedType(7);
    pub const TypeBool: FieldDescriptorProtoNestedType = FieldDescriptorProtoNestedType(8);
    pub const TypeString: FieldDescriptorProtoNestedType = FieldDescriptorProtoNestedType(9);
    pub const TypeGroup: FieldDescriptorProtoNestedType = FieldDescriptorProtoNestedType(10);
    pub const TypeMessage: FieldDescriptorProtoNestedType = FieldDescriptorProtoNestedType(11);
    pub const TypeBytes: FieldDescriptorProtoNestedType = FieldDescriptorProtoNestedType(12);
    pub const TypeUint32: FieldDescriptorProtoNestedType = FieldDescriptorProtoNestedType(13);
    pub const TypeEnum: FieldDescriptorProtoNestedType = FieldDescriptorProtoNestedType(14);
    pub const TypeSfixed32: FieldDescriptorProtoNestedType = FieldDescriptorProtoNestedType(15);
    pub const TypeSfixed64: FieldDescriptorProtoNestedType = FieldDescriptorProtoNestedType(16);
    pub const TypeSint32: FieldDescriptorProtoNestedType = FieldDescriptorProtoNestedType(17);
    pub const TypeSint64: FieldDescriptorProtoNestedType = FieldDescriptorProtoNestedType(18);
}

impl From<i32> for FieldDescriptorProtoNestedType {
    #[inline]
    fn from(u: i32) -> FieldDescriptorProtoNestedType {
        FieldDescriptorProtoNestedType(u)
    }
}

impl EnumType for FieldDescriptorProtoNestedType {
    #[inline]
    fn values() -> &'static [FieldDescriptorProtoNestedType] {
        &[
            FieldDescriptorProtoNestedType::TypeDouble,
            FieldDescriptorProtoNestedType::TypeFloat,
            FieldDescriptorProtoNestedType::TypeInt64,
            FieldDescriptorProtoNestedType::TypeUint64,
            FieldDescriptorProtoNestedType::TypeInt32,
            FieldDescriptorProtoNestedType::TypeFixed64,
            FieldDescriptorProtoNestedType::TypeFixed32,
            FieldDescriptorProtoNestedType::TypeBool,
            FieldDescriptorProtoNestedType::TypeString,
            FieldDescriptorProtoNestedType::TypeGroup,
            FieldDescriptorProtoNestedType::TypeMessage,
            FieldDescriptorProtoNestedType::TypeBytes,
            FieldDescriptorProtoNestedType::TypeUint32,
            FieldDescriptorProtoNestedType::TypeEnum,
            FieldDescriptorProtoNestedType::TypeSfixed32,
            FieldDescriptorProtoNestedType::TypeSfixed64,
            FieldDescriptorProtoNestedType::TypeSint32,
            FieldDescriptorProtoNestedType::TypeSint64,
        ]
    }

    #[inline]
    fn value(&self) -> i32 { self.0 }
}

#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]
pub struct FieldDescriptorProtoNestedLabel(i32);

impl FieldDescriptorProtoNestedLabel {
    pub const LabelOptional: FieldDescriptorProtoNestedLabel = FieldDescriptorProtoNestedLabel(1);
    pub const LabelRequired: FieldDescriptorProtoNestedLabel = FieldDescriptorProtoNestedLabel(2);
    pub const LabelRepeated: FieldDescriptorProtoNestedLabel = FieldDescriptorProtoNestedLabel(3);
}

impl From<i32> for FieldDescriptorProtoNestedLabel {
    #[inline]
    fn from(u: i32) -> FieldDescriptorProtoNestedLabel {
        FieldDescriptorProtoNestedLabel(u)
    }
}

impl EnumType for FieldDescriptorProtoNestedLabel {
    #[inline]
    fn values() -> &'static [FieldDescriptorProtoNestedLabel] {
        &[
            FieldDescriptorProtoNestedLabel::LabelOptional,
            FieldDescriptorProtoNestedLabel::LabelRequired,
            FieldDescriptorProtoNestedLabel::LabelRepeated,
        ]
    }

    #[inline]
    fn value(&self) -> i32 { self.0 }
}

#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]
pub struct FileOptionsNestedOptimizeMode(i32);

impl FileOptionsNestedOptimizeMode {
    pub const Speed: FileOptionsNestedOptimizeMode = FileOptionsNestedOptimizeMode(1);
    pub const CodeSize: FileOptionsNestedOptimizeMode = FileOptionsNestedOptimizeMode(2);
    pub const LiteRuntime: FileOptionsNestedOptimizeMode = FileOptionsNestedOptimizeMode(3);
}

impl From<i32> for FileOptionsNestedOptimizeMode {
    #[inline]
    fn from(u: i32) -> FileOptionsNestedOptimizeMode {
        FileOptionsNestedOptimizeMode(u)
    }
}

impl EnumType for FileOptionsNestedOptimizeMode {
    #[inline]
    fn values() -> &'static [FileOptionsNestedOptimizeMode] {
        &[
            FileOptionsNestedOptimizeMode::Speed,
            FileOptionsNestedOptimizeMode::CodeSize,
            FileOptionsNestedOptimizeMode::LiteRuntime,
        ]
    }

    #[inline]
    fn value(&self) -> i32 { self.0 }
}

#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]
pub struct FieldOptionsNestedCType(i32);

impl FieldOptionsNestedCType {
    pub const String: FieldOptionsNestedCType = FieldOptionsNestedCType(0);
    pub const Cord: FieldOptionsNestedCType = FieldOptionsNestedCType(1);
    pub const StringPiece: FieldOptionsNestedCType = FieldOptionsNestedCType(2);
}

impl From<i32> for FieldOptionsNestedCType {
    #[inline]
    fn from(u: i32) -> FieldOptionsNestedCType {
        FieldOptionsNestedCType(u)
    }
}

impl EnumType for FieldOptionsNestedCType {
    #[inline]
    fn values() -> &'static [FieldOptionsNestedCType] {
        &[
            FieldOptionsNestedCType::String,
            FieldOptionsNestedCType::Cord,
            FieldOptionsNestedCType::StringPiece,
        ]
    }

    #[inline]
    fn value(&self) -> i32 { self.0 }
}

#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]
pub struct FieldOptionsNestedJsType(i32);

impl FieldOptionsNestedJsType {
    pub const JsNormal: FieldOptionsNestedJsType = FieldOptionsNestedJsType(0);
    pub const JsString: FieldOptionsNestedJsType = FieldOptionsNestedJsType(1);
    pub const JsNumber: FieldOptionsNestedJsType = FieldOptionsNestedJsType(2);
}

impl From<i32> for FieldOptionsNestedJsType {
    #[inline]
    fn from(u: i32) -> FieldOptionsNestedJsType {
        FieldOptionsNestedJsType(u)
    }
}

impl EnumType for FieldOptionsNestedJsType {
    #[inline]
    fn values() -> &'static [FieldOptionsNestedJsType] {
        &[
            FieldOptionsNestedJsType::JsNormal,
            FieldOptionsNestedJsType::JsString,
            FieldOptionsNestedJsType::JsNumber,
        ]
    }

    #[inline]
    fn value(&self) -> i32 { self.0 }
}

#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]
pub struct MethodOptionsNestedIdempotencyLevel(i32);

impl MethodOptionsNestedIdempotencyLevel {
    pub const IdempotencyUnknown: MethodOptionsNestedIdempotencyLevel = MethodOptionsNestedIdempotencyLevel(0);
    pub const NoSideEffects: MethodOptionsNestedIdempotencyLevel = MethodOptionsNestedIdempotencyLevel(1);
    pub const Idempotent: MethodOptionsNestedIdempotencyLevel = MethodOptionsNestedIdempotencyLevel(2);
}

impl From<i32> for MethodOptionsNestedIdempotencyLevel {
    #[inline]
    fn from(u: i32) -> MethodOptionsNestedIdempotencyLevel {
        MethodOptionsNestedIdempotencyLevel(u)
    }
}

impl EnumType for MethodOptionsNestedIdempotencyLevel {
    #[inline]
    fn values() -> &'static [MethodOptionsNestedIdempotencyLevel] {
        &[
            MethodOptionsNestedIdempotencyLevel::IdempotencyUnknown,
            MethodOptionsNestedIdempotencyLevel::NoSideEffects,
            MethodOptionsNestedIdempotencyLevel::Idempotent,
        ]
    }

    #[inline]
    fn value(&self) -> i32 { self.0 }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct FileDescriptorSet {
    pub file: Vec<FileDescriptorProto>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for FileDescriptorSet {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => s.read_message_to(&mut self.file)?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.file.is_empty() {
            for v in &self.file {
                s.write_raw_1_byte([10])?;
                s.write_message(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.file.is_empty() {
            n += encoded::arr_message_len(1, &self.file);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct FileDescriptorProto {
    pub name: String,
    pub package: String,
    pub dependency: Vec<String>,
    pub public_dependency: Vec<i32>,
    pub weak_dependency: Vec<i32>,
    pub message_type: Vec<DescriptorProto>,
    pub enum_type: Vec<EnumDescriptorProto>,
    pub service: Vec<ServiceDescriptorProto>,
    pub extension: Vec<FieldDescriptorProto>,
    pub options: Option<FileOptions>,
    pub source_code_info: Option<SourceCodeInfo>,
    pub syntax: String,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for FileDescriptorProto {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.name = s.read_string()?,
                18 => self.package = s.read_string()?,
                26 => self.dependency.push(s.read_string()?),
                80 => self.public_dependency.push(s.read_var_i32()?),
                82 => s.read_var_i32_array(&mut self.public_dependency)?,
                88 => self.weak_dependency.push(s.read_var_i32()?),
                90 => s.read_var_i32_array(&mut self.weak_dependency)?,
                34 => s.read_message_to(&mut self.message_type)?,
                42 => s.read_message_to(&mut self.enum_type)?,
                50 => s.read_message_to(&mut self.service)?,
                58 => s.read_message_to(&mut self.extension)?,
                66 => {
                    let msg = self.options.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                74 => {
                    let msg = self.source_code_info.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                98 => self.syntax = s.read_string()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.name.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.name)?;
        }
        if !self.package.is_empty() {
            s.write_raw_1_byte([18])?;
            s.write_string(&self.package)?;
        }
        if !self.dependency.is_empty() {
            for v in &self.dependency {
                s.write_raw_1_byte([26])?;
                s.write_string(v)?;
            }
        }
        if !self.public_dependency.is_empty() {
            s.write_raw_1_byte([82])?;
            s.write_var_i32_array(&self.public_dependency)?;
        }
        if !self.weak_dependency.is_empty() {
            s.write_raw_1_byte([90])?;
            s.write_var_i32_array(&self.weak_dependency)?;
        }
        if !self.message_type.is_empty() {
            for v in &self.message_type {
                s.write_raw_1_byte([34])?;
                s.write_message(v)?;
            }
        }
        if !self.enum_type.is_empty() {
            for v in &self.enum_type {
                s.write_raw_1_byte([42])?;
                s.write_message(v)?;
            }
        }
        if !self.service.is_empty() {
            for v in &self.service {
                s.write_raw_1_byte([50])?;
                s.write_message(v)?;
            }
        }
        if !self.extension.is_empty() {
            for v in &self.extension {
                s.write_raw_1_byte([58])?;
                s.write_message(v)?;
            }
        }
        if let Some(v) = &self.options {
            s.write_raw_1_byte([66])?;
            s.write_message(v)?;
        }
        if let Some(v) = &self.source_code_info {
            s.write_raw_1_byte([74])?;
            s.write_message(v)?;
        }
        if !self.syntax.is_empty() {
            s.write_raw_1_byte([98])?;
            s.write_string(&self.syntax)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.name.is_empty() {
            n += 1 + encoded::string_len(&self.name);
        }
        if !self.package.is_empty() {
            n += 1 + encoded::string_len(&self.package);
        }
        if !self.dependency.is_empty() {
            n += encoded::arr_string_len(1, &self.dependency);
        }
        if !self.public_dependency.is_empty() {
            n += 1 + encoded::arr_var_i32_len(&self.public_dependency);
        }
        if !self.weak_dependency.is_empty() {
            n += 1 + encoded::arr_var_i32_len(&self.weak_dependency);
        }
        if !self.message_type.is_empty() {
            n += encoded::arr_message_len(1, &self.message_type);
        }
        if !self.enum_type.is_empty() {
            n += encoded::arr_message_len(1, &self.enum_type);
        }
        if !self.service.is_empty() {
            n += encoded::arr_message_len(1, &self.service);
        }
        if !self.extension.is_empty() {
            n += encoded::arr_message_len(1, &self.extension);
        }
        if let Some(v) = &self.options {
            n += 1 + encoded::message_len(v);
        }
        if let Some(v) = &self.source_code_info {
            n += 1 + encoded::message_len(v);
        }
        if !self.syntax.is_empty() {
            n += 1 + encoded::string_len(&self.syntax);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct DescriptorProto {
    pub name: String,
    pub field: Vec<FieldDescriptorProto>,
    pub extension: Vec<FieldDescriptorProto>,
    pub nested_type: Vec<DescriptorProto>,
    pub enum_type: Vec<EnumDescriptorProto>,
    pub extension_range: Vec<DescriptorProtoNestedExtensionRange>,
    pub oneof_decl: Vec<OneofDescriptorProto>,
    pub options: Option<MessageOptions>,
    pub reserved_range: Vec<DescriptorProtoNestedReservedRange>,
    pub reserved_name: Vec<String>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for DescriptorProto {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.name = s.read_string()?,
                18 => s.read_message_to(&mut self.field)?,
                50 => s.read_message_to(&mut self.extension)?,
                26 => s.read_message_to(&mut self.nested_type)?,
                34 => s.read_message_to(&mut self.enum_type)?,
                42 => s.read_message_to(&mut self.extension_range)?,
                66 => s.read_message_to(&mut self.oneof_decl)?,
                58 => {
                    let msg = self.options.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                74 => s.read_message_to(&mut self.reserved_range)?,
                82 => self.reserved_name.push(s.read_string()?),
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.name.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.name)?;
        }
        if !self.field.is_empty() {
            for v in &self.field {
                s.write_raw_1_byte([18])?;
                s.write_message(v)?;
            }
        }
        if !self.extension.is_empty() {
            for v in &self.extension {
                s.write_raw_1_byte([50])?;
                s.write_message(v)?;
            }
        }
        if !self.nested_type.is_empty() {
            for v in &self.nested_type {
                s.write_raw_1_byte([26])?;
                s.write_message(v)?;
            }
        }
        if !self.enum_type.is_empty() {
            for v in &self.enum_type {
                s.write_raw_1_byte([34])?;
                s.write_message(v)?;
            }
        }
        if !self.extension_range.is_empty() {
            for v in &self.extension_range {
                s.write_raw_1_byte([42])?;
                s.write_message(v)?;
            }
        }
        if !self.oneof_decl.is_empty() {
            for v in &self.oneof_decl {
                s.write_raw_1_byte([66])?;
                s.write_message(v)?;
            }
        }
        if let Some(v) = &self.options {
            s.write_raw_1_byte([58])?;
            s.write_message(v)?;
        }
        if !self.reserved_range.is_empty() {
            for v in &self.reserved_range {
                s.write_raw_1_byte([74])?;
                s.write_message(v)?;
            }
        }
        if !self.reserved_name.is_empty() {
            for v in &self.reserved_name {
                s.write_raw_1_byte([82])?;
                s.write_string(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.name.is_empty() {
            n += 1 + encoded::string_len(&self.name);
        }
        if !self.field.is_empty() {
            n += encoded::arr_message_len(1, &self.field);
        }
        if !self.extension.is_empty() {
            n += encoded::arr_message_len(1, &self.extension);
        }
        if !self.nested_type.is_empty() {
            n += encoded::arr_message_len(1, &self.nested_type);
        }
        if !self.enum_type.is_empty() {
            n += encoded::arr_message_len(1, &self.enum_type);
        }
        if !self.extension_range.is_empty() {
            n += encoded::arr_message_len(1, &self.extension_range);
        }
        if !self.oneof_decl.is_empty() {
            n += encoded::arr_message_len(1, &self.oneof_decl);
        }
        if let Some(v) = &self.options {
            n += 1 + encoded::message_len(v);
        }
        if !self.reserved_range.is_empty() {
            n += encoded::arr_message_len(1, &self.reserved_range);
        }
        if !self.reserved_name.is_empty() {
            n += encoded::arr_string_len(1, &self.reserved_name);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct DescriptorProtoNestedExtensionRange {
    pub start: i32,
    pub end: i32,
    pub options: Option<ExtensionRangeOptions>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for DescriptorProtoNestedExtensionRange {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.start = s.read_var_i32()?,
                16 => self.end = s.read_var_i32()?,
                26 => {
                    let msg = self.options.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.start {
            s.write_raw_1_byte([8])?;
            s.write_var_i32(self.start)?;
        }
        if 0 != self.end {
            s.write_raw_1_byte([16])?;
            s.write_var_i32(self.end)?;
        }
        if let Some(v) = &self.options {
            s.write_raw_1_byte([26])?;
            s.write_message(v)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.start {
            n += 1 + encoded::var_i32_len(self.start);
        }
        if 0 != self.end {
            n += 1 + encoded::var_i32_len(self.end);
        }
        if let Some(v) = &self.options {
            n += 1 + encoded::message_len(v);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct DescriptorProtoNestedReservedRange {
    pub start: i32,
    pub end: i32,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for DescriptorProtoNestedReservedRange {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.start = s.read_var_i32()?,
                16 => self.end = s.read_var_i32()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.start {
            s.write_raw_1_byte([8])?;
            s.write_var_i32(self.start)?;
        }
        if 0 != self.end {
            s.write_raw_1_byte([16])?;
            s.write_var_i32(self.end)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.start {
            n += 1 + encoded::var_i32_len(self.start);
        }
        if 0 != self.end {
            n += 1 + encoded::var_i32_len(self.end);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct ExtensionRangeOptions {
    pub uninterpreted_option: Vec<UninterpretedOption>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for ExtensionRangeOptions {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                7994 => s.read_message_to(&mut self.uninterpreted_option)?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.uninterpreted_option.is_empty() {
            for v in &self.uninterpreted_option {
                s.write_raw_2_byte([186, 62])?;
                s.write_message(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.uninterpreted_option.is_empty() {
            n += encoded::arr_message_len(2, &self.uninterpreted_option);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct FieldDescriptorProto {
    pub name: String,
    pub number: i32,
    pub label: FieldDescriptorProtoNestedLabel,
    pub r#type: FieldDescriptorProtoNestedType,
    pub type_name: String,
    pub extendee: String,
    pub default_value: String,
    pub oneof_index: i32,
    pub json_name: String,
    pub options: Option<FieldOptions>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for FieldDescriptorProto {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.name = s.read_string()?,
                24 => self.number = s.read_var_i32()?,
                32 => self.label = s.read_enum()?,
                40 => self.r#type = s.read_enum()?,
                50 => self.type_name = s.read_string()?,
                18 => self.extendee = s.read_string()?,
                58 => self.default_value = s.read_string()?,
                72 => self.oneof_index = s.read_var_i32()?,
                82 => self.json_name = s.read_string()?,
                66 => {
                    let msg = self.options.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.name.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.name)?;
        }
        if 0 != self.number {
            s.write_raw_1_byte([24])?;
            s.write_var_i32(self.number)?;
        }
        if self.label.value() != 0 {
            s.write_raw_1_byte([32])?;
            s.write_enum(self.label)?;
        }
        if self.r#type.value() != 0 {
            s.write_raw_1_byte([40])?;
            s.write_enum(self.r#type)?;
        }
        if !self.type_name.is_empty() {
            s.write_raw_1_byte([50])?;
            s.write_string(&self.type_name)?;
        }
        if !self.extendee.is_empty() {
            s.write_raw_1_byte([18])?;
            s.write_string(&self.extendee)?;
        }
        if !self.default_value.is_empty() {
            s.write_raw_1_byte([58])?;
            s.write_string(&self.default_value)?;
        }
        if 0 != self.oneof_index {
            s.write_raw_1_byte([72])?;
            s.write_var_i32(self.oneof_index)?;
        }
        if !self.json_name.is_empty() {
            s.write_raw_1_byte([82])?;
            s.write_string(&self.json_name)?;
        }
        if let Some(v) = &self.options {
            s.write_raw_1_byte([66])?;
            s.write_message(v)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.name.is_empty() {
            n += 1 + encoded::string_len(&self.name);
        }
        if 0 != self.number {
            n += 1 + encoded::var_i32_len(self.number);
        }
        if self.label.value() != 0 {
            n += 1 + encoded::enum_len(self.label);
        }
        if self.r#type.value() != 0 {
            n += 1 + encoded::enum_len(self.r#type);
        }
        if !self.type_name.is_empty() {
            n += 1 + encoded::string_len(&self.type_name);
        }
        if !self.extendee.is_empty() {
            n += 1 + encoded::string_len(&self.extendee);
        }
        if !self.default_value.is_empty() {
            n += 1 + encoded::string_len(&self.default_value);
        }
        if 0 != self.oneof_index {
            n += 1 + encoded::var_i32_len(self.oneof_index);
        }
        if !self.json_name.is_empty() {
            n += 1 + encoded::string_len(&self.json_name);
        }
        if let Some(v) = &self.options {
            n += 1 + encoded::message_len(v);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct OneofDescriptorProto {
    pub name: String,
    pub options: Option<OneofOptions>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for OneofDescriptorProto {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.name = s.read_string()?,
                18 => {
                    let msg = self.options.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.name.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.name)?;
        }
        if let Some(v) = &self.options {
            s.write_raw_1_byte([18])?;
            s.write_message(v)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.name.is_empty() {
            n += 1 + encoded::string_len(&self.name);
        }
        if let Some(v) = &self.options {
            n += 1 + encoded::message_len(v);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct EnumDescriptorProto {
    pub name: String,
    pub value: Vec<EnumValueDescriptorProto>,
    pub options: Option<EnumOptions>,
    pub reserved_range: Vec<EnumDescriptorProtoNestedEnumReservedRange>,
    pub reserved_name: Vec<String>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for EnumDescriptorProto {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.name = s.read_string()?,
                18 => s.read_message_to(&mut self.value)?,
                26 => {
                    let msg = self.options.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                34 => s.read_message_to(&mut self.reserved_range)?,
                42 => self.reserved_name.push(s.read_string()?),
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.name.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.name)?;
        }
        if !self.value.is_empty() {
            for v in &self.value {
                s.write_raw_1_byte([18])?;
                s.write_message(v)?;
            }
        }
        if let Some(v) = &self.options {
            s.write_raw_1_byte([26])?;
            s.write_message(v)?;
        }
        if !self.reserved_range.is_empty() {
            for v in &self.reserved_range {
                s.write_raw_1_byte([34])?;
                s.write_message(v)?;
            }
        }
        if !self.reserved_name.is_empty() {
            for v in &self.reserved_name {
                s.write_raw_1_byte([42])?;
                s.write_string(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.name.is_empty() {
            n += 1 + encoded::string_len(&self.name);
        }
        if !self.value.is_empty() {
            n += encoded::arr_message_len(1, &self.value);
        }
        if let Some(v) = &self.options {
            n += 1 + encoded::message_len(v);
        }
        if !self.reserved_range.is_empty() {
            n += encoded::arr_message_len(1, &self.reserved_range);
        }
        if !self.reserved_name.is_empty() {
            n += encoded::arr_string_len(1, &self.reserved_name);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct EnumDescriptorProtoNestedEnumReservedRange {
    pub start: i32,
    pub end: i32,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for EnumDescriptorProtoNestedEnumReservedRange {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.start = s.read_var_i32()?,
                16 => self.end = s.read_var_i32()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if 0 != self.start {
            s.write_raw_1_byte([8])?;
            s.write_var_i32(self.start)?;
        }
        if 0 != self.end {
            s.write_raw_1_byte([16])?;
            s.write_var_i32(self.end)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if 0 != self.start {
            n += 1 + encoded::var_i32_len(self.start);
        }
        if 0 != self.end {
            n += 1 + encoded::var_i32_len(self.end);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct EnumValueDescriptorProto {
    pub name: String,
    pub number: i32,
    pub options: Option<EnumValueOptions>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for EnumValueDescriptorProto {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.name = s.read_string()?,
                16 => self.number = s.read_var_i32()?,
                26 => {
                    let msg = self.options.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.name.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.name)?;
        }
        if 0 != self.number {
            s.write_raw_1_byte([16])?;
            s.write_var_i32(self.number)?;
        }
        if let Some(v) = &self.options {
            s.write_raw_1_byte([26])?;
            s.write_message(v)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.name.is_empty() {
            n += 1 + encoded::string_len(&self.name);
        }
        if 0 != self.number {
            n += 1 + encoded::var_i32_len(self.number);
        }
        if let Some(v) = &self.options {
            n += 1 + encoded::message_len(v);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct ServiceDescriptorProto {
    pub name: String,
    pub method: Vec<MethodDescriptorProto>,
    pub options: Option<ServiceOptions>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for ServiceDescriptorProto {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.name = s.read_string()?,
                18 => s.read_message_to(&mut self.method)?,
                26 => {
                    let msg = self.options.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.name.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.name)?;
        }
        if !self.method.is_empty() {
            for v in &self.method {
                s.write_raw_1_byte([18])?;
                s.write_message(v)?;
            }
        }
        if let Some(v) = &self.options {
            s.write_raw_1_byte([26])?;
            s.write_message(v)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.name.is_empty() {
            n += 1 + encoded::string_len(&self.name);
        }
        if !self.method.is_empty() {
            n += encoded::arr_message_len(1, &self.method);
        }
        if let Some(v) = &self.options {
            n += 1 + encoded::message_len(v);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct MethodDescriptorProto {
    pub name: String,
    pub input_type: String,
    pub output_type: String,
    pub options: Option<MethodOptions>,
    pub client_streaming: bool,
    pub server_streaming: bool,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for MethodDescriptorProto {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.name = s.read_string()?,
                18 => self.input_type = s.read_string()?,
                26 => self.output_type = s.read_string()?,
                34 => {
                    let msg = self.options.get_or_insert_with(Default::default);
                    s.read_message(msg)?;
                }
                40 => self.client_streaming = s.read_bool()?,
                48 => self.server_streaming = s.read_bool()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.name.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.name)?;
        }
        if !self.input_type.is_empty() {
            s.write_raw_1_byte([18])?;
            s.write_string(&self.input_type)?;
        }
        if !self.output_type.is_empty() {
            s.write_raw_1_byte([26])?;
            s.write_string(&self.output_type)?;
        }
        if let Some(v) = &self.options {
            s.write_raw_1_byte([34])?;
            s.write_message(v)?;
        }
        if self.client_streaming {
            s.write_raw_1_byte([40])?;
            s.write_bool(self.client_streaming)?;
        }
        if self.server_streaming {
            s.write_raw_1_byte([48])?;
            s.write_bool(self.server_streaming)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.name.is_empty() {
            n += 1 + encoded::string_len(&self.name);
        }
        if !self.input_type.is_empty() {
            n += 1 + encoded::string_len(&self.input_type);
        }
        if !self.output_type.is_empty() {
            n += 1 + encoded::string_len(&self.output_type);
        }
        if let Some(v) = &self.options {
            n += 1 + encoded::message_len(v);
        }
        if self.client_streaming {
            n += 2;
        }
        if self.server_streaming {
            n += 2;
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct FileOptions {
    pub java_package: String,
    pub java_outer_classname: String,
    pub java_multiple_files: bool,
    pub java_generate_equals_and_hash: bool,
    pub java_string_check_utf8: bool,
    pub optimize_for: FileOptionsNestedOptimizeMode,
    pub go_package: String,
    pub cc_generic_services: bool,
    pub java_generic_services: bool,
    pub py_generic_services: bool,
    pub php_generic_services: bool,
    pub deprecated: bool,
    pub cc_enable_arenas: bool,
    pub objc_class_prefix: String,
    pub csharp_namespace: String,
    pub swift_prefix: String,
    pub php_class_prefix: String,
    pub php_namespace: String,
    pub php_metadata_namespace: String,
    pub ruby_package: String,
    pub uninterpreted_option: Vec<UninterpretedOption>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for FileOptions {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.java_package = s.read_string()?,
                66 => self.java_outer_classname = s.read_string()?,
                80 => self.java_multiple_files = s.read_bool()?,
                160 => self.java_generate_equals_and_hash = s.read_bool()?,
                216 => self.java_string_check_utf8 = s.read_bool()?,
                72 => self.optimize_for = s.read_enum()?,
                90 => self.go_package = s.read_string()?,
                128 => self.cc_generic_services = s.read_bool()?,
                136 => self.java_generic_services = s.read_bool()?,
                144 => self.py_generic_services = s.read_bool()?,
                336 => self.php_generic_services = s.read_bool()?,
                184 => self.deprecated = s.read_bool()?,
                248 => self.cc_enable_arenas = s.read_bool()?,
                290 => self.objc_class_prefix = s.read_string()?,
                298 => self.csharp_namespace = s.read_string()?,
                314 => self.swift_prefix = s.read_string()?,
                322 => self.php_class_prefix = s.read_string()?,
                330 => self.php_namespace = s.read_string()?,
                354 => self.php_metadata_namespace = s.read_string()?,
                362 => self.ruby_package = s.read_string()?,
                7994 => s.read_message_to(&mut self.uninterpreted_option)?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.java_package.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.java_package)?;
        }
        if !self.java_outer_classname.is_empty() {
            s.write_raw_1_byte([66])?;
            s.write_string(&self.java_outer_classname)?;
        }
        if self.java_multiple_files {
            s.write_raw_1_byte([80])?;
            s.write_bool(self.java_multiple_files)?;
        }
        if self.java_generate_equals_and_hash {
            s.write_raw_2_byte([160, 1])?;
            s.write_bool(self.java_generate_equals_and_hash)?;
        }
        if self.java_string_check_utf8 {
            s.write_raw_2_byte([216, 1])?;
            s.write_bool(self.java_string_check_utf8)?;
        }
        if self.optimize_for.value() != 0 {
            s.write_raw_1_byte([72])?;
            s.write_enum(self.optimize_for)?;
        }
        if !self.go_package.is_empty() {
            s.write_raw_1_byte([90])?;
            s.write_string(&self.go_package)?;
        }
        if self.cc_generic_services {
            s.write_raw_2_byte([128, 1])?;
            s.write_bool(self.cc_generic_services)?;
        }
        if self.java_generic_services {
            s.write_raw_2_byte([136, 1])?;
            s.write_bool(self.java_generic_services)?;
        }
        if self.py_generic_services {
            s.write_raw_2_byte([144, 1])?;
            s.write_bool(self.py_generic_services)?;
        }
        if self.php_generic_services {
            s.write_raw_2_byte([208, 2])?;
            s.write_bool(self.php_generic_services)?;
        }
        if self.deprecated {
            s.write_raw_2_byte([184, 1])?;
            s.write_bool(self.deprecated)?;
        }
        if self.cc_enable_arenas {
            s.write_raw_2_byte([248, 1])?;
            s.write_bool(self.cc_enable_arenas)?;
        }
        if !self.objc_class_prefix.is_empty() {
            s.write_raw_2_byte([162, 2])?;
            s.write_string(&self.objc_class_prefix)?;
        }
        if !self.csharp_namespace.is_empty() {
            s.write_raw_2_byte([170, 2])?;
            s.write_string(&self.csharp_namespace)?;
        }
        if !self.swift_prefix.is_empty() {
            s.write_raw_2_byte([186, 2])?;
            s.write_string(&self.swift_prefix)?;
        }
        if !self.php_class_prefix.is_empty() {
            s.write_raw_2_byte([194, 2])?;
            s.write_string(&self.php_class_prefix)?;
        }
        if !self.php_namespace.is_empty() {
            s.write_raw_2_byte([202, 2])?;
            s.write_string(&self.php_namespace)?;
        }
        if !self.php_metadata_namespace.is_empty() {
            s.write_raw_2_byte([226, 2])?;
            s.write_string(&self.php_metadata_namespace)?;
        }
        if !self.ruby_package.is_empty() {
            s.write_raw_2_byte([234, 2])?;
            s.write_string(&self.ruby_package)?;
        }
        if !self.uninterpreted_option.is_empty() {
            for v in &self.uninterpreted_option {
                s.write_raw_2_byte([186, 62])?;
                s.write_message(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.java_package.is_empty() {
            n += 1 + encoded::string_len(&self.java_package);
        }
        if !self.java_outer_classname.is_empty() {
            n += 1 + encoded::string_len(&self.java_outer_classname);
        }
        if self.java_multiple_files {
            n += 2;
        }
        if self.java_generate_equals_and_hash {
            n += 3;
        }
        if self.java_string_check_utf8 {
            n += 3;
        }
        if self.optimize_for.value() != 0 {
            n += 1 + encoded::enum_len(self.optimize_for);
        }
        if !self.go_package.is_empty() {
            n += 1 + encoded::string_len(&self.go_package);
        }
        if self.cc_generic_services {
            n += 3;
        }
        if self.java_generic_services {
            n += 3;
        }
        if self.py_generic_services {
            n += 3;
        }
        if self.php_generic_services {
            n += 3;
        }
        if self.deprecated {
            n += 3;
        }
        if self.cc_enable_arenas {
            n += 3;
        }
        if !self.objc_class_prefix.is_empty() {
            n += 2 + encoded::string_len(&self.objc_class_prefix);
        }
        if !self.csharp_namespace.is_empty() {
            n += 2 + encoded::string_len(&self.csharp_namespace);
        }
        if !self.swift_prefix.is_empty() {
            n += 2 + encoded::string_len(&self.swift_prefix);
        }
        if !self.php_class_prefix.is_empty() {
            n += 2 + encoded::string_len(&self.php_class_prefix);
        }
        if !self.php_namespace.is_empty() {
            n += 2 + encoded::string_len(&self.php_namespace);
        }
        if !self.php_metadata_namespace.is_empty() {
            n += 2 + encoded::string_len(&self.php_metadata_namespace);
        }
        if !self.ruby_package.is_empty() {
            n += 2 + encoded::string_len(&self.ruby_package);
        }
        if !self.uninterpreted_option.is_empty() {
            n += encoded::arr_message_len(2, &self.uninterpreted_option);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct MessageOptions {
    pub message_set_wire_format: bool,
    pub no_standard_descriptor_accessor: bool,
    pub deprecated: bool,
    pub map_entry: bool,
    pub uninterpreted_option: Vec<UninterpretedOption>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for MessageOptions {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.message_set_wire_format = s.read_bool()?,
                16 => self.no_standard_descriptor_accessor = s.read_bool()?,
                24 => self.deprecated = s.read_bool()?,
                56 => self.map_entry = s.read_bool()?,
                7994 => s.read_message_to(&mut self.uninterpreted_option)?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if self.message_set_wire_format {
            s.write_raw_1_byte([8])?;
            s.write_bool(self.message_set_wire_format)?;
        }
        if self.no_standard_descriptor_accessor {
            s.write_raw_1_byte([16])?;
            s.write_bool(self.no_standard_descriptor_accessor)?;
        }
        if self.deprecated {
            s.write_raw_1_byte([24])?;
            s.write_bool(self.deprecated)?;
        }
        if self.map_entry {
            s.write_raw_1_byte([56])?;
            s.write_bool(self.map_entry)?;
        }
        if !self.uninterpreted_option.is_empty() {
            for v in &self.uninterpreted_option {
                s.write_raw_2_byte([186, 62])?;
                s.write_message(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if self.message_set_wire_format {
            n += 2;
        }
        if self.no_standard_descriptor_accessor {
            n += 2;
        }
        if self.deprecated {
            n += 2;
        }
        if self.map_entry {
            n += 2;
        }
        if !self.uninterpreted_option.is_empty() {
            n += encoded::arr_message_len(2, &self.uninterpreted_option);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct FieldOptions {
    pub ctype: FieldOptionsNestedCType,
    pub packed: bool,
    pub jstype: FieldOptionsNestedJsType,
    pub lazy: bool,
    pub deprecated: bool,
    pub weak: bool,
    pub uninterpreted_option: Vec<UninterpretedOption>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for FieldOptions {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.ctype = s.read_enum()?,
                16 => self.packed = s.read_bool()?,
                48 => self.jstype = s.read_enum()?,
                40 => self.lazy = s.read_bool()?,
                24 => self.deprecated = s.read_bool()?,
                80 => self.weak = s.read_bool()?,
                7994 => s.read_message_to(&mut self.uninterpreted_option)?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if self.ctype.value() != 0 {
            s.write_raw_1_byte([8])?;
            s.write_enum(self.ctype)?;
        }
        if self.packed {
            s.write_raw_1_byte([16])?;
            s.write_bool(self.packed)?;
        }
        if self.jstype.value() != 0 {
            s.write_raw_1_byte([48])?;
            s.write_enum(self.jstype)?;
        }
        if self.lazy {
            s.write_raw_1_byte([40])?;
            s.write_bool(self.lazy)?;
        }
        if self.deprecated {
            s.write_raw_1_byte([24])?;
            s.write_bool(self.deprecated)?;
        }
        if self.weak {
            s.write_raw_1_byte([80])?;
            s.write_bool(self.weak)?;
        }
        if !self.uninterpreted_option.is_empty() {
            for v in &self.uninterpreted_option {
                s.write_raw_2_byte([186, 62])?;
                s.write_message(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if self.ctype.value() != 0 {
            n += 1 + encoded::enum_len(self.ctype);
        }
        if self.packed {
            n += 2;
        }
        if self.jstype.value() != 0 {
            n += 1 + encoded::enum_len(self.jstype);
        }
        if self.lazy {
            n += 2;
        }
        if self.deprecated {
            n += 2;
        }
        if self.weak {
            n += 2;
        }
        if !self.uninterpreted_option.is_empty() {
            n += encoded::arr_message_len(2, &self.uninterpreted_option);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct OneofOptions {
    pub uninterpreted_option: Vec<UninterpretedOption>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for OneofOptions {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                7994 => s.read_message_to(&mut self.uninterpreted_option)?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.uninterpreted_option.is_empty() {
            for v in &self.uninterpreted_option {
                s.write_raw_2_byte([186, 62])?;
                s.write_message(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.uninterpreted_option.is_empty() {
            n += encoded::arr_message_len(2, &self.uninterpreted_option);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct EnumOptions {
    pub allow_alias: bool,
    pub deprecated: bool,
    pub uninterpreted_option: Vec<UninterpretedOption>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for EnumOptions {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                16 => self.allow_alias = s.read_bool()?,
                24 => self.deprecated = s.read_bool()?,
                7994 => s.read_message_to(&mut self.uninterpreted_option)?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if self.allow_alias {
            s.write_raw_1_byte([16])?;
            s.write_bool(self.allow_alias)?;
        }
        if self.deprecated {
            s.write_raw_1_byte([24])?;
            s.write_bool(self.deprecated)?;
        }
        if !self.uninterpreted_option.is_empty() {
            for v in &self.uninterpreted_option {
                s.write_raw_2_byte([186, 62])?;
                s.write_message(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if self.allow_alias {
            n += 2;
        }
        if self.deprecated {
            n += 2;
        }
        if !self.uninterpreted_option.is_empty() {
            n += encoded::arr_message_len(2, &self.uninterpreted_option);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct EnumValueOptions {
    pub deprecated: bool,
    pub uninterpreted_option: Vec<UninterpretedOption>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for EnumValueOptions {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.deprecated = s.read_bool()?,
                7994 => s.read_message_to(&mut self.uninterpreted_option)?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if self.deprecated {
            s.write_raw_1_byte([8])?;
            s.write_bool(self.deprecated)?;
        }
        if !self.uninterpreted_option.is_empty() {
            for v in &self.uninterpreted_option {
                s.write_raw_2_byte([186, 62])?;
                s.write_message(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if self.deprecated {
            n += 2;
        }
        if !self.uninterpreted_option.is_empty() {
            n += encoded::arr_message_len(2, &self.uninterpreted_option);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct ServiceOptions {
    pub deprecated: bool,
    pub uninterpreted_option: Vec<UninterpretedOption>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for ServiceOptions {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                264 => self.deprecated = s.read_bool()?,
                7994 => s.read_message_to(&mut self.uninterpreted_option)?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if self.deprecated {
            s.write_raw_2_byte([136, 2])?;
            s.write_bool(self.deprecated)?;
        }
        if !self.uninterpreted_option.is_empty() {
            for v in &self.uninterpreted_option {
                s.write_raw_2_byte([186, 62])?;
                s.write_message(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if self.deprecated {
            n += 3;
        }
        if !self.uninterpreted_option.is_empty() {
            n += encoded::arr_message_len(2, &self.uninterpreted_option);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct MethodOptions {
    pub deprecated: bool,
    pub idempotency_level: MethodOptionsNestedIdempotencyLevel,
    pub uninterpreted_option: Vec<UninterpretedOption>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for MethodOptions {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                264 => self.deprecated = s.read_bool()?,
                272 => self.idempotency_level = s.read_enum()?,
                7994 => s.read_message_to(&mut self.uninterpreted_option)?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if self.deprecated {
            s.write_raw_2_byte([136, 2])?;
            s.write_bool(self.deprecated)?;
        }
        if self.idempotency_level.value() != 0 {
            s.write_raw_2_byte([144, 2])?;
            s.write_enum(self.idempotency_level)?;
        }
        if !self.uninterpreted_option.is_empty() {
            for v in &self.uninterpreted_option {
                s.write_raw_2_byte([186, 62])?;
                s.write_message(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if self.deprecated {
            n += 3;
        }
        if self.idempotency_level.value() != 0 {
            n += 2 + encoded::enum_len(self.idempotency_level);
        }
        if !self.uninterpreted_option.is_empty() {
            n += encoded::arr_message_len(2, &self.uninterpreted_option);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UninterpretedOption {
    pub name: Vec<UninterpretedOptionNestedNamePart>,
    pub identifier_value: String,
    pub positive_int_value: u64,
    pub negative_int_value: i64,
    pub double_value: f64,
    pub string_value: Vec<u8>,
    pub aggregate_value: String,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for UninterpretedOption {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                18 => s.read_message_to(&mut self.name)?,
                26 => self.identifier_value = s.read_string()?,
                32 => self.positive_int_value = s.read_var_u64()?,
                40 => self.negative_int_value = s.read_var_i64()?,
                49 => self.double_value = s.read_f64()?,
                58 => self.string_value = s.read_bytes()?,
                66 => self.aggregate_value = s.read_string()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.name.is_empty() {
            for v in &self.name {
                s.write_raw_1_byte([18])?;
                s.write_message(v)?;
            }
        }
        if !self.identifier_value.is_empty() {
            s.write_raw_1_byte([26])?;
            s.write_string(&self.identifier_value)?;
        }
        if 0 != self.positive_int_value {
            s.write_raw_1_byte([32])?;
            s.write_var_u64(self.positive_int_value)?;
        }
        if 0 != self.negative_int_value {
            s.write_raw_1_byte([40])?;
            s.write_var_i64(self.negative_int_value)?;
        }
        if 0f64 != self.double_value {
            s.write_raw_1_byte([49])?;
            s.write_f64(self.double_value)?;
        }
        if !self.string_value.is_empty() {
            s.write_raw_1_byte([58])?;
            s.write_bytes(&self.string_value)?;
        }
        if !self.aggregate_value.is_empty() {
            s.write_raw_1_byte([66])?;
            s.write_string(&self.aggregate_value)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.name.is_empty() {
            n += encoded::arr_message_len(1, &self.name);
        }
        if !self.identifier_value.is_empty() {
            n += 1 + encoded::string_len(&self.identifier_value);
        }
        if 0 != self.positive_int_value {
            n += 1 + encoded::var_u64_len(self.positive_int_value);
        }
        if 0 != self.negative_int_value {
            n += 1 + encoded::var_i64_len(self.negative_int_value);
        }
        if 0f64 != self.double_value {
            n += 9;
        }
        if !self.string_value.is_empty() {
            n += 1 + encoded::bytes_len(&self.string_value);
        }
        if !self.aggregate_value.is_empty() {
            n += 1 + encoded::string_len(&self.aggregate_value);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UninterpretedOptionNestedNamePart {
    pub name_part: String,
    pub is_extension: bool,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for UninterpretedOptionNestedNamePart {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => self.name_part = s.read_string()?,
                16 => self.is_extension = s.read_bool()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.name_part.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_string(&self.name_part)?;
        }
        if self.is_extension {
            s.write_raw_1_byte([16])?;
            s.write_bool(self.is_extension)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.name_part.is_empty() {
            n += 1 + encoded::string_len(&self.name_part);
        }
        if self.is_extension {
            n += 2;
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct SourceCodeInfo {
    pub location: Vec<SourceCodeInfoNestedLocation>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for SourceCodeInfo {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => s.read_message_to(&mut self.location)?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.location.is_empty() {
            for v in &self.location {
                s.write_raw_1_byte([10])?;
                s.write_message(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.location.is_empty() {
            n += encoded::arr_message_len(1, &self.location);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct SourceCodeInfoNestedLocation {
    pub path: Vec<i32>,
    pub span: Vec<i32>,
    pub leading_comments: String,
    pub trailing_comments: String,
    pub leading_detached_comments: Vec<String>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for SourceCodeInfoNestedLocation {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.path.push(s.read_var_i32()?),
                10 => s.read_var_i32_array(&mut self.path)?,
                16 => self.span.push(s.read_var_i32()?),
                18 => s.read_var_i32_array(&mut self.span)?,
                26 => self.leading_comments = s.read_string()?,
                34 => self.trailing_comments = s.read_string()?,
                50 => self.leading_detached_comments.push(s.read_string()?),
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.path.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_var_i32_array(&self.path)?;
        }
        if !self.span.is_empty() {
            s.write_raw_1_byte([18])?;
            s.write_var_i32_array(&self.span)?;
        }
        if !self.leading_comments.is_empty() {
            s.write_raw_1_byte([26])?;
            s.write_string(&self.leading_comments)?;
        }
        if !self.trailing_comments.is_empty() {
            s.write_raw_1_byte([34])?;
            s.write_string(&self.trailing_comments)?;
        }
        if !self.leading_detached_comments.is_empty() {
            for v in &self.leading_detached_comments {
                s.write_raw_1_byte([50])?;
                s.write_string(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.path.is_empty() {
            n += 1 + encoded::arr_var_i32_len(&self.path);
        }
        if !self.span.is_empty() {
            n += 1 + encoded::arr_var_i32_len(&self.span);
        }
        if !self.leading_comments.is_empty() {
            n += 1 + encoded::string_len(&self.leading_comments);
        }
        if !self.trailing_comments.is_empty() {
            n += 1 + encoded::string_len(&self.trailing_comments);
        }
        if !self.leading_detached_comments.is_empty() {
            n += encoded::arr_string_len(1, &self.leading_detached_comments);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct GeneratedCodeInfo {
    pub annotation: Vec<GeneratedCodeInfoNestedAnnotation>,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for GeneratedCodeInfo {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                10 => s.read_message_to(&mut self.annotation)?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.annotation.is_empty() {
            for v in &self.annotation {
                s.write_raw_1_byte([10])?;
                s.write_message(v)?;
            }
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.annotation.is_empty() {
            n += encoded::arr_message_len(1, &self.annotation);
        }
        n
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct GeneratedCodeInfoNestedAnnotation {
    pub path: Vec<i32>,
    pub source_file: String,
    pub begin: i32,
    pub end: i32,
    pub cache_size: CacheSize,
    pub unknown: Vec<u8>,
}

impl Message for GeneratedCodeInfoNestedAnnotation {
    fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {
        loop {
            let tag = s.read_tag()?;
            match tag {
                8 => self.path.push(s.read_var_i32()?),
                10 => s.read_var_i32_array(&mut self.path)?,
                18 => self.source_file = s.read_string()?,
                24 => self.begin = s.read_var_i32()?,
                32 => self.end = s.read_var_i32()?,
                0 => return Ok(()),
                _ => s.skip_field(&mut self.unknown, tag)?,
            }
        }
    }

    fn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {
        if !self.path.is_empty() {
            s.write_raw_1_byte([10])?;
            s.write_var_i32_array(&self.path)?;
        }
        if !self.source_file.is_empty() {
            s.write_raw_1_byte([18])?;
            s.write_string(&self.source_file)?;
        }
        if 0 != self.begin {
            s.write_raw_1_byte([24])?;
            s.write_var_i32(self.begin)?;
        }
        if 0 != self.end {
            s.write_raw_1_byte([32])?;
            s.write_var_i32(self.end)?;
        }
        if !self.unknown.is_empty() {
            s.write_unknown(&self.unknown)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        let mut n = self.unknown.len();
        if !self.path.is_empty() {
            n += 1 + encoded::arr_var_i32_len(&self.path);
        }
        if !self.source_file.is_empty() {
            n += 1 + encoded::string_len(&self.source_file);
        }
        if 0 != self.begin {
            n += 1 + encoded::var_i32_len(self.begin);
        }
        if 0 != self.end {
            n += 1 + encoded::var_i32_len(self.end);
        }
        n
    }
}
