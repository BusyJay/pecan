use crate::context::{Context, Output, Printer};
use crate::descriptor::{EnumDescriptor, FileDescriptor, MessageDescriptor};
use crate::pecan_descriptor::google::protobuf::descriptor_pb::*;
use id_arena::Id;
use pecan::Message;
use pecan::Result;
use pecan_utils::naming;
use std::env;
use std::fmt::Write;

struct FieldDecl<'a> {
    field_name: String,
    type_name: String,
    tag1: u32,
    tag2: u32,
    copy: bool,
    default_val: &'static str,
    method_symbol: &'static str,
    proto: &'a FieldDescriptorProto,
}

impl FieldDecl<'_> {
    fn strip_field_name(&self) -> &str {
        if !self.field_name.starts_with("r#") {
            &self.field_name
        } else {
            &self.field_name[2..]
        }
    }
}

struct OneOfDecl<'a> {
    field_name: String,
    type_name: String,
    copy: bool,
    items: Vec<FieldType<'a>>,
}

enum FieldType<'a> {
    Optional(FieldDecl<'a>),
    Singlular(FieldDecl<'a>),
    Repeated(FieldDecl<'a>),
    Oneof(OneOfDecl<'a>),
}

pub struct Generator<'a> {
    printer: Printer<'a>,
    file: Id<FileDescriptor>,
    proto3: bool,
    file_name: String,
}

impl Generator<'_> {
    pub fn new<'a>(
        ctx: &Context,
        output: &'a mut Output,
        file: Id<FileDescriptor>,
    ) -> Generator<'a> {
        let file_descriptor = &ctx.db.files.get(file).unwrap();
        let input_file_name = file_descriptor.proto.name().to_owned();
        let module_name = naming::module_name(&input_file_name);
        let output_file_name = naming::file_name(&module_name);
        let printer = output.open(&output_file_name);
        Generator {
            printer,
            file,
            proto3: file_descriptor.proto3,
            file_name: input_file_name,
        }
    }

    fn print_top_boilerplate(&mut self) {
        w!(
            self.printer,
            "// This file is generated by pecan {version}, DO NOT EDIT!
// @generated
// source: {file_name}
",
            version = env!("CARGO_PKG_VERSION"),
            file_name = self.file_name
        );
        w!(self.printer, "\n");
        w!(
            self.printer,
            "#![allow(non_upper_case_globals)]\n#![allow(unused_imports)]\n"
        );
    }

    fn print_imports(&mut self, ctx: &Context) {
        w!(self.printer, "\n");
        w!(
            self.printer,
            "use pecan::{{
    EnumType,
    Message,
    Result,
    Buf,
    BufMut,
    CodedInputStream,
    CodedOutputStream,
    encoded,
}};\n"
        );
        let f = ctx.db.files.get(self.file).unwrap();
        if f.proto.dependency().is_empty() {
            return;
        }

        w!(self.printer, "\n");
        for dependency in f.proto.dependency() {
            let id = *ctx.files.get(dependency).unwrap();
            let dep = &ctx.db.files.get(id).unwrap();
            let module_name = naming::module_name(dep.proto.name());
            let module_alias = naming::alias_name(dep.proto.name());
            w!(
                self.printer,
                "use crate::{module_name} as {module_alias};\n",
                module_name = module_name,
                module_alias = module_alias
            );
        }
    }

    fn print_file_descriptor(&mut self, ctx: &Context) -> Result<()> {
        let mut proto = ctx.db.files.get(self.file).unwrap().proto.clone();
        proto.clear_source_code_info();
        let bytes = proto.write_as_bytes()?;
        w!(self.printer, "\npub static DESCRIPTOR: &[u8] = &[\n");
        self.printer.indent();
        for chunk in bytes.chunks(16) {
            for b in &chunk[..chunk.len() - 1] {
                w!(self.printer, "{}, ", b);
            }
            w!(self.printer, "{},\n", chunk[chunk.len() - 1]);
        }
        self.printer.outdent();
        w!(self.printer, "];\n");
        Ok(())
    }

    fn print_enum(&mut self, ctx: &Context, id: Id<EnumDescriptor>) {
        w!(
            self.printer,
            "\n#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]\n"
        );
        let e = ctx.db.enums.get(id).unwrap();
        let name = naming::type_name(&e.type_name);
        w!(self.printer, "pub struct {}(i32);\n\n", name);

        w_scope!(self.printer, "impl {} {{\n", name);
        let mut zero_value = format!("{}(0)", name);
        for v in e.proto.value() {
            let enum_name = naming::camel_case(v.name());
            if v.number() == 0 {
                zero_value = format!("{}::{}", name, enum_name);
            }
            w!(
                self.printer,
                "pub const {}: {} = {}({});\n",
                enum_name,
                name,
                name,
                v.number()
            );
        }
        w_scope!(self.printer, "\npub const fn new() -> {} {{\n", name);
        w!(self.printer, "{}\n", zero_value);
        w_end_scope!(self.printer, "}}\n");
        w_end_scope!(self.printer, "}}\n\n");

        w!(self.printer, "impl From<i32> for {} {{\n", name);
        self.printer.indent();
        w!(self.printer, "#[inline]\nfn from(u: i32) -> {} {{\n", name);
        self.printer.indent();
        w!(self.printer, "{}(u)\n", name);
        self.printer.outdent();
        w!(self.printer, "}}\n");
        self.printer.outdent();
        w!(self.printer, "}}\n\n");

        w!(self.printer, "impl EnumType for {} {{\n", name);
        self.printer.indent();
        w!(
            self.printer,
            "#[inline]\nfn values() -> &'static [{}] {{\n",
            name
        );
        self.printer.indent();
        w!(self.printer, "&[\n");
        self.printer.indent();
        for v in e.proto.value() {
            let enum_name = naming::camel_case(v.name());
            w!(self.printer, "{}::{},\n", name, enum_name);
        }
        self.printer.outdent();
        w!(self.printer, "]\n");
        self.printer.outdent();
        w!(
            self.printer,
            "}}\n\n#[inline]\nfn value(&self) -> i32 {{ self.0 }}\n"
        );
        self.printer.outdent();
        w!(self.printer, "}}\n");
    }

    fn print_enums(&mut self, ctx: &Context) {
        let enums = &ctx.db.files.get(self.file).unwrap().enums;
        for e in enums {
            self.print_enum(ctx, *e);
        }
    }

    fn build_field<'a>(
        &mut self,
        ctx: &Context,
        f: &'a FieldDescriptorProto,
    ) -> (Option<i32>, FieldType<'a>) {
        let mut desc = FieldDecl {
            field_name: naming::field_name(f.name()),
            type_name: String::new(),
            tag1: (f.number() as u32) << 3,
            tag2: 0,
            copy: true,
            default_val: "0",
            method_symbol: "",
            proto: f,
        };
        let mut wire_type = 0;
        match f.r#type() {
            FieldDescriptorProtoNestedType::TypeBool => {
                desc.method_symbol = "bool";
                desc.type_name = "bool".to_owned();
                desc.default_val = "";
            }
            FieldDescriptorProtoNestedType::TypeInt32 => {
                desc.method_symbol = "var_i32";
                desc.type_name = "i32".to_owned();
            }
            FieldDescriptorProtoNestedType::TypeInt64 => {
                desc.method_symbol = "var_i64";
                desc.type_name = "i64".to_owned();
            }
            FieldDescriptorProtoNestedType::TypeUint32 => {
                desc.method_symbol = "var_u32";
                desc.type_name = "u32".to_owned();
            }
            FieldDescriptorProtoNestedType::TypeUint64 => {
                desc.method_symbol = "var_u64";
                desc.type_name = "u64".to_owned();
            }
            FieldDescriptorProtoNestedType::TypeSint32 => {
                desc.method_symbol = "var_s32";
                desc.type_name = "i32".to_owned();
            }
            FieldDescriptorProtoNestedType::TypeSint64 => {
                desc.method_symbol = "var_s64";
                desc.type_name = "i64".to_owned();
            }
            FieldDescriptorProtoNestedType::TypeEnum => {
                desc.method_symbol = "enum";
                let id = ctx.enum_address.get(f.type_name()).unwrap();
                let e = ctx.db.enums.get(*id).unwrap();
                desc.type_name = naming::type_name(&e.type_name);
                if e.file != self.file {
                    let f = ctx.db.files.get(e.file).unwrap();
                    desc.type_name = format!(
                        "{}::{}",
                        naming::alias_name(f.proto.name()),
                        &desc.type_name
                    );
                }
                desc.default_val = "";
            }
            FieldDescriptorProtoNestedType::TypeFixed64 => {
                wire_type = 1;
                desc.method_symbol = "fixed64";
                desc.type_name = "u64".to_owned();
            }
            FieldDescriptorProtoNestedType::TypeSfixed64 => {
                wire_type = 1;
                desc.method_symbol = "sfixed64";
                desc.type_name = "i64".to_owned();
            }
            FieldDescriptorProtoNestedType::TypeDouble => {
                wire_type = 1;
                desc.method_symbol = "f64";
                desc.type_name = "f64".to_owned();
                desc.default_val = "0f64";
            }
            FieldDescriptorProtoNestedType::TypeString => {
                wire_type = 2;
                desc.method_symbol = "string";
                desc.type_name = "String".to_owned();
                desc.default_val = "";
                desc.copy = false;
            }
            FieldDescriptorProtoNestedType::TypeBytes => {
                wire_type = 2;
                desc.method_symbol = "bytes";
                desc.type_name = "Vec<u8>".to_owned();
                desc.default_val = "";
                desc.copy = false;
            }
            FieldDescriptorProtoNestedType::TypeMessage => {
                wire_type = 2;
                desc.method_symbol = "message";
                let id = ctx.message_address.get(f.type_name()).unwrap();
                let e = ctx.db.messages.get(*id).unwrap();
                desc.type_name = naming::type_name(&e.type_name);
                if e.file != self.file {
                    let f = ctx.db.files.get(e.file).unwrap();
                    desc.type_name = format!(
                        "{}::{}",
                        naming::alias_name(f.proto.name()),
                        &desc.type_name
                    );
                }
                desc.default_val = "";
                desc.copy = false;
            }
            FieldDescriptorProtoNestedType::TypeGroup => unimplemented!(),
            FieldDescriptorProtoNestedType::TypeFixed32 => {
                wire_type = 5;
                desc.method_symbol = "fixed32";
                desc.type_name = "u32".to_owned();
            }
            FieldDescriptorProtoNestedType::TypeSfixed32 => {
                wire_type = 5;
                desc.method_symbol = "sfixed32";
                desc.type_name = "i32".to_owned();
            }
            FieldDescriptorProtoNestedType::TypeFloat => {
                wire_type = 5;
                desc.method_symbol = "f32";
                desc.type_name = "f32".to_owned();
                desc.default_val = "0f32";
            }
            _ => unimplemented!(),
        }
        desc.tag1 |= wire_type;
        let oneof_index = if desc.proto.has_oneof_index() {
            Some(desc.proto.oneof_index())
        } else {
            None
        };
        let ft = match desc.proto.label() {
            FieldDescriptorProtoNestedLabel::LabelOptional => {
                if !self.proto3 || f.r#type() == FieldDescriptorProtoNestedType::TypeMessage {
                    FieldType::Optional(desc)
                } else {
                    FieldType::Singlular(desc)
                }
            }
            FieldDescriptorProtoNestedLabel::LabelRequired => FieldType::Singlular(desc),
            FieldDescriptorProtoNestedLabel::LabelRepeated => {
                if wire_type == 0 || wire_type == 1 || wire_type == 5 {
                    desc.tag2 = (desc.proto.number() as u32) << 3 | 2;
                }
                FieldType::Repeated(desc)
            }
            _ => unimplemented!(),
        };
        (oneof_index, ft)
    }

    fn build_field_set<'a>(
        &mut self,
        ctx: &Context,
        m: &'a MessageDescriptor,
    ) -> Vec<FieldType<'a>> {
        let mut oneof_decls = vec![];
        for oneof in m.proto.oneof_decl() {
            let mut oneof_names = m.type_name.clone();
            oneof_names.push(oneof.name().to_owned());
            oneof_decls.push(OneOfDecl {
                field_name: naming::field_name(oneof.name()),
                type_name: naming::type_name(&oneof_names),
                copy: true,
                items: vec![],
            });
        }
        let mut fields = vec![];
        for f in m.proto.field() {
            let (oneof_index, ft) = self.build_field(ctx, f);
            if let Some(index) = oneof_index {
                oneof_decls[index as usize].copy &= match &ft {
                    FieldType::Optional(d) | FieldType::Singlular(d) => d.copy,
                    FieldType::Oneof(_) | FieldType::Repeated(_) => unreachable!(),
                };
                oneof_decls[index as usize].items.push(ft);
            } else {
                fields.push(ft);
            }
        }
        fields.extend(oneof_decls.into_iter().map(FieldType::Oneof));
        fields
    }

    fn print_field_decl(&mut self, field_sets: &[FieldType]) {
        for ft in field_sets {
            match ft {
                FieldType::Optional(desc) => {
                    w!(
                        self.printer,
                        "{}: Option<{}>,\n",
                        desc.field_name,
                        desc.type_name
                    );
                }
                FieldType::Singlular(desc) => {
                    w!(
                        self.printer,
                        "pub {}: {},\n",
                        desc.field_name,
                        desc.type_name
                    );
                }
                FieldType::Repeated(desc) => {
                    w!(
                        self.printer,
                        "{}: Vec<{}>,\n",
                        desc.field_name,
                        desc.type_name
                    );
                }
                FieldType::Oneof(desc) => {
                    w!(
                        self.printer,
                        "pub {}: Option<{}>,\n",
                        desc.field_name,
                        desc.type_name
                    );
                }
            }
        }
    }

    fn print_oneof_decl(&mut self, field_sets: &[FieldType]) {
        for ft in field_sets {
            let desc = match ft {
                FieldType::Oneof(desc) => desc,
                _ => continue,
            };
            if desc.copy {
                w!(
                    self.printer,
                    "\n#[derive(Clone, Debug, Coppy, PartialEq)]\n"
                );
            } else {
                w!(self.printer, "\n#[derive(Clone, Debug, PartialEq)]\n");
            }
            w!(self.printer, "\npub enum {} {{\n", desc.type_name);
            self.printer.indent();
            for item in &desc.items {
                let (ty_name, internal_ty) = match item {
                    FieldType::Oneof(d) => (naming::camel_case(&d.field_name), &d.type_name),
                    FieldType::Optional(d) => (naming::camel_case(&d.field_name), &d.type_name),
                    FieldType::Repeated(d) => (naming::camel_case(&d.field_name), &d.type_name),
                    FieldType::Singlular(d) => (naming::camel_case(&d.field_name), &d.type_name),
                };
                w!(self.printer, "{}({}),\n", ty_name, internal_ty);
            }
            self.printer.outdent();
            w!(self.printer, "}}\n");
        }
    }

    fn print_merge_from_optional(&mut self, d: &FieldDecl) {
        if d.method_symbol != "message" {
            w!(
                self.printer,
                "{} => self.{} = Some(s.read_{}()?),\n",
                d.tag1,
                d.field_name,
                d.method_symbol
            );
            return;
        }

        w!(self.printer, "{} => {{\n", d.tag1);
        self.printer.indent();
        w!(
            self.printer,
            "let msg = self.{}.get_or_insert_with(Default::default);\n",
            d.field_name
        );
        w!(self.printer, "s.read_message(msg)?;\n");
        self.printer.outdent();
        w!(self.printer, "}}\n");
    }

    fn print_merge_from_singlular(&mut self, d: &FieldDecl) {
        w!(
            self.printer,
            "{} => self.{} = s.read_{}()?,\n",
            d.tag1,
            d.field_name,
            d.method_symbol
        );
    }

    fn print_merge_from_repeated(&mut self, d: &FieldDecl) {
        if d.method_symbol != "message" {
            w!(
                self.printer,
                "{} => self.{}.push(s.read_{}()?),\n",
                d.tag1,
                d.field_name,
                d.method_symbol
            );
        } else {
            w!(
                self.printer,
                "{} => s.read_message_to(&mut self.{})?,\n",
                d.tag1,
                d.field_name
            );
        }
        if d.tag1 != d.tag2 && d.tag2 != 0 {
            w!(
                self.printer,
                "{} => s.read_{}_array(&mut self.{})?,\n",
                d.tag2,
                d.method_symbol,
                d.field_name
            );
        }
    }

    fn print_merge_from_oneof(&mut self, o: &OneOfDecl) {
        for item in &o.items {
            match item {
                FieldType::Optional(d) => {
                    if d.method_symbol != "message" {
                        w!(
                            self.printer,
                            "{} => self.{} = Some({}::{}(s.read_{}()?)),\n",
                            d.tag1,
                            o.field_name,
                            o.type_name,
                            naming::camel_case(&d.field_name),
                            d.method_symbol
                        );
                        continue;
                    }

                    w!(self.printer, "{} => {{\n", d.tag1);
                    self.printer.indent();
                    w!(
                        self.printer,
                        "let msg = self.{}.{}_mut();\n",
                        o.field_name,
                        d.field_name
                    );
                    w!(self.printer, "s.read_message(msg)?;\n");
                    self.printer.outdent();
                    w!(self.printer, "}}\n");
                }
                FieldType::Singlular(d) => {
                    w!(
                        self.printer,
                        "{} => self.{} = Some({}::{}(self.read_{}()?)),\n",
                        d.tag1,
                        o.field_name,
                        o.type_name,
                        naming::camel_case(&d.field_name),
                        d.method_symbol
                    );
                }
                FieldType::Repeated(_) | FieldType::Oneof(_) => unreachable!(),
            }
        }
    }

    fn print_merge_from(&mut self, field_sets: &[FieldType]) {
        w!(
            self.printer,
            "fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {{\n"
        );
        self.printer.indent();
        w!(self.printer, "loop {{\n");
        self.printer.indent();
        w!(self.printer, "let tag = s.read_tag()?;\nmatch tag {{\n");
        self.printer.indent();
        for ft in field_sets {
            match ft {
                FieldType::Optional(d) => self.print_merge_from_optional(d),
                FieldType::Singlular(d) => self.print_merge_from_singlular(d),
                FieldType::Repeated(d) => self.print_merge_from_repeated(d),
                FieldType::Oneof(d) => self.print_merge_from_oneof(d),
            }
        }
        w!(
            self.printer,
            "0 => return Ok(()),\n_ => s.skip_field(&mut self.unknown, tag)?,\n"
        );
        for _ in 0..3 {
            self.printer.outdent();
            w!(self.printer, "}}\n");
        }
    }

    fn print_write_to_raw(&mut self, d: &FieldDecl, method_symbol: &str, field: &str) {
        let tag = if d.tag2 == 0 { d.tag1 } else { d.tag2 };
        let mut buffer = [0u8; 5];
        let count =
            unsafe { pecan_utils::codec::encode_varint_u32_to_array(buffer.as_mut_ptr(), tag) };
        w!(
            self.printer,
            "s.write_raw_{}_byte({:?})?;\n",
            count,
            &buffer[..count]
        );
        if method_symbol != "message" {
            w!(self.printer, "s.write_{}({})?;\n", method_symbol, field);
        } else {
            w!(self.printer, "s.write_message({})?;\n", field);
        }
    }

    fn print_write_to_repeated(&mut self, d: &FieldDecl) {
        w!(self.printer, "if !self.{}.is_empty() {{\n", d.field_name);
        self.printer.indent();
        if d.copy {
            let method_symbol = format!("{}_array", d.method_symbol);
            let field = format!("&self.{}", d.field_name);
            self.print_write_to_raw(d, &method_symbol, &field);
        } else {
            w!(self.printer, "for v in &self.{} {{\n", d.field_name);
            self.printer.indent();
            self.print_write_to_raw(d, d.method_symbol, "v");
            self.printer.outdent();
            w!(self.printer, "}}\n");
        }
        self.printer.outdent();
        w!(self.printer, "}}\n");
    }

    fn print_write_to(&mut self, field_sets: &[FieldType]) {
        w!(
            self.printer,
            "\nfn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {{\n"
        );
        self.printer.indent();
        for ft in field_sets {
            match ft {
                FieldType::Optional(d) => self.print_write_to_optional(d),
                FieldType::Singlular(d) => self.check_print_singlular(d, Self::print_write_to_raw),
                FieldType::Repeated(d) => self.print_write_to_repeated(d),
                FieldType::Oneof(d) => self.check_print_oneof(d, Self::print_write_to_raw),
            }
        }
        w!(self.printer, "if !self.unknown.is_empty() {{\n");
        self.printer.indent();
        w!(self.printer, "s.write_unknown(&self.unknown)?;\n");
        self.printer.outdent();
        w!(self.printer, "}}\nOk(())\n");
        self.printer.outdent();
        w!(self.printer, "}}\n");
    }

    fn print_len_raw(&mut self, d: &FieldDecl, method_symbol: &str, field: &str) {
        let tag = if d.tag2 == 0 { d.tag1 } else { d.tag2 };
        let tag_len = pecan::encoded::var_u32_len(tag);
        if method_symbol == "bool" {
            w!(self.printer, "n += {};\n", tag_len + 1);
        } else if method_symbol.starts_with("arr_") {
            if !d.copy {
                w!(
                    self.printer,
                    "n += encoded::{}_len({}, &self.{});\n",
                    method_symbol,
                    tag_len,
                    d.field_name
                );
            } else {
                w!(
                    self.printer,
                    "n += {} + encoded::{}_len({});\n",
                    tag_len,
                    method_symbol,
                    field
                );
            }
        } else if method_symbol.ends_with("f64") || method_symbol.ends_with("fixed64") {
            w!(self.printer, "n += {};\n", tag_len + 8);
        } else if method_symbol == "f32" || method_symbol.ends_with("fixed32") {
            w!(self.printer, "n += {};\n", tag_len + 4);
        } else {
            w!(
                self.printer,
                "n += {} + encoded::{}_len({});\n",
                tag_len,
                method_symbol,
                field
            );
        }
    }

    fn print_write_to_optional(&mut self, d: &FieldDecl) {
        if d.copy {
            w_scope!(self.printer, "if let Some(v) = self.{} {{\n", d.field_name);
        } else {
            w_scope!(self.printer, "if let Some(v) = &self.{} {{\n", d.field_name);
        }
        self.print_write_to_raw(d, d.method_symbol, "v");
        w_end_scope!(self.printer, "}}\n");
    }

    fn print_len_optional(&mut self, d: &FieldDecl) {
        if d.copy {
            if d.method_symbol.contains("fixed")
                || d.method_symbol.starts_with('f')
                || d.method_symbol == "bool"
            {
                w_scope!(self.printer, "if self.{}.is_some() {{\n", d.field_name);
            } else {
                w_scope!(self.printer, "if let Some(v) = self.{} {{\n", d.field_name);
            }
        } else {
            w_scope!(self.printer, "if let Some(v) = &self.{} {{\n", d.field_name);
        }
        self.print_len_raw(d, d.method_symbol, "v");
        w_end_scope!(self.printer, "}}\n");
    }

    fn check_print_singlular(
        &mut self,
        d: &FieldDecl,
        f: impl FnOnce(&mut Self, &FieldDecl, &str, &str),
    ) {
        if !d.default_val.is_empty() {
            w!(
                self.printer,
                "if {} != self.{} {{\n",
                d.default_val,
                d.field_name
            );
        } else if d.method_symbol == "bool" {
            w!(self.printer, "if self.{} {{\n", d.field_name);
        } else if d.method_symbol == "enum" {
            w!(self.printer, "if self.{}.value() != 0 {{\n", d.field_name);
        } else {
            w!(self.printer, "if !self.{}.is_empty() {{\n", d.field_name);
        }
        self.printer.indent();
        let field = if d.copy {
            format!("self.{}", d.field_name)
        } else {
            format!("&self.{}", d.field_name)
        };
        f(self, d, d.method_symbol, &field);
        self.printer.outdent();
        w!(self.printer, "}}\n");
    }

    fn check_print_repeated(
        &mut self,
        d: &FieldDecl,
        f: impl FnOnce(&mut Self, &FieldDecl, &str, &str),
    ) {
        w!(self.printer, "if !self.{}.is_empty() {{\n", d.field_name);
        self.printer.indent();
        let method_symbol = format!("arr_{}", d.method_symbol);
        let field = format!("&self.{}", d.field_name);
        f(self, d, &method_symbol, &field);
        self.printer.outdent();
        w!(self.printer, "}}\n");
    }

    fn check_print_oneof(&mut self, o: &OneOfDecl, f: impl Fn(&mut Self, &FieldDecl, &str, &str)) {
        if o.copy {
            w!(self.printer, "if let Some(v) = self.{} {{\n", o.field_name);
        } else {
            w!(self.printer, "if let Some(v) = &self.{} {{\n", o.field_name);
        }
        self.printer.indent();
        w!(self.printer, "match v {{\n");
        self.printer.indent();
        for item in &o.items {
            let d = match item {
                FieldType::Optional(d) | FieldType::Singlular(d) => d,
                FieldType::Repeated(_) | FieldType::Oneof(_) => unreachable!(),
            };
            w!(
                self.printer,
                "{}::{}(v) => {{\n",
                o.type_name,
                naming::camel_case(&d.field_name)
            );
            self.printer.indent();
            f(self, d, d.method_symbol, "v");
            self.printer.outdent();
            w!(self.printer, "}}\n");
        }
        for _ in 0..2 {
            self.printer.outdent();
            w!(self.printer, "}}\n");
        }
    }

    fn print_len(&mut self, field_sets: &[FieldType]) {
        w!(self.printer, "\nfn len(&self) -> usize {{\n");
        self.printer.indent();
        w!(self.printer, "let mut n = self.unknown.len();\n");
        for ft in field_sets {
            match ft {
                FieldType::Optional(d) => self.print_len_optional(d),
                FieldType::Singlular(d) => self.check_print_singlular(d, Self::print_len_raw),
                FieldType::Repeated(d) => self.check_print_repeated(d, Self::print_len_raw),
                FieldType::Oneof(o) => self.check_print_oneof(o, Self::print_len_raw),
            }
        }
        w!(self.printer, "n\n");
        w_end_scope!(self.printer, "}}\n");
    }

    fn print_default_instance(&mut self, type_name: &str, field_sets: &[FieldType]) {
        w_scope!(self.printer, "pub const fn new() -> {} {{\n", type_name);
        w_scope!(self.printer, "{} {{\n", type_name);
        for ft in field_sets {
            match ft {
                FieldType::Optional(d) => {
                    w!(self.printer, "{}: None,\n", d.field_name);
                }
                FieldType::Singlular(d) => {
                    if !d.default_val.is_empty() {
                        w!(self.printer, "{}: {},\n", d.field_name, d.default_val);
                    } else if d.method_symbol == "bool" {
                        w!(self.printer, "{}: false,\n", d.field_name);
                    } else if d.method_symbol == "string" {
                        w!(self.printer, "{}: String::new(),\n", d.field_name);
                    } else if d.method_symbol == "bytes" {
                        w!(self.printer, "{}: Vec::new(),\n", d.field_name);
                    } else {
                        w!(self.printer, "{}: {}::new(),\n", d.field_name, d.type_name);
                    }
                }
                FieldType::Repeated(d) => {
                    w!(self.printer, "{}: Vec::new(),\n", d.field_name);
                }
                FieldType::Oneof(o) => {
                    w!(self.printer, "{}: None,\n", o.field_name);
                }
            }
        }
        w!(self.printer, "cache_size: 0,\nunknown: Vec::new(),\n");
        w_end_scope!(self.printer, "}}\n");
        w_end_scope!(self.printer, "}}\n");
        w_scope!(
            self.printer,
            "\npub fn default_instance() -> &'static {} {{\n",
            type_name
        );
        w!(
            self.printer,
            "static DEFAULT: {} = {}::new();\n",
            type_name,
            type_name
        );
        w!(self.printer, "&DEFAULT\n");
        w_end_scope!(self.printer, "}}\n");
    }

    fn print_field_accessors_optional(&mut self, d: &FieldDecl) {
        if d.copy {
            w_scope!(
                self.printer,
                "\npub fn {}(&self) -> {} {{\n",
                d.field_name,
                d.type_name
            );
        } else if d.method_symbol == "bytes" {
            w_scope!(
                self.printer,
                "\npub fn {}(&self) -> &[u8] {{\n",
                d.field_name
            );
        } else if d.method_symbol == "string" {
            w_scope!(
                self.printer,
                "\npub fn {}(&self) -> &str {{\n",
                d.field_name
            );
        } else {
            w_scope!(
                self.printer,
                "\npub fn {}(&self) -> &{} {{\n",
                d.field_name,
                d.type_name
            );
        }
        if d.copy {
            w!(self.printer, "self.{}.unwrap_or_default()\n", d.field_name);
        } else if d.method_symbol == "bytes" {
            w!(
                self.printer,
                "self.{}.as_ref().map_or(&[], |s| s.as_slice())\n",
                d.field_name
            );
        } else if d.method_symbol == "string" {
            w!(
                self.printer,
                "self.{}.as_ref().map_or(\"\", |s| s.as_str())\n",
                d.field_name
            );
        } else {
            w!(
                self.printer,
                "self.{}.as_ref().unwrap_or_else(|| {}::default_instance())\n",
                d.field_name,
                d.type_name
            );
        }
        w_end_scope!(self.printer, "}}\n");
        w!(
            self.printer,
            "\npub fn clear_{}(&mut self) {{ self.{} = None; }}\n",
            d.strip_field_name(),
            d.field_name
        );
        w!(
            self.printer,
            "\npub fn has_{}(&self) -> bool {{ self.{}.is_some() }}\n",
            d.strip_field_name(),
            d.field_name
        );
        w!(
            self.printer,
            "\npub fn set_{}(&mut self, v: {}) {{ self.{} = Some(v); }}\n",
            d.strip_field_name(),
            d.type_name,
            d.field_name
        );
        if d.copy {
            return;
        }

        w_scope!(
            self.printer,
            "\npub fn {}_mut(&mut self) -> &mut {} {{\n",
            d.strip_field_name(),
            d.type_name
        );
        w!(
            self.printer,
            "self.{}.get_or_insert_with(Default::default)\n",
            d.field_name
        );
        w_end_scope!(self.printer, "}}\n");
    }

    fn print_field_accessors_singlular(&mut self, d: &FieldDecl) {
        if d.copy {
            w!(
                self.printer,
                "\npub fn {}(&self) -> {} {{ self.{} }}\n",
                d.field_name,
                d.type_name,
                d.field_name
            );
        } else if d.method_symbol == "bytes" {
            w!(
                self.printer,
                "\npub fn {}(&self) -> &[u8] {{ &self.{} }}\n",
                d.field_name,
                d.field_name
            );
        } else if d.method_symbol == "string" {
            w!(
                self.printer,
                "\npub fn {}(&self) -> &str {{ &self.{} }}\n",
                d.field_name,
                d.field_name
            );
        }
        if !d.default_val.is_empty() {
            w!(
                self.printer,
                "\npub fn clear_{}(&mut self) {{ self.{} = {}; }}\n",
                d.strip_field_name(),
                d.field_name,
                d.default_val
            );
        } else if d.method_symbol == "bool" {
            w!(
                self.printer,
                "\npub fn clear_{}(&mut self) {{ self.{} = false; }}\n",
                d.strip_field_name(),
                d.field_name
            );
        } else {
            w!(
                self.printer,
                "\npub fn clear_{}(&mut self) {{ self.{} = Default::default(); }}\n",
                d.strip_field_name(),
                d.field_name
            );
        }
        w!(
            self.printer,
            "\npub fn set_{}(&mut self, v: {}) {{ self.{} = v; }}\n",
            d.strip_field_name(),
            d.type_name,
            d.field_name
        );
        if d.copy {
            return;
        }
        w!(
            self.printer,
            "\npub fn {}_mut(&mut self) -> &mut {} {{ &mut self.{} }}\n",
            d.strip_field_name(),
            d.type_name,
            d.field_name
        );
    }

    fn print_field_accessors_repeated(&mut self, d: &FieldDecl) {
        w!(
            self.printer,
            "\npub fn {}(&self) -> &[{}] {{ &self.{} }}\n",
            d.field_name,
            d.type_name,
            d.field_name
        );
        w!(
            self.printer,
            "\npub fn clear_{}(&mut self) {{ self.{}.clear(); }}\n",
            d.strip_field_name(),
            d.field_name
        );
        w!(
            self.printer,
            "\npub fn set_{}(&mut self, v: impl Into<Vec<{}>>) {{ self.{} = v.into(); }}\n",
            d.strip_field_name(),
            d.type_name,
            d.field_name
        );
        w!(
            self.printer,
            "\npub fn {}_mut(&mut self) -> &mut Vec<{}> {{ &mut self.{} }}\n",
            d.strip_field_name(),
            d.type_name,
            d.field_name
        );
    }

    fn print_field_accessors_oneof(&mut self, o: &OneOfDecl) {
        for ft in &o.items {
            let d = match ft {
                FieldType::Optional(d) | FieldType::Singlular(d) => d,
                FieldType::Repeated(_) | FieldType::Oneof(_) => unreachable!(),
            };
            if d.copy {
                w_scope!(
                    self.printer,
                    "\npub fn {}(&self) -> {} {{\n",
                    d.field_name,
                    d.type_name
                );
            } else if d.method_symbol == "bytes" {
                w_scope!(
                    self.printer,
                    "\npub fn {}(&self) -> &[u8] {{\n",
                    d.field_name
                );
            } else if d.method_symbol == "string" {
                w_scope!(
                    self.printer,
                    "\npub fn {}(&self) -> &str {{\n",
                    d.field_name
                );
            } else {
                w_scope!(
                    self.printer,
                    "\npub fn {}(&self) -> &{} {{\n",
                    d.field_name,
                    d.type_name
                );
            }
            if d.copy {
                w_scope!(self.printer, "match self.{} {{\n", o.field_name);
            } else {
                w_scope!(self.printer, "match &self.{} {{\n", o.field_name);
            }
            w!(
                self.printer,
                "Some({}::{}(v)) => v\n",
                o.type_name,
                naming::camel_case(&d.field_name)
            );
            if d.copy {
                w!(self.printer, "_ => Default::default(),\n");
            } else if d.method_symbol == "bytes" {
                w!(self.printer, "_ => &[],\n");
            } else if d.method_symbol == "string" {
                w!(self.printer, "_ => \"\",\n");
            } else {
                w!(self.printer, "_ => {}::default_instance(),\n", d.type_name);
            }
            w_end_scope!(self.printer, "}}\n");
            w_end_scope!(self.printer, "}}\n");
            w_scope!(
                self.printer,
                "\npub fn clear_{}(&mut self) {{\n",
                d.strip_field_name()
            );
            w_scope!(
                self.printer,
                "if let Some({}::{}(_)) = self.{} {{\n",
                o.type_name,
                naming::camel_case(&d.field_name),
                o.field_name
            );
            w!(self.printer, "self.{} = None;\n", o.field_name);
            w_end_scope!(self.printer, "}}\n");
            w_end_scope!(self.printer, "}}\n");
            w_scope!(
                self.printer,
                "\npub fn set_{}(&mut self, v: {}) {{\n",
                d.strip_field_name(),
                d.type_name
            );
            w!(
                self.printer,
                "self.{} = Some({}::{}(v));\n",
                o.field_name,
                o.type_name,
                naming::camel_case(&d.field_name)
            );
            w_end_scope!(self.printer, "}}\n");
            if d.copy {
                return;
            }
            w_scope!(
                self.printer,
                "\npub fn {}_mut(&mut self) -> &mut {} {{\n",
                d.strip_field_name(),
                d.type_name
            );
            w_scope!(
                self.printer,
                "if let Some({}::{}(v)) = &mut self.{} {{\n",
                o.type_name,
                naming::camel_case(&d.field_name),
                o.field_name
            );
            w!(self.printer, "return v;\n");
            w_end_scope!(self.printer, "}}\n");
            w!(
                self.printer,
                "self.{} = Some({}::{}(Default::default());\n",
                o.field_name,
                o.type_name,
                naming::camel_case(&d.field_name)
            );
            w_scope!(
                self.printer,
                "if let Some({}::{}(v)) = &mut self.{} {{\n",
                o.type_name,
                naming::camel_case(&d.field_name),
                o.field_name
            );
            w!(self.printer, "return v;\n");
            w_end_scope!(self.printer, "}} else {{ unreachable!() }}\n");
            w_end_scope!(self.printer, "}}\n");
        }
    }

    fn print_field_accessors(&mut self, field_sets: &[FieldType]) {
        for ft in field_sets {
            match ft {
                FieldType::Optional(d) => self.print_field_accessors_optional(d),
                FieldType::Singlular(d) => self.print_field_accessors_singlular(d),
                FieldType::Repeated(d) => self.print_field_accessors_repeated(d),
                FieldType::Oneof(d) => self.print_field_accessors_oneof(d),
            }
        }
    }

    /// If m is nested message, it will be named as `Prefix1NestedPrefix2Nested...Name`.
    fn print_message(&mut self, ctx: &Context, id: Id<MessageDescriptor>) {
        w!(
            self.printer,
            "\n#[derive(Clone, Debug, Default, PartialEq)]\n"
        );
        let m = ctx.db.messages.get(id).unwrap();
        let name = naming::type_name(&m.type_name);
        w!(self.printer, "pub struct {} {{\n", name);
        self.printer.indent();
        let field_sets = self.build_field_set(ctx, &m);
        self.print_field_decl(&field_sets);
        w!(self.printer, "cache_size: u32,\nunknown: Vec<u8>,\n");
        self.printer.outdent();
        w!(self.printer, "}}\n");

        self.print_oneof_decl(&field_sets);

        w!(self.printer, "\nimpl Message for {} {{\n", name);
        self.printer.indent();

        self.print_merge_from(&field_sets);
        self.print_write_to(&field_sets);
        self.print_len(&field_sets);

        self.printer.outdent();
        w!(self.printer, "}}\n");

        w!(self.printer, "\nimpl {} {{\n", name);
        self.printer.indent();
        self.print_default_instance(&name, &field_sets);
        self.print_field_accessors(&field_sets);
        self.printer.outdent();
        w!(self.printer, "}}\n");
    }

    fn print_messages(&mut self, ctx: &Context) {
        let messages = &ctx.db.files.get(self.file).unwrap().messages;
        for m in messages {
            self.print_message(ctx, *m);
        }
    }

    pub fn generate(&mut self, ctx: &Context) -> Result<()> {
        self.print_top_boilerplate();
        self.print_imports(ctx);
        self.print_file_descriptor(ctx)?;
        self.print_enums(ctx);
        self.print_messages(ctx);
        Ok(())
    }
}
