use crate::context::{Context, Output, Printer};
use crate::descriptor::{EnumDescriptor, FileDescriptor, MessageDescriptor};
use crate::pecan_descriptor::google::protobuf::descriptor_pb::*;
use id_arena::Id;
use pecan::Message;
use pecan::Result;
use pecan_utils::naming;
use std::fmt::Write;
use std::{env, result};

pub struct Generator<'a> {
    printer: Printer<'a>,
    file: Id<FileDescriptor>,
    file_name: String,
}

impl Generator<'_> {
    pub fn new<'a>(
        ctx: &Context,
        output: &'a mut Output,
        file: Id<FileDescriptor>,
    ) -> Generator<'a> {
        let input_file_name = ctx.db.files.get(file).unwrap().proto.name.clone();
        let module_name = naming::module_name(&input_file_name);
        let output_file_name = naming::file_name(&module_name);
        let printer = output.open(&output_file_name);
        Generator {
            printer,
            file,
            file_name: input_file_name,
        }
    }

    fn print_top_boilerplate(&mut self) {
        w!(
            self.printer,
            "// This file is generated by pecan {version}, DO NOT EDIT!
// @generated
// source: {file_name}
",
            version = env!("CARGO_PKG_VERSION"),
            file_name = self.file_name
        );
        w!(self.printer, "\n");
        w!(
            self.printer,
            "#![allow(non_upper_case_globals)]\n#![allow(unused_imports)]\n"
        );
    }

    fn print_imports(&mut self, ctx: &Context) {
        w!(self.printer, "\n");
        w!(
            self.printer,
            "use pecan::{{
    EnumType,
    Message,
    Result,
    Buf,
    BufMut,
    CodedInputStream,
    CodedOutputStream,
    CacheSize,
    encoded,
}};\n"
        );
        let f = ctx.db.files.get(self.file).unwrap();
        if f.proto.dependency.is_empty() {
            return;
        }

        w!(self.printer, "\n");
        for dependency in &f.proto.dependency {
            let id = *ctx.files.get(dependency).unwrap();
            let dep = &ctx.db.files.get(id).unwrap();
            let module_name = naming::module_name(&dep.proto.name);
            let module_alias = naming::alias_name(&dep.proto.name);
            w!(
                self.printer,
                "use crate::{module_name} as {module_alias};\n",
                module_name = module_name,
                module_alias = module_alias
            );
        }
    }

    fn print_file_descriptor(&mut self, ctx: &Context) -> Result<()> {
        let mut proto = ctx.db.files.get(self.file).unwrap().proto.clone();
        proto.source_code_info.take();
        let bytes = proto.write_as_bytes()?;
        w!(self.printer, "\npub static DESCRIPTOR: &[u8] = &[\n");
        self.printer.indent();
        for chunk in bytes.chunks(16) {
            for b in &chunk[..chunk.len() - 1] {
                w!(self.printer, "{}, ", b);
            }
            w!(self.printer, "{},\n", chunk[chunk.len() - 1]);
        }
        self.printer.outdent();
        w!(self.printer, "];\n");
        Ok(())
    }

    fn print_enum(&mut self, ctx: &Context, id: Id<EnumDescriptor>) {
        w!(
            self.printer,
            "\n#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]\n"
        );
        let e = ctx.db.enums.get(id).unwrap();
        let name = naming::type_name(&e.type_name);
        w!(self.printer, "pub struct {}(i32);\n\n", name);

        w!(self.printer, "impl {} {{\n", name);
        self.printer.indent();
        for v in &e.proto.value {
            let enum_name = naming::camel_case(&v.name);
            w!(
                self.printer,
                "pub const {}: {} = {}({});\n",
                enum_name,
                name,
                name,
                v.number
            );
        }
        self.printer.outdent();
        w!(self.printer, "}}\n\n");

        w!(self.printer, "impl From<i32> for {} {{\n", name);
        self.printer.indent();
        w!(self.printer, "#[inline]\nfn from(u: i32) -> {} {{\n", name);
        self.printer.indent();
        w!(self.printer, "{}(u)\n", name);
        self.printer.outdent();
        w!(self.printer, "}}\n");
        self.printer.outdent();
        w!(self.printer, "}}\n\n");

        w!(self.printer, "impl EnumType for {} {{\n", name);
        self.printer.indent();
        w!(
            self.printer,
            "#[inline]\nfn values() -> &'static [{}] {{\n",
            name
        );
        self.printer.indent();
        w!(self.printer, "&[\n");
        self.printer.indent();
        for v in &e.proto.value {
            let enum_name = naming::camel_case(&v.name);
            w!(self.printer, "{}::{},\n", name, enum_name);
        }
        self.printer.outdent();
        w!(self.printer, "]\n");
        self.printer.outdent();
        w!(
            self.printer,
            "}}\n\n#[inline]\nfn value(&self) -> i32 {{ self.0 }}\n"
        );
        self.printer.outdent();
        w!(self.printer, "}}\n");
    }

    fn print_enums(&mut self, ctx: &Context) {
        let enums = &ctx.db.files.get(self.file).unwrap().enums;
        for e in enums {
            self.print_enum(ctx, *e);
        }
    }

    fn search_type(
        &self,
        ctx: &Context,
        f: &FieldDescriptorProto,
    ) -> result::Result<&'static str, String> {
        let (file, mut type_name) = match f.r#type {
            FieldDescriptorProtoNestedType::TypeBool => return Ok("bool"),
            FieldDescriptorProtoNestedType::TypeUint32
            | FieldDescriptorProtoNestedType::TypeFixed32 => return Ok("u32"),
            FieldDescriptorProtoNestedType::TypeUint64
            | FieldDescriptorProtoNestedType::TypeFixed64 => return Ok("u64"),
            FieldDescriptorProtoNestedType::TypeInt32
            | FieldDescriptorProtoNestedType::TypeSfixed32
            | FieldDescriptorProtoNestedType::TypeSint32 => return Ok("i32"),
            FieldDescriptorProtoNestedType::TypeInt64
            | FieldDescriptorProtoNestedType::TypeSfixed64
            | FieldDescriptorProtoNestedType::TypeSint64 => return Ok("i64"),
            FieldDescriptorProtoNestedType::TypeString => return Ok("String"),
            FieldDescriptorProtoNestedType::TypeBytes => return Ok("Vec<u8>"),
            FieldDescriptorProtoNestedType::TypeDouble => return Ok("f64"),
            FieldDescriptorProtoNestedType::TypeFloat => return Ok("f32"),
            FieldDescriptorProtoNestedType::TypeMessage
            | FieldDescriptorProtoNestedType::TypeGroup => {
                let id = ctx.message_address.get(&f.type_name).expect(&f.type_name);
                let m = ctx.db.messages.get(*id).expect(&f.type_name);
                (m.file, naming::type_name(&m.type_name))
            }
            FieldDescriptorProtoNestedType::TypeEnum => {
                let id = ctx.enum_address.get(&f.type_name).unwrap();
                let e = ctx.db.enums.get(*id).unwrap();
                (e.file, naming::type_name(&e.type_name))
            }
            _ => unimplemented!(),
        };

        if file != self.file {
            let f = ctx.db.files.get(file).unwrap();
            type_name = format!("{}::{}", naming::alias_name(&f.proto.name), type_name)
        }

        Err(type_name)
    }

    fn wire_type(&self, f: &FieldDescriptorProto) -> (u32, &'static str) {
        match f.r#type {
            FieldDescriptorProtoNestedType::TypeBool => (0, "bool"),
            FieldDescriptorProtoNestedType::TypeInt32 => (0, "var_i32"),
            FieldDescriptorProtoNestedType::TypeInt64 => (0, "var_i64"),
            FieldDescriptorProtoNestedType::TypeUint32 => (0, "var_u32"),
            FieldDescriptorProtoNestedType::TypeUint64 => (0, "var_u64"),
            FieldDescriptorProtoNestedType::TypeSint32 => (0, "var_s32"),
            FieldDescriptorProtoNestedType::TypeSint64 => (0, "var_s64"),
            FieldDescriptorProtoNestedType::TypeEnum => (0, "enum"),
            FieldDescriptorProtoNestedType::TypeFixed64 => (1, "fixed64"),
            FieldDescriptorProtoNestedType::TypeSfixed64 => (1, "sfixed64"),
            FieldDescriptorProtoNestedType::TypeDouble => (1, "f64"),
            FieldDescriptorProtoNestedType::TypeString => (2, "string"),
            FieldDescriptorProtoNestedType::TypeBytes => (2, "bytes"),
            FieldDescriptorProtoNestedType::TypeMessage => (2, ""),
            FieldDescriptorProtoNestedType::TypeGroup => unimplemented!(),
            FieldDescriptorProtoNestedType::TypeFixed32 => (5, "fixed32"),
            FieldDescriptorProtoNestedType::TypeSfixed32 => (5, "sfixed32"),
            FieldDescriptorProtoNestedType::TypeFloat => (5, "f32"),
            _ => unimplemented!(),
        }
    }

    fn match_merge_from_repeated(&mut self, number: u32, wire_type: u32, name: &str, ty: &str) {
        let tag = (number << 3) | wire_type;
        if !ty.is_empty() {
            w!(
                self.printer,
                "{} => self.{}.push(s.read_{}()?),\n",
                tag,
                name,
                ty
            );
        } else {
            assert_eq!(wire_type, 2);
            w!(
                self.printer,
                "{} => s.read_message_to(&mut self.{})?,\n",
                tag,
                name
            );
        }
        if wire_type != 2 && wire_type != 3 && wire_type != 4 {
            let packed_tag = (number << 3) | 2;
            w!(
                self.printer,
                "{} => s.read_{}_array(&mut self.{})?,\n",
                packed_tag,
                ty,
                name
            );
        }
    }

    fn match_merge_from_single(&mut self, number: u32, wire_type: u32, name: &str, ty: &str) {
        let tag = (number << 3) | wire_type;
        if !ty.is_empty() {
            w!(
                self.printer,
                "{} => self.{} = s.read_{}()?,\n",
                tag,
                name,
                ty
            );
        } else {
            assert_eq!(wire_type, 2);
            w!(self.printer, "{} => {{\n", tag);
            self.printer.indent();
            w!(
                self.printer,
                "let msg = self.{}.get_or_insert_with(Default::default);\n",
                name
            );
            w!(self.printer, "s.read_message(msg)?;\n");
            self.printer.outdent();
            w!(self.printer, "}}\n");
        }
    }

    fn match_merge_from(&mut self, f: &FieldDescriptorProto) {
        let name = naming::field_name(&f.name);
        let (wire_type, ty) = self.wire_type(f);
        match f.label {
            FieldDescriptorProtoNestedLabel::LabelRepeated => {
                self.match_merge_from_repeated(f.number as u32, wire_type, &name, ty)
            }
            _ => self.match_merge_from_single(f.number as u32, wire_type, &name, ty),
        }
    }

    fn field_write_to(&mut self, f: &FieldDescriptorProto) {
        let name = naming::field_name(&f.name);
        let (wire_type, ty) = self.wire_type(f);
        if f.label == FieldDescriptorProtoNestedLabel::LabelRepeated
            || (wire_type == 2 && !ty.is_empty())
        {
            w!(self.printer, "if !self.{}.is_empty() {{\n", name);
            self.printer.indent();
        } else if f.r#type == FieldDescriptorProtoNestedType::TypeBool {
            w!(self.printer, "if self.{} {{\n", name);
            self.printer.indent();
        } else if f.r#type == FieldDescriptorProtoNestedType::TypeEnum {
            w!(self.printer, "if self.{}.value() != 0 {{\n", name);
            self.printer.indent();
        } else if wire_type == 3 {
            unimplemented!()
        } else if !ty.is_empty() {
            let zero_ty = if ty == "f64" || ty == "f32" { ty } else { "" };
            w!(self.printer, "if self.{} != 0{} {{\n", name, zero_ty);
            self.printer.indent();
        }

        let tag = if f.label == FieldDescriptorProtoNestedLabel::LabelRepeated {
            (f.number as u32) << 3 | 2
        } else {
            (f.number as u32) << 3 | wire_type as u32
        };
        let mut buffer = [0u8; 5];
        let count =
            unsafe { pecan_utils::codec::encode_varint_u32_to_array(buffer.as_mut_ptr(), tag) };
        if f.label == FieldDescriptorProtoNestedLabel::LabelRepeated {
            if wire_type != 2 {
                w!(
                    self.printer,
                    "s.write_raw_{}_byte({:?})?;\n",
                    count,
                    &buffer[..count]
                );
                w!(self.printer, "s.write_{}_array(&self.{})?;\n", ty, name);
            } else {
                w!(self.printer, "for m in &self.{} {{\n", name);
                self.printer.indent();
                w!(
                    self.printer,
                    "s.write_raw_{}_byte({:?})?;\n",
                    count,
                    &buffer[..count]
                );
                if ty.is_empty() {
                    w!(self.printer, "s.write_message(m)?;\n");
                } else {
                    w!(self.printer, "s.write_{}(m)?;\n", ty);
                }
                self.printer.outdent();
                w!(self.printer, "}}\n");
            }
        } else if !ty.is_empty() {
            w!(
                self.printer,
                "s.write_raw_{}_byte({:?})?;\n",
                count,
                &buffer[..count]
            );
            if wire_type == 2 {
                w!(self.printer, "s.write_{}(&self.{})?;\n", ty, name);
            } else {
                w!(self.printer, "s.write_{}(self.{})?;\n", ty, name);
            }
        } else {
            w!(self.printer, "if let Some(m) = &self.{} {{\n", name);
            w!(
                self.printer,
                "s.write_raw_{}_byte({:?})?;\n",
                count,
                &buffer[..count]
            );
            self.printer.indent();
            w!(
                self.printer,
                "s.write_raw_{}_byte({:?})?;\n",
                count,
                &buffer[..count]
            );
            w!(self.printer, "s.write_message(m)?;\n");
        }
        self.printer.outdent();
        w!(self.printer, "}}\n");
    }

    fn field_len(&mut self, f: &FieldDescriptorProto) {
        let name = naming::field_name(&f.name);
        let (wire_type, ty) = self.wire_type(f);
        let tag = ((f.number as u32) << 3) | wire_type as u32;
        let tag_len = pecan::encoded::var_u32_len(tag);
        if f.label == FieldDescriptorProtoNestedLabel::LabelRepeated
            || (wire_type == 2 && !ty.is_empty())
        {
            let tag = ((f.number as u32) << 3) | 2;
            let tag_len = pecan::encoded::var_u32_len(tag);
            w!(self.printer, "if !self.{}.is_empty() {{\n", name);
            self.printer.indent();
            if f.label == FieldDescriptorProtoNestedLabel::LabelRepeated {
                if wire_type != 2 {
                    w!(
                        self.printer,
                        "n += {} + encoded::arr_{}_len(&self.{});\n",
                        tag_len,
                        ty,
                        name
                    );
                } else if !ty.is_empty() {
                    w!(
                        self.printer,
                        "n += encoded::arr_{}_len({}, &self.{});\n",
                        ty,
                        tag_len,
                        name
                    );
                } else {
                    w!(
                        self.printer,
                        "n += encoded::arr_message_len({}, &self.{});\n",
                        tag_len,
                        name
                    );
                }
            } else {
                w!(
                    self.printer,
                    "n += {} + encoded::{}_len(&self.{});\n",
                    tag_len,
                    ty,
                    name
                );
            }
        } else if f.r#type == FieldDescriptorProtoNestedType::TypeBool {
            w!(self.printer, "if self.{} {{\n", name);
            self.printer.indent();
            w!(self.printer, "n += {};\n", tag_len + 1);
        } else if f.r#type == FieldDescriptorProtoNestedType::TypeEnum {
            w!(self.printer, "if self.{}.value() != 0 {{\n", name);
            self.printer.indent();
            w!(
                self.printer,
                "n += {} + encoded::var_i32_len(self.{}.value());\n",
                tag_len,
                name
            );
        } else if wire_type == 3 {
            unimplemented!()
        } else if ty.is_empty() {
            w!(self.printer, "if let Some(msg) = &self.{} {{\n", name);
            self.printer.indent();
            w!(
                self.printer,
                "n += {} + encoded::message_len(msg);\n",
                tag_len
            );
        } else {
            let zero_ty = if ty == "f64" || ty == "f32" { ty } else { "" };
            w!(self.printer, "if self.{} != 0{} {{\n", name, zero_ty);
            self.printer.indent();
            if wire_type == 1 {
                w!(self.printer, "n += {};\n", tag_len + 8);
            } else if wire_type == 5 {
                w!(self.printer, "n += {};\n", tag_len + 4);
            } else {
                w!(
                    self.printer,
                    "n += {} + encoded::{}_len(self.{});\n",
                    tag_len,
                    ty,
                    name
                );
            }
        }
        self.printer.outdent();
        w!(self.printer, "}}\n");
    }

    /// If m is nested message, it will be named as `Prefix1NestedPrefix2Nested...Name`.
    fn print_message(&mut self, ctx: &Context, id: Id<MessageDescriptor>) {
        w!(self.printer, "\n#[derive(Clone, Debug, Default)]\n");
        let m = ctx.db.messages.get(id).unwrap();
        let name = naming::type_name(&m.type_name);
        w!(self.printer, "pub struct {} {{\n", name);
        self.printer.indent();
        for f in &m.proto.field {
            let name = naming::field_name(&f.name);
            let type_name = self.search_type(ctx, f);
            let type_name_ref = type_name.as_ref().map_or_else(|s| s.as_str(), |s| s);
            if FieldDescriptorProtoNestedLabel::LabelRepeated == f.label {
                w!(self.printer, "pub {}: Vec<{}>,\n", name, type_name_ref);
            } else if FieldDescriptorProtoNestedType::TypeMessage != f.r#type
                && FieldDescriptorProtoNestedType::TypeGroup != f.r#type
            {
                w!(self.printer, "pub {}: {},\n", name, type_name_ref);
            } else {
                w!(self.printer, "pub {}: Option<{}>,\n", name, type_name_ref);
            }
        }
        w!(
            self.printer,
            "pub cache_size: CacheSize,\npub unknown: Vec<u8>,\n"
        );
        self.printer.outdent();
        w!(self.printer, "}}\n\n");

        w!(self.printer, "impl Message for {} {{\n", name);
        self.printer.indent();

        w!(
            self.printer,
            "fn merge_from(&mut self, s: &mut CodedInputStream<impl Buf>) -> Result<()> {{\n"
        );
        self.printer.indent();
        w!(self.printer, "loop {{\n");
        self.printer.indent();
        w!(self.printer, "let tag = s.read_tag()?;\nmatch tag {{\n");
        self.printer.indent();
        for f in &m.proto.field {
            self.match_merge_from(f);
        }
        w!(
            self.printer,
            "0 => return Ok(()),\n_ => s.skip_field(&mut self.unknown, tag)?,\n"
        );
        for _ in 0..3 {
            self.printer.outdent();
            w!(self.printer, "}}\n");
        }

        w!(
            self.printer,
            "\nfn write_to(&self, s: &mut CodedOutputStream<impl BufMut>) -> Result<()> {{\n"
        );
        self.printer.indent();
        for f in &m.proto.field {
            self.field_write_to(f);
        }
        w!(self.printer, "if !self.unknown.is_empty() {{\n");
        self.printer.indent();
        w!(self.printer, "s.write_unknown(&self.unknown)?;\n");
        self.printer.outdent();
        w!(self.printer, "}}\nOk(())\n");
        self.printer.outdent();
        w!(self.printer, "}}\n");

        w!(self.printer, "\nfn len(&self) -> usize {{\n");
        self.printer.indent();
        w!(self.printer, "let mut n = self.unknown.len();\n");
        for f in &m.proto.field {
            self.field_len(f);
        }
        w!(self.printer, "n\n");
        for _ in 0..2 {
            self.printer.outdent();
            w!(self.printer, "}}\n");
        }
    }

    fn print_messages(&mut self, ctx: &Context) {
        let messages = &ctx.db.files.get(self.file).unwrap().messages;
        for m in messages {
            self.print_message(ctx, *m);
        }
    }

    pub fn generate(&mut self, ctx: &Context) -> Result<()> {
        self.print_top_boilerplate();
        self.print_imports(ctx);
        self.print_file_descriptor(ctx)?;
        self.print_enums(ctx);
        self.print_messages(ctx);
        Ok(())
    }
}
